{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst converter = require('./converter');\n\nfunction checkForInput(inputs, inputIndex) {\n  const input = inputs[inputIndex];\n  if (input === undefined) throw new Error(\"No input #\".concat(inputIndex));\n  return input;\n}\n\nexports.checkForInput = checkForInput;\n\nfunction checkForOutput(outputs, outputIndex) {\n  const output = outputs[outputIndex];\n  if (output === undefined) throw new Error(\"No output #\".concat(outputIndex));\n  return output;\n}\n\nexports.checkForOutput = checkForOutput;\n\nfunction checkHasKey(checkKeyVal, keyVals, enumLength) {\n  if (checkKeyVal.key[0] < enumLength) {\n    throw new Error(\"Use the method for your specific key instead of addUnknownKeyVal*\");\n  }\n\n  if (keyVals && keyVals.filter(kv => kv.key.equals(checkKeyVal.key)).length !== 0) {\n    throw new Error(\"Duplicate Key: \".concat(checkKeyVal.key.toString('hex')));\n  }\n}\n\nexports.checkHasKey = checkHasKey;\n\nfunction getEnumLength(myenum) {\n  let count = 0;\n  Object.keys(myenum).forEach(val => {\n    if (Number(isNaN(Number(val)))) {\n      count++;\n    }\n  });\n  return count;\n}\n\nexports.getEnumLength = getEnumLength;\n\nfunction inputCheckUncleanFinalized(inputIndex, input) {\n  let result = false;\n\n  if (!input.nonWitnessUtxo !== !input.witnessUtxo) {\n    const needScriptSig = !!input.redeemScript;\n    const needWitnessScript = !!input.witnessScript;\n    const scriptSigOK = !needScriptSig || !!input.finalScriptSig;\n    const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;\n    const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;\n    result = scriptSigOK && witnessScriptOK && hasOneFinal;\n  }\n\n  if (result === false) {\n    throw new Error(\"Input #\".concat(inputIndex, \" has too much or too little data to clean\"));\n  }\n}\n\nexports.inputCheckUncleanFinalized = inputCheckUncleanFinalized;\n\nfunction throwForUpdateMaker(typeName, name, expected, data) {\n  throw new Error(\"Data for \".concat(typeName, \" key \").concat(name, \" is incorrect: Expected \") + \"\".concat(expected, \" and got \").concat(JSON.stringify(data)));\n}\n\nfunction updateMaker(typeName) {\n  return (updateData, mainData) => {\n    for (const name of Object.keys(updateData)) {\n      // @ts-ignore\n      const data = updateData[name]; // @ts-ignore\n\n      const _ref = // @ts-ignore\n      converter[typeName + 's'][name] || {},\n            canAdd = _ref.canAdd,\n            canAddToArray = _ref.canAddToArray,\n            check = _ref.check,\n            expected = _ref.expected;\n\n      const isArray = !!canAddToArray; // If unknown data. ignore and do not add\n\n      if (check) {\n        if (isArray) {\n          if (!Array.isArray(data) || // @ts-ignore\n          mainData[name] && !Array.isArray(mainData[name])) {\n            throw new Error(\"Key type \".concat(name, \" must be an array\"));\n          }\n\n          if (!data.every(check)) {\n            throwForUpdateMaker(typeName, name, expected, data);\n          } // @ts-ignore\n\n\n          const arr = mainData[name] || [];\n          const dupeCheckSet = new Set();\n\n          if (!data.every(v => canAddToArray(arr, v, dupeCheckSet))) {\n            throw new Error('Can not add duplicate data to array');\n          } // @ts-ignore\n\n\n          mainData[name] = arr.concat(data);\n        } else {\n          if (!check(data)) {\n            throwForUpdateMaker(typeName, name, expected, data);\n          }\n\n          if (!canAdd(mainData, data)) {\n            throw new Error(\"Can not add duplicate data to \".concat(typeName));\n          } // @ts-ignore\n\n\n          mainData[name] = data;\n        }\n      }\n    }\n  };\n}\n\nexports.updateGlobal = updateMaker('global');\nexports.updateInput = updateMaker('input');\nexports.updateOutput = updateMaker('output');\n\nfunction addInputAttributes(inputs, data) {\n  const index = inputs.length - 1;\n  const input = checkForInput(inputs, index);\n  exports.updateInput(data, input);\n}\n\nexports.addInputAttributes = addInputAttributes;\n\nfunction addOutputAttributes(outputs, data) {\n  const index = outputs.length - 1;\n  const output = checkForInput(outputs, index);\n  exports.updateOutput(data, output);\n}\n\nexports.addOutputAttributes = addOutputAttributes;\n\nfunction defaultVersionSetter(version, txBuf) {\n  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {\n    throw new Error('Set Version: Invalid Transaction');\n  }\n\n  txBuf.writeUInt32LE(version, 0);\n  return txBuf;\n}\n\nexports.defaultVersionSetter = defaultVersionSetter;\n\nfunction defaultLocktimeSetter(locktime, txBuf) {\n  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {\n    throw new Error('Set Locktime: Invalid Transaction');\n  }\n\n  txBuf.writeUInt32LE(locktime, txBuf.length - 4);\n  return txBuf;\n}\n\nexports.defaultLocktimeSetter = defaultLocktimeSetter;","map":null,"metadata":{},"sourceType":"script"}