{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst queryString = require(\"query-string\"); // @ts-ignore: Could not find a declaration file for module\n\n\nconst jsontokens_1 = require(\"jsontokens\");\n\nconst authVerification_1 = require(\"./authVerification\");\n\nconst utils_1 = require(\"../utils\");\n\nconst fetchUtil_1 = require(\"../fetchUtil\");\n\nconst dids_1 = require(\"../dids\");\n\nconst errors_1 = require(\"../errors\");\n\nconst authMessages_1 = require(\"./authMessages\");\n\nconst authConstants_1 = require(\"./authConstants\");\n\nconst profileTokens_1 = require(\"../profiles/profileTokens\");\n\nconst userSession_1 = require(\"./userSession\");\n\nconst config_1 = require(\"../config\");\n\nconst logger_1 = require(\"../logger\");\n\nconst protocolEchoDetection_1 = require(\"./protocolEchoDetection\");\n\nconst protocolLaunch_1 = require(\"./protocolLaunch\");\n\nconst DEFAULT_PROFILE = {\n  '@type': 'Person',\n  '@context': 'http://schema.org'\n};\n/**\n * @deprecated\n * #### v19 Use [[UserSession.isUserSignedIn]] instead.\n *\n * Check if a user is currently signed in.\n * @return {Boolean} `true` if the user is signed in, `false` if not.\n */\n\nfunction isUserSignedIn() {\n  console.warn('DEPRECATION WARNING: The static isUserSignedIn() function will be deprecated in ' + 'the next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method isUserSignedIn().');\n  const userSession = new userSession_1.UserSession();\n  return userSession.isUserSignedIn();\n}\n\nexports.isUserSignedIn = isUserSignedIn;\n/**\n *\n *\n * @deprecated\n * #### v19 Use [[UserSession.isUserSignedIn]] instead.\n *\n * Generates an authentication request and redirects the user to the Blockstack\n * browser to approve the sign in request.\n *\n * Please note that this requires that the web browser properly handles the\n * `blockstack:` URL protocol handler.\n *\n * Most applications should use this\n * method for sign in unless they require more fine grained control over how the\n * authentication request is generated. If your app falls into this category,\n * use `makeAuthRequest` and `redirectToSignInWithAuthRequest` to build your own sign in process.\n *\n * @param {String} [redirectURI=`${window.location.origin}/`]\n * The location to which the identity provider will redirect the user after\n * the user approves sign in.\n * @param  {String} [manifestURI=`${window.location.origin}/manifest.json`]\n * Location of the manifest file.\n * @param  {Array} [scopes=DEFAULT_SCOPE] Defaults to requesting write access to\n * this app's data store.\n * An array of strings indicating which permissions this app is requesting.\n * @return {void}\n */\n\nfunction redirectToSignIn(redirectURI, manifestURI, scopes) {\n  console.warn('DEPRECATION WARNING: The static redirectToSignIn() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method redirectToSignIn().');\n  const authRequest = authMessages_1.makeAuthRequest(null, redirectURI, manifestURI, scopes);\n  redirectToSignInWithAuthRequest(authRequest);\n}\n\nexports.redirectToSignIn = redirectToSignIn;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.isSignInPending]] instead.\n *\n * Check if there is a authentication request that hasn't been handled.\n *\n * Also checks for a protocol echo reply (which if detected then the page\n * will be automatically redirected after this call).\n *\n * @return {Boolean} `true` if there is a pending sign in, otherwise `false`\n */\n\nfunction isSignInPending() {\n  try {\n    const isProtocolEcho = protocolEchoDetection_1.protocolEchoReplyDetection();\n\n    if (isProtocolEcho) {\n      logger_1.Logger.info('protocolEchoReply detected from isSignInPending call, the page is about to redirect.');\n      return true;\n    }\n  } catch (error) {\n    logger_1.Logger.error(\"Error checking for protocol echo reply isSignInPending: \".concat(error));\n  }\n\n  return !!getAuthResponseToken();\n}\n\nexports.isSignInPending = isSignInPending;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.getAuthResponseToken]] instead.\n *\n * Retrieve the authentication token from the URL query\n * @return {String} the authentication token if it exists otherwise `null`\n */\n\nfunction getAuthResponseToken() {\n  const search = utils_1.getGlobalObject('location', {\n    throwIfUnavailable: true,\n    usageDesc: 'getAuthResponseToken'\n  }).search;\n  const queryDict = queryString.parse(search);\n  return queryDict.authResponse ? queryDict.authResponse : '';\n}\n\nexports.getAuthResponseToken = getAuthResponseToken;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.loadUserData]] instead.\n *\n * Retrieves the user data object. The user's profile is stored in the key `profile`.\n * @return {Object} User data object.\n*/\n\nfunction loadUserData() {\n  console.warn('DEPRECATION WARNING: The static loadUserData() function will be deprecated in the ' + 'next major release of blockstack.js. Create an instance of UserSession and call the ' + 'instance method loadUserData().');\n  const userSession = new userSession_1.UserSession();\n  return userSession.loadUserData();\n}\n\nexports.loadUserData = loadUserData;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.signUserOut]] instead.\n *\n * Sign the user out and optionally redirect to given location.\n * @param  redirectURL\n * Location to redirect user to after sign out.\n * Only used in environments with `window` available\n */\n\nfunction signUserOut(redirectURL, caller) {\n  const userSession = caller || new userSession_1.UserSession();\n  userSession.store.deleteSessionData();\n\n  if (redirectURL) {\n    utils_1.getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: 'signUserOut'\n    }).href = redirectURL;\n  }\n}\n\nexports.signUserOut = signUserOut;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.redirectToSignInWithAuthRequest]] instead.\n *\n * Redirects the user to the Blockstack browser to approve the sign in request\n * given.\n *\n * The user is redirected to the `blockstackIDHost` if the `blockstack:`\n * protocol handler is not detected. Please note that the protocol handler detection\n * does not work on all browsers.\n * @param  {String} authRequest - the authentication request generated by `makeAuthRequest`\n * @param  {String} blockstackIDHost - the URL to redirect the user to if the blockstack\n *                                     protocol handler is not detected\n * @return {void}\n */\n\nfunction redirectToSignInWithAuthRequest(authRequest, blockstackIDHost = authConstants_1.DEFAULT_BLOCKSTACK_HOST) {\n  authRequest = authRequest || authMessages_1.makeAuthRequest();\n  const httpsURI = \"\".concat(blockstackIDHost, \"?authRequest=\").concat(authRequest);\n\n  const _utils_1$getGlobalObj = utils_1.getGlobalObjects(['navigator', 'location'], {\n    throwIfUnavailable: true,\n    usageDesc: 'redirectToSignInWithAuthRequest'\n  }),\n        navigator = _utils_1$getGlobalObj.navigator,\n        location = _utils_1$getGlobalObj.location; // If they're on a mobile OS, always redirect them to HTTPS site\n\n\n  if (/Android|webOS|iPhone|iPad|iPod|Opera Mini/i.test(navigator.userAgent)) {\n    logger_1.Logger.info('detected mobile OS, sending to https');\n    location.href = httpsURI;\n    return;\n  }\n\n  function successCallback() {\n    logger_1.Logger.info('protocol handler detected'); // The detection function should open the link for us\n  }\n\n  function failCallback() {\n    logger_1.Logger.warn('protocol handler not detected');\n    location.href = httpsURI;\n  }\n\n  protocolLaunch_1.launchCustomProtocol(authRequest, successCallback, failCallback);\n}\n\nexports.redirectToSignInWithAuthRequest = redirectToSignInWithAuthRequest;\n/**\n * @deprecated\n * #### v19 Use [[UserSession.handlePendingSignIn]] instead.\n *\n * Try to process any pending sign in request by returning a `Promise` that resolves\n * to the user data object if the sign in succeeds.\n *\n * @param {String} nameLookupURL - the endpoint against which to verify public\n * keys match claimed username\n * @param {String} authResponseToken - the signed authentication response token\n * @param {String} transitKey - the transit private key that corresponds to the transit public key\n * that was provided in the authentication request\n * @return {Promise} that resolves to the user data object if successful and rejects\n * if handling the sign in request fails or there was no pending sign in request.\n */\n\nfunction handlePendingSignIn(nameLookupURL = '', authResponseToken = getAuthResponseToken(), transitKey, caller) {\n  return __awaiter(this, void 0, void 0, function* () {\n    try {\n      const isProtocolEcho = protocolEchoDetection_1.protocolEchoReplyDetection();\n\n      if (isProtocolEcho) {\n        const msg = 'handlePendingSignIn called while protocolEchoReply was detected, and ' + 'the page is about to redirect. This function will resolve with an error after ' + 'several seconds, if the page was not redirected for some reason.';\n        logger_1.Logger.info(msg);\n        return new Promise((_resolve, reject) => {\n          setTimeout(() => {\n            logger_1.Logger.error('Page should have redirected by now. handlePendingSignIn will now throw.');\n            reject(msg);\n          }, 3000);\n        });\n      }\n    } catch (error) {\n      logger_1.Logger.error(\"Error checking for protocol echo reply handlePendingSignIn: \".concat(error));\n    }\n\n    if (!caller) {\n      caller = new userSession_1.UserSession();\n    }\n\n    const sessionData = caller.store.getSessionData();\n\n    if (sessionData.userData) {\n      throw new errors_1.LoginFailedError('Existing user session found.');\n    }\n\n    if (!transitKey) {\n      transitKey = caller.store.getSessionData().transitKey;\n    }\n\n    if (!nameLookupURL) {\n      const tokenPayload = jsontokens_1.decodeToken(authResponseToken).payload;\n\n      if (typeof tokenPayload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n      }\n\n      if (utils_1.isLaterVersion(tokenPayload.version, '1.3.0') && tokenPayload.blockstackAPIUrl !== null && tokenPayload.blockstackAPIUrl !== undefined) {\n        // override globally\n        logger_1.Logger.info(\"Overriding \".concat(config_1.config.network.blockstackAPIUrl, \" \") + \"with \".concat(tokenPayload.blockstackAPIUrl));\n        config_1.config.network.blockstackAPIUrl = tokenPayload.blockstackAPIUrl;\n      }\n\n      nameLookupURL = \"\".concat(config_1.config.network.blockstackAPIUrl).concat(authConstants_1.NAME_LOOKUP_PATH);\n    }\n\n    const isValid = yield authVerification_1.verifyAuthResponse(authResponseToken, nameLookupURL);\n\n    if (!isValid) {\n      throw new errors_1.LoginFailedError('Invalid authentication response.');\n    }\n\n    const tokenPayload = jsontokens_1.decodeToken(authResponseToken).payload;\n\n    if (typeof tokenPayload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    } // TODO: real version handling\n\n\n    let appPrivateKey = tokenPayload.private_key;\n    let coreSessionToken = tokenPayload.core_token;\n\n    if (utils_1.isLaterVersion(tokenPayload.version, '1.1.0')) {\n      if (transitKey !== undefined && transitKey != null) {\n        if (tokenPayload.private_key !== undefined && tokenPayload.private_key !== null) {\n          try {\n            appPrivateKey = authMessages_1.decryptPrivateKey(transitKey, tokenPayload.private_key);\n          } catch (e) {\n            logger_1.Logger.warn('Failed decryption of appPrivateKey, will try to use as given');\n\n            try {\n              utils_1.hexStringToECPair(tokenPayload.private_key);\n            } catch (ecPairError) {\n              throw new errors_1.LoginFailedError('Failed decrypting appPrivateKey. Usually means' + ' that the transit key has changed during login.');\n            }\n          }\n        }\n\n        if (coreSessionToken !== undefined && coreSessionToken !== null) {\n          try {\n            coreSessionToken = authMessages_1.decryptPrivateKey(transitKey, coreSessionToken);\n          } catch (e) {\n            logger_1.Logger.info('Failed decryption of coreSessionToken, will try to use as given');\n          }\n        }\n      } else {\n        throw new errors_1.LoginFailedError('Authenticating with protocol > 1.1.0 requires transit' + ' key, and none found.');\n      }\n    }\n\n    let hubUrl = authConstants_1.BLOCKSTACK_DEFAULT_GAIA_HUB_URL;\n    let gaiaAssociationToken;\n\n    if (utils_1.isLaterVersion(tokenPayload.version, '1.2.0') && tokenPayload.hubUrl !== null && tokenPayload.hubUrl !== undefined) {\n      hubUrl = tokenPayload.hubUrl;\n    }\n\n    if (utils_1.isLaterVersion(tokenPayload.version, '1.3.0') && tokenPayload.associationToken !== null && tokenPayload.associationToken !== undefined) {\n      gaiaAssociationToken = tokenPayload.associationToken;\n    }\n\n    const userData = {\n      username: tokenPayload.username,\n      profile: tokenPayload.profile,\n      email: tokenPayload.email,\n      decentralizedID: tokenPayload.iss,\n      identityAddress: dids_1.getAddressFromDID(tokenPayload.iss),\n      appPrivateKey,\n      coreSessionToken,\n      authResponseToken,\n      hubUrl,\n      gaiaAssociationToken\n    };\n    const profileURL = tokenPayload.profile_url;\n\n    if (!userData.profile && profileURL) {\n      const response = yield fetchUtil_1.fetchPrivate(profileURL);\n\n      if (!response.ok) {\n        // return blank profile if we fail to fetch\n        userData.profile = Object.assign({}, DEFAULT_PROFILE);\n      } else {\n        const responseText = yield response.text();\n        const wrappedProfile = JSON.parse(responseText);\n        const profile = profileTokens_1.extractProfile(wrappedProfile[0].token);\n        userData.profile = profile;\n      }\n    } else {\n      userData.profile = tokenPayload.profile;\n    }\n\n    sessionData.userData = userData;\n    caller.store.setSessionData(sessionData);\n    return userData;\n  });\n}\n\nexports.handlePendingSignIn = handlePendingSignIn;","map":null,"metadata":{},"sourceType":"script"}