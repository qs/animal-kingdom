{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // @ts-ignore: Could not find a declaration file for module\n\nconst jsontokens_1 = require(\"jsontokens\");\n\nconst dids_1 = require(\"../dids\");\n\nconst keys_1 = require(\"../keys\");\n\nconst utils_1 = require(\"../utils\");\n\nconst fetchUtil_1 = require(\"../fetchUtil\");\n\nconst authProvider_1 = require(\"./authProvider\");\n/**\n * Checks if the ES256k signature on passed `token` match the claimed public key\n * in the payload key `public_keys`.\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} Returns `true` if the signature matches the claimed public key\n * @throws {Error} if `token` contains multiple public keys\n * @private\n * @ignore\n */\n\n\nfunction doSignaturesMatchPublicKeys(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  const publicKeys = payload.public_keys;\n\n  if (publicKeys.length === 1) {\n    const publicKey = publicKeys[0];\n\n    try {\n      const tokenVerifier = new jsontokens_1.TokenVerifier('ES256k', publicKey);\n      const signatureVerified = tokenVerifier.verify(token);\n\n      if (signatureVerified) {\n        return true;\n      } else {\n        return false;\n      }\n    } catch (e) {\n      return false;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n}\n\nexports.doSignaturesMatchPublicKeys = doSignaturesMatchPublicKeys;\n/**\n * Makes sure that the identity address portion of\n * the decentralized identifier passed in the issuer `iss`\n * key of the token matches the public key\n *\n * @param  {String} token encoded and signed authentication token\n * @return {Boolean} if the identity address and public keys match\n * @throws {Error} if ` token` has multiple public keys\n * @private\n * @ignore\n */\n\nfunction doPublicKeysMatchIssuer(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  const publicKeys = payload.public_keys;\n  const addressFromIssuer = dids_1.getAddressFromDID(payload.iss);\n\n  if (publicKeys.length === 1) {\n    const addressFromPublicKeys = keys_1.publicKeyToAddress(publicKeys[0]);\n\n    if (addressFromPublicKeys === addressFromIssuer) {\n      return true;\n    }\n  } else {\n    throw new Error('Multiple public keys are not supported');\n  }\n\n  return false;\n}\n\nexports.doPublicKeysMatchIssuer = doPublicKeysMatchIssuer;\n/**\n * Looks up the identity address that owns the claimed username\n * in `token` using the lookup endpoint provided in `nameLookupURL`\n * to determine if the username is owned by the identity address\n * that matches the claimed public key\n *\n * @param  {String} token  encoded and signed authentication token\n * @param  {String} nameLookupURL a URL to the name lookup endpoint of the Blockstack Core API\n * @return {Promise<Boolean>} returns a `Promise` that resolves to\n * `true` if the username is owned by the public key, otherwise the\n * `Promise` resolves to `false`\n * @private\n * @ignore\n */\n\nfunction doPublicKeysMatchUsername(token, nameLookupURL) {\n  return Promise.resolve().then(() => {\n    const payload = jsontokens_1.decodeToken(token).payload;\n\n    if (typeof payload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    if (!payload.username) {\n      return true;\n    }\n\n    if (payload.username === null) {\n      return true;\n    }\n\n    if (nameLookupURL === null) {\n      return false;\n    }\n\n    const username = payload.username;\n    const url = \"\".concat(nameLookupURL.replace(/\\/$/, ''), \"/\").concat(username);\n    return fetchUtil_1.fetchPrivate(url).then(response => response.text()).then(responseText => {\n      const responseJSON = JSON.parse(responseText);\n\n      if (responseJSON.hasOwnProperty('address')) {\n        const nameOwningAddress = responseJSON.address;\n        const addressFromIssuer = dids_1.getAddressFromDID(payload.iss);\n\n        if (nameOwningAddress === addressFromIssuer) {\n          return true;\n        } else {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    });\n  }).catch(() => false);\n}\n\nexports.doPublicKeysMatchUsername = doPublicKeysMatchUsername;\n/**\n * Checks if the if the token issuance time and date is after the\n * current time and date.\n *\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the token was issued after the current time,\n * otherwise returns `false`\n * @private\n * @ignore\n */\n\nfunction isIssuanceDateValid(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  if (payload.iat) {\n    if (typeof payload.iat !== 'number') {\n      return false;\n    }\n\n    const issuedAt = new Date(payload.iat * 1000); // JWT times are in seconds\n\n    if (new Date().getTime() < issuedAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\nexports.isIssuanceDateValid = isIssuanceDateValid;\n/**\n * Checks if the expiration date of the `token` is before the current time\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if the `token` has not yet expired, `false`\n * if the `token` has expired\n *\n * @private\n * @ignore\n */\n\nfunction isExpirationDateValid(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  if (payload.exp) {\n    if (typeof payload.exp !== 'number') {\n      return false;\n    }\n\n    const expiresAt = new Date(payload.exp * 1000); // JWT times are in seconds\n\n    if (new Date().getTime() > expiresAt.getTime()) {\n      return false;\n    } else {\n      return true;\n    }\n  } else {\n    return true;\n  }\n}\n\nexports.isExpirationDateValid = isExpirationDateValid;\n/**\n * Makes sure the `manifest_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\n\nfunction isManifestUriValid(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  return utils_1.isSameOriginAbsoluteUrl(payload.domain_name, payload.manifest_uri);\n}\n\nexports.isManifestUriValid = isManifestUriValid;\n/**\n * Makes sure the `redirect_uri` is a same origin absolute URL.\n * @param  {String}  token encoded and signed authentication token\n * @return {Boolean} `true` if valid, otherwise `false`\n * @private\n * @ignore\n */\n\nfunction isRedirectUriValid(token) {\n  const payload = jsontokens_1.decodeToken(token).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  return utils_1.isSameOriginAbsoluteUrl(payload.domain_name, payload.redirect_uri);\n}\n\nexports.isRedirectUriValid = isRedirectUriValid;\n/**\n * Verify authentication request is valid. This function performs a number\n * of checks on the authentication request token:\n * * Checks that `token` has a valid issuance date & is not expired\n * * Checks that `token` has a valid signature that matches the public key it claims\n * * Checks that both the manifest and redirect URLs are absolute and conform to\n * the same origin policy\n *\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to true if the auth request\n *  is valid and false if it does not. It rejects with a String if the\n *  token is not signed\n * @private\n * @ignore\n */\n\nfunction verifyAuthRequest(token) {\n  return Promise.resolve().then(() => {\n    if (jsontokens_1.decodeToken(token).header.alg === 'none') {\n      throw new Error('Token must be signed in order to be verified');\n    }\n  }).then(() => Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), isManifestUriValid(token), isRedirectUriValid(token)])).then(values => {\n    if (values.every(Boolean)) {\n      return true;\n    } else {\n      return false;\n    }\n  });\n}\n\nexports.verifyAuthRequest = verifyAuthRequest;\n/**\n * Verify the authentication request is valid and\n * fetch the app manifest file if valid. Otherwise, reject the promise.\n * @param  {String} token encoded and signed authentication request token\n * @return {Promise} that resolves to the app manifest file in JSON format\n * or rejects if the auth request or app manifest file is invalid\n * @private\n * @ignore\n */\n\nfunction verifyAuthRequestAndLoadManifest(token) {\n  return Promise.resolve().then(() => verifyAuthRequest(token).then(valid => {\n    if (valid) {\n      return authProvider_1.fetchAppManifest(token);\n    } else {\n      return Promise.reject();\n    }\n  }));\n}\n\nexports.verifyAuthRequestAndLoadManifest = verifyAuthRequestAndLoadManifest;\n/**\n * Verify the authentication response is valid\n * @param {String} token the authentication response token\n * @param {String} nameLookupURL the url use to verify owner of a username\n * @return {Promise} that resolves to true if auth response\n * is valid and false if it does not\n * @private\n * @ignore\n */\n\nfunction verifyAuthResponse(token, nameLookupURL) {\n  return Promise.all([isExpirationDateValid(token), isIssuanceDateValid(token), doSignaturesMatchPublicKeys(token), doPublicKeysMatchIssuer(token), doPublicKeysMatchUsername(token, nameLookupURL)]).then(values => {\n    if (values.every(Boolean)) {\n      return true;\n    } else {\n      return false;\n    }\n  });\n}\n\nexports.verifyAuthResponse = verifyAuthResponse;","map":null,"metadata":{},"sourceType":"script"}