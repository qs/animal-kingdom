{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst queryString = require(\"query-string\"); // @ts-ignore: Could not find a declaration file for module\n\n\nconst jsontokens_1 = require(\"jsontokens\");\n\nconst utils_1 = require(\"../utils\");\n\nconst fetchUtil_1 = require(\"../fetchUtil\");\n\nconst logger_1 = require(\"../logger\");\n/**\n * Retrieves the authentication request from the query string\n * @return {String|null} the authentication request or `null` if\n * the query string parameter `authRequest` is not found\n * @private\n * @ignore\n */\n\n\nfunction getAuthRequestFromURL() {\n  const location = utils_1.getGlobalObject('location', {\n    throwIfUnavailable: true,\n    usageDesc: 'getAuthRequestFromURL'\n  });\n  const queryDict = queryString.parse(location.search);\n\n  if (queryDict.authRequest) {\n    return queryDict.authRequest.split(\"\".concat(utils_1.BLOCKSTACK_HANDLER, \":\")).join('');\n  } else {\n    return null;\n  }\n}\n\nexports.getAuthRequestFromURL = getAuthRequestFromURL;\n/**\n * Fetches the contents of the manifest file specified in the authentication request\n *\n * @param  {String} authRequest encoded and signed authentication request\n * @return {Promise<Object|String>} Returns a `Promise` that resolves to the JSON\n * object manifest file unless there's an error in which case rejects with an error\n * message.\n * @private\n * @ignore\n */\n\nfunction fetchAppManifest(authRequest) {\n  return new Promise((resolve, reject) => {\n    if (!authRequest) {\n      reject('Invalid auth request');\n    } else {\n      const payload = jsontokens_1.decodeToken(authRequest).payload;\n\n      if (typeof payload === 'string') {\n        throw new Error('Unexpected token payload type of string');\n      }\n\n      const manifestURI = payload.manifest_uri;\n\n      try {\n        logger_1.Logger.debug(\"Fetching manifest from \".concat(manifestURI));\n        fetchUtil_1.fetchPrivate(manifestURI).then(response => response.text()).then(responseText => JSON.parse(responseText)).then(responseJSON => {\n          resolve(Object.assign({}, responseJSON, {\n            manifestURI\n          }));\n        }).catch(e => {\n          logger_1.Logger.debug(e.stack);\n          reject('Could not fetch manifest.json');\n        });\n      } catch (e) {\n        logger_1.Logger.debug(e.stack);\n        reject('Could not fetch manifest.json');\n      }\n    }\n  });\n}\n\nexports.fetchAppManifest = fetchAppManifest;\n/**\n * Redirect the user's browser to the app using the `redirect_uri`\n * specified in the authentication request, passing the authentication\n * response token as a query parameter.\n *\n * @param {String} authRequest  encoded and signed authentication request token\n * @param {String} authResponse encoded and signed authentication response token\n * @return {void}\n * @throws {Error} if there is no redirect uri\n * @private\n * @ignore\n */\n\nfunction redirectUserToApp(authRequest, authResponse) {\n  const payload = jsontokens_1.decodeToken(authRequest).payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  }\n\n  let redirectURI = payload.redirect_uri;\n  logger_1.Logger.debug(redirectURI);\n\n  if (redirectURI) {\n    redirectURI = utils_1.updateQueryStringParameter(redirectURI, 'authResponse', authResponse);\n  } else {\n    throw new Error('Invalid redirect URI');\n  }\n\n  const location = utils_1.getGlobalObject('location', {\n    throwIfUnavailable: true,\n    usageDesc: 'redirectUserToApp'\n  });\n  location.href = redirectURI;\n}\n\nexports.redirectUserToApp = redirectUserToApp;","map":null,"metadata":{},"sourceType":"script"}