{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst base64url_1 = __importDefault(require(\"base64url\"));\n\nconst cryptoClients_1 = require(\"./cryptoClients\");\n\nconst errors_1 = require(\"./errors\");\n\nclass TokenVerifier {\n  constructor(signingAlgorithm, rawPublicKey) {\n    if (!(signingAlgorithm && rawPublicKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and public key are required');\n    }\n\n    if (typeof signingAlgorithm !== 'string') {\n      throw 'signing algorithm parameter must be a string';\n    }\n\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw 'invalid signing algorithm';\n    }\n\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPublicKey = rawPublicKey;\n  }\n\n  verify(token) {\n    if (typeof token === 'string') {\n      return this.verifyCompact(token);\n    } else if (typeof token === 'object') {\n      return this.verifyExpanded(token);\n    } else {\n      return false;\n    }\n  }\n\n  verifyCompact(token) {\n    // decompose the token into parts\n    const tokenParts = token.split('.'); // calculate the signing input hash\n\n    const signingInput = tokenParts[0] + '.' + tokenParts[1];\n    const signingInputHash = this.cryptoClient.createHash(signingInput); // extract the signature as a DER array\n\n    const derSignatureBuffer = this.cryptoClient.loadSignature(tokenParts[2]); // verify the signed hash\n\n    return this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);\n  }\n\n  verifyExpanded(token) {\n    const signingInput = [token['header'].join('.'), base64url_1.default.encode(token['payload'])].join('.');\n    const signingInputHash = this.cryptoClient.createHash(signingInput);\n    let verified = true;\n    token['signature'].map(signature => {\n      const derSignatureBuffer = this.cryptoClient.loadSignature(signature);\n      const signatureVerified = this.cryptoClient.verifyHash(signingInputHash, derSignatureBuffer, this.rawPublicKey);\n\n      if (!signatureVerified) {\n        verified = false;\n      }\n    });\n    return verified;\n  }\n\n}\n\nexports.TokenVerifier = TokenVerifier;","map":null,"metadata":{},"sourceType":"script"}