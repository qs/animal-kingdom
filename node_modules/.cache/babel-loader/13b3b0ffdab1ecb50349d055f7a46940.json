{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n\nconst FormData = require(\"form-data\"); // @ts-ignore\n\n\nconst BN = require(\"bn.js\");\n\nconst RIPEMD160 = require(\"ripemd160\");\n\nconst errors_1 = require(\"./errors\");\n\nconst logger_1 = require(\"./logger\");\n\nconst config_1 = require(\"./config\");\n\nconst fetchUtil_1 = require(\"./fetchUtil\");\n\nconst SATOSHIS_PER_BTC = 1e8;\nconst TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT = 'zone-file';\nconst TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT = 'registration';\nconst TX_BROADCAST_SERVICE_TX_ENDPOINT = 'transaction';\n/**\n * @private\n * @ignore\n */\n\nclass BitcoinNetwork {\n  broadcastTransaction(transaction) {\n    return Promise.reject(new Error(\"Not implemented, broadcastTransaction(\".concat(transaction, \")\")));\n  }\n\n  getBlockHeight() {\n    return Promise.reject(new Error('Not implemented, getBlockHeight()'));\n  }\n\n  getTransactionInfo(txid) {\n    return Promise.reject(new Error(\"Not implemented, getTransactionInfo(\".concat(txid, \")\")));\n  }\n\n  getNetworkedUTXOs(address) {\n    return Promise.reject(new Error(\"Not implemented, getNetworkedUTXOs(\".concat(address, \")\")));\n  }\n\n}\n\nexports.BitcoinNetwork = BitcoinNetwork;\n/**\n * @private\n * @ignore\n */\n\nclass BlockstackNetwork {\n  constructor(apiUrl, broadcastServiceUrl, bitcoinAPI, network = bitcoinjs_lib_1.networks.bitcoin) {\n    this.blockstackAPIUrl = apiUrl;\n    this.broadcastServiceUrl = broadcastServiceUrl;\n    this.layer1 = network;\n    this.btc = bitcoinAPI;\n    this.DUST_MINIMUM = 5500;\n    this.includeUtxoMap = {};\n    this.excludeUtxoSet = [];\n    this.MAGIC_BYTES = 'id';\n  }\n\n  coerceAddress(address) {\n    const _bitcoinjs_lib_1$addr = bitcoinjs_lib_1.address.fromBase58Check(address),\n          hash = _bitcoinjs_lib_1$addr.hash,\n          version = _bitcoinjs_lib_1$addr.version;\n\n    const scriptHashes = [bitcoinjs_lib_1.networks.bitcoin.scriptHash, bitcoinjs_lib_1.networks.testnet.scriptHash];\n    const pubKeyHashes = [bitcoinjs_lib_1.networks.bitcoin.pubKeyHash, bitcoinjs_lib_1.networks.testnet.pubKeyHash];\n    let coercedVersion;\n\n    if (scriptHashes.indexOf(version) >= 0) {\n      coercedVersion = this.layer1.scriptHash;\n    } else if (pubKeyHashes.indexOf(version) >= 0) {\n      coercedVersion = this.layer1.pubKeyHash;\n    } else {\n      throw new Error(\"Unrecognized address version number \".concat(version, \" in \").concat(address));\n    }\n\n    return bitcoinjs_lib_1.address.toBase58Check(hash, coercedVersion);\n  }\n  /**\n  * @ignore\n  */\n\n\n  getDefaultBurnAddress() {\n    return this.coerceAddress('1111111111111111111114oLvT2');\n  }\n  /**\n   * Get the price of a name via the legacy /v1/prices API endpoint.\n   * @param {String} fullyQualifiedName the name to query\n   * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }\n   * @private\n   */\n\n\n  getNamePriceV1(fullyQualifiedName) {\n    // legacy code path\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/prices/names/\").concat(fullyQualifiedName)).then(resp => {\n      if (!resp.ok) {\n        throw new Error(\"Failed to query name price for \".concat(fullyQualifiedName));\n      }\n\n      return resp;\n    }).then(resp => resp.json()).then(resp => resp.name_price).then(namePrice => {\n      if (!namePrice || !namePrice.satoshis) {\n        throw new Error(\"Failed to get price for \".concat(fullyQualifiedName, \". Does the namespace exist?\"));\n      }\n\n      if (namePrice.satoshis < this.DUST_MINIMUM) {\n        namePrice.satoshis = this.DUST_MINIMUM;\n      }\n\n      const result = {\n        units: 'BTC',\n        amount: new BN(String(namePrice.satoshis))\n      };\n      return result;\n    });\n  }\n  /**\n   * Get the price of a namespace via the legacy /v1/prices API endpoint.\n   * @param {String} namespaceID the namespace to query\n   * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }\n   * @private\n   */\n\n\n  getNamespacePriceV1(namespaceID) {\n    // legacy code path\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/prices/namespaces/\").concat(namespaceID)).then(resp => {\n      if (!resp.ok) {\n        throw new Error(\"Failed to query name price for \".concat(namespaceID));\n      }\n\n      return resp;\n    }).then(resp => resp.json()).then(namespacePrice => {\n      if (!namespacePrice || !namespacePrice.satoshis) {\n        throw new Error(\"Failed to get price for \".concat(namespaceID));\n      }\n\n      if (namespacePrice.satoshis < this.DUST_MINIMUM) {\n        namespacePrice.satoshis = this.DUST_MINIMUM;\n      }\n\n      const result = {\n        units: 'BTC',\n        amount: new BN(String(namespacePrice.satoshis))\n      };\n      return result;\n    });\n  }\n  /**\n   * Get the price of a name via the /v2/prices API endpoint.\n   * @param {String} fullyQualifiedName the name to query\n   * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }\n   * @private\n   */\n\n\n  getNamePriceV2(fullyQualifiedName) {\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v2/prices/names/\").concat(fullyQualifiedName)).then(resp => {\n      if (resp.status !== 200) {\n        // old core node \n        throw new Error('The upstream node does not handle the /v2/ price namespace');\n      }\n\n      return resp;\n    }).then(resp => resp.json()).then(resp => resp.name_price).then(namePrice => {\n      if (!namePrice) {\n        throw new Error(\"Failed to get price for \".concat(fullyQualifiedName, \". Does the namespace exist?\"));\n      }\n\n      const result = {\n        units: namePrice.units,\n        amount: new BN(namePrice.amount)\n      };\n\n      if (namePrice.units === 'BTC') {\n        // must be at least dust-minimum\n        const dustMin = new BN(String(this.DUST_MINIMUM));\n\n        if (result.amount.ucmp(dustMin) < 0) {\n          result.amount = dustMin;\n        }\n      }\n\n      return result;\n    });\n  }\n  /**\n   * Get the price of a namespace via the /v2/prices API endpoint.\n   * @param {String} namespaceID the namespace to query\n   * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }\n   * @private\n   */\n\n\n  getNamespacePriceV2(namespaceID) {\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v2/prices/namespaces/\").concat(namespaceID)).then(resp => {\n      if (resp.status !== 200) {\n        // old core node \n        throw new Error('The upstream node does not handle the /v2/ price namespace');\n      }\n\n      return resp;\n    }).then(resp => resp.json()).then(namespacePrice => {\n      if (!namespacePrice) {\n        throw new Error(\"Failed to get price for \".concat(namespaceID));\n      }\n\n      const result = {\n        units: namespacePrice.units,\n        amount: new BN(namespacePrice.amount)\n      };\n\n      if (namespacePrice.units === 'BTC') {\n        // must be at least dust-minimum\n        const dustMin = new BN(String(this.DUST_MINIMUM));\n\n        if (result.amount.ucmp(dustMin) < 0) {\n          result.amount = dustMin;\n        }\n      }\n\n      return result;\n    });\n  }\n  /**\n   * Get the price of a name.\n   * @param {String} fullyQualifiedName the name to query\n   * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }, where\n   *   .units encodes the cryptocurrency units to pay (e.g. BTC, STACKS), and\n   *   .amount encodes the number of units, in the smallest denominiated amount\n   *   (e.g. if .units is BTC, .amount will be satoshis; if .units is STACKS,\n   *   .amount will be microStacks)\n   */\n\n\n  getNamePrice(fullyQualifiedName) {\n    // handle v1 or v2 \n    return Promise.resolve().then(() => this.getNamePriceV2(fullyQualifiedName)).catch(() => this.getNamePriceV1(fullyQualifiedName));\n  }\n  /**\n   * Get the price of a namespace\n   * @param {String} namespaceID the namespace to query\n   * @return {Promise} a promise to an Object with { units: String, amount: BigInteger }, where\n   *   .units encodes the cryptocurrency units to pay (e.g. BTC, STACKS), and\n   *   .amount encodes the number of units, in the smallest denominiated amount\n   *   (e.g. if .units is BTC, .amount will be satoshis; if .units is STACKS,\n   *   .amount will be microStacks)\n   */\n\n\n  getNamespacePrice(namespaceID) {\n    // handle v1 or v2 \n    return Promise.resolve().then(() => this.getNamespacePriceV2(namespaceID)).catch(() => this.getNamespacePriceV1(namespaceID));\n  }\n  /**\n   * How many blocks can pass between a name expiring and the name being able to be\n   * re-registered by a different owner?\n   * @param {string} fullyQualifiedName unused\n   * @return {Promise} a promise to the number of blocks\n   */\n\n\n  getGracePeriod(fullyQualifiedName) {\n    return Promise.resolve(5000);\n  }\n  /**\n   * Get the names -- both on-chain and off-chain -- owned by an address.\n   * @param {String} address the blockchain address (the hash of the owner public key)\n   * @return {Promise} a promise that resolves to a list of names (Strings)\n   */\n\n\n  getNamesOwned(address) {\n    const networkAddress = this.coerceAddress(address);\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/addresses/bitcoin/\").concat(networkAddress)).then(resp => resp.json()).then(obj => obj.names);\n  }\n  /**\n   * Get the blockchain address to which a name's registration fee must be sent\n   * (the address will depend on the namespace in which it is registered.)\n   * @param {String} namespace the namespace ID\n   * @return {Promise} a promise that resolves to an address (String)\n   */\n\n\n  getNamespaceBurnAddress(namespace) {\n    return Promise.all([fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/namespaces/\").concat(namespace)), this.getBlockHeight()]).then(([resp, blockHeight]) => {\n      if (resp.status === 404) {\n        throw new Error(\"No such namespace '\".concat(namespace, \"'\"));\n      } else {\n        return Promise.all([resp.json(), blockHeight]);\n      }\n    }).then(([namespaceInfo, blockHeight]) => {\n      let address = this.getDefaultBurnAddress();\n\n      if (namespaceInfo.version === 2) {\n        // pay-to-namespace-creator if this namespace is less than 1 year old\n        if (namespaceInfo.reveal_block + 52595 >= blockHeight) {\n          address = namespaceInfo.address;\n        }\n      }\n\n      return address;\n    }).then(address => this.coerceAddress(address));\n  }\n  /**\n   * Get WHOIS-like information for a name, including the address that owns it,\n   * the block at which it expires, and the zone file anchored to it (if available).\n   * @param {String} fullyQualifiedName the name to query.  Can be on-chain of off-chain.\n   * @return {Promise} a promise that resolves to the WHOIS-like information\n   */\n\n\n  getNameInfo(fullyQualifiedName) {\n    logger_1.Logger.debug(this.blockstackAPIUrl);\n    const nameLookupURL = \"\".concat(this.blockstackAPIUrl, \"/v1/names/\").concat(fullyQualifiedName);\n    return fetchUtil_1.fetchPrivate(nameLookupURL).then(resp => {\n      if (resp.status === 404) {\n        throw new Error('Name not found');\n      } else if (resp.status !== 200) {\n        throw new Error(\"Bad response status: \".concat(resp.status));\n      } else {\n        return resp.json();\n      }\n    }).then(nameInfo => {\n      logger_1.Logger.debug(\"nameInfo: \".concat(JSON.stringify(nameInfo))); // the returned address _should_ be in the correct network ---\n      //  blockstackd gets into trouble because it tries to coerce back to mainnet\n      //  and the regtest transaction generation libraries want to use testnet addresses\n\n      if (nameInfo.address) {\n        return Object.assign({}, nameInfo, {\n          address: this.coerceAddress(nameInfo.address)\n        });\n      } else {\n        return nameInfo;\n      }\n    });\n  }\n  /**\n   * Get the pricing parameters and creation history of a namespace.\n   * @param {String} namespaceID the namespace to query\n   * @return {Promise} a promise that resolves to the namespace information.\n   */\n\n\n  getNamespaceInfo(namespaceID) {\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/namespaces/\").concat(namespaceID)).then(resp => {\n      if (resp.status === 404) {\n        throw new Error('Namespace not found');\n      } else if (resp.status !== 200) {\n        throw new Error(\"Bad response status: \".concat(resp.status));\n      } else {\n        return resp.json();\n      }\n    }).then(namespaceInfo => {\n      // the returned address _should_ be in the correct network ---\n      //  blockstackd gets into trouble because it tries to coerce back to mainnet\n      //  and the regtest transaction generation libraries want to use testnet addresses\n      if (namespaceInfo.address && namespaceInfo.recipient_address) {\n        return Object.assign({}, namespaceInfo, {\n          address: this.coerceAddress(namespaceInfo.address),\n          recipient_address: this.coerceAddress(namespaceInfo.recipient_address)\n        });\n      } else {\n        return namespaceInfo;\n      }\n    });\n  }\n  /**\n   * Get a zone file, given its hash.  Throws an exception if the zone file\n   * obtained does not match the hash.\n   * @param {String} zonefileHash the ripemd160(sha256) hash of the zone file\n   * @return {Promise} a promise that resolves to the zone file's text\n   */\n\n\n  getZonefile(zonefileHash) {\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/zonefiles/\").concat(zonefileHash)).then(resp => {\n      if (resp.status === 200) {\n        return resp.text().then(body => {\n          const sha256 = bitcoinjs_lib_1.crypto.sha256(Buffer.from(body));\n          const h = new RIPEMD160().update(sha256).digest('hex');\n\n          if (h !== zonefileHash) {\n            throw new Error(\"Zone file contents hash to \".concat(h, \", not \").concat(zonefileHash));\n          }\n\n          return body;\n        });\n      } else {\n        throw new Error(\"Bad response status: \".concat(resp.status));\n      }\n    });\n  }\n  /**\n   * Get the status of an account for a particular token holding.  This includes its total number of\n   * expenditures and credits, lockup times, last txid, and so on.\n   * @param {String} address the account\n   * @param {String} tokenType the token type to query\n   * @return {Promise} a promise that resolves to an object representing the state of the account\n   *   for this token\n   */\n\n\n  getAccountStatus(address, tokenType) {\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/accounts/\").concat(address, \"/\").concat(tokenType, \"/status\")).then(resp => {\n      if (resp.status === 404) {\n        throw new Error('Account not found');\n      } else if (resp.status !== 200) {\n        throw new Error(\"Bad response status: \".concat(resp.status));\n      } else {\n        return resp.json();\n      }\n    }).then(accountStatus => {\n      // coerce all addresses, and convert credit/debit to biginteger\n      const formattedStatus = Object.assign({}, accountStatus, {\n        address: this.coerceAddress(accountStatus.address),\n        debit_value: new BN(String(accountStatus.debit_value)),\n        credit_value: new BN(String(accountStatus.credit_value))\n      });\n      return formattedStatus;\n    });\n  }\n  /**\n   * Get a page of an account's transaction history.\n   * @param {String} address the account's address\n   * @param {number} page the page number.  Page 0 is the most recent transactions\n   * @return {Promise} a promise that resolves to an Array of Objects, where each Object encodes\n   *   states of the account at various block heights (e.g. prior balances, txids, etc)\n   */\n\n\n  getAccountHistoryPage(address, page) {\n    const url = \"\".concat(this.blockstackAPIUrl, \"/v1/accounts/\").concat(address, \"/history?page=\").concat(page);\n    return fetchUtil_1.fetchPrivate(url).then(resp => {\n      if (resp.status === 404) {\n        throw new Error('Account not found');\n      } else if (resp.status !== 200) {\n        throw new Error(\"Bad response status: \".concat(resp.status));\n      } else {\n        return resp.json();\n      }\n    }).then(historyList => {\n      if (historyList.error) {\n        throw new Error(\"Unable to get account history page: \".concat(historyList.error));\n      } // coerse all addresses and convert to bigint\n\n\n      return historyList.map(histEntry => {\n        histEntry.address = this.coerceAddress(histEntry.address);\n        histEntry.debit_value = new BN(String(histEntry.debit_value));\n        histEntry.credit_value = new BN(String(histEntry.credit_value));\n        return histEntry;\n      });\n    });\n  }\n  /**\n   * Get the state(s) of an account at a particular block height.  This includes the state of the\n   * account beginning with this block's transactions, as well as all of the states the account\n   * passed through when this block was processed (if any).\n   * @param {String} address the account's address\n   * @param {Integer} blockHeight the block to query\n   * @return {Promise} a promise that resolves to an Array of Objects, where each Object encodes\n   *   states of the account at this block.\n   */\n\n\n  getAccountAt(address, blockHeight) {\n    const url = \"\".concat(this.blockstackAPIUrl, \"/v1/accounts/\").concat(address, \"/history/\").concat(blockHeight);\n    return fetchUtil_1.fetchPrivate(url).then(resp => {\n      if (resp.status === 404) {\n        throw new Error('Account not found');\n      } else if (resp.status !== 200) {\n        throw new Error(\"Bad response status: \".concat(resp.status));\n      } else {\n        return resp.json();\n      }\n    }).then(historyList => {\n      if (historyList.error) {\n        throw new Error(\"Unable to get historic account state: \".concat(historyList.error));\n      } // coerce all addresses \n\n\n      return historyList.map(histEntry => {\n        histEntry.address = this.coerceAddress(histEntry.address);\n        histEntry.debit_value = new BN(String(histEntry.debit_value));\n        histEntry.credit_value = new BN(String(histEntry.credit_value));\n        return histEntry;\n      });\n    });\n  }\n  /**\n   * Get the set of token types that this account owns\n   * @param {String} address the account's address\n   * @return {Promise} a promise that resolves to an Array of Strings, where each item encodes the\n   *   type of token this account holds (excluding the underlying blockchain's tokens)\n   */\n\n\n  getAccountTokens(address) {\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/accounts/\").concat(address, \"/tokens\")).then(resp => {\n      if (resp.status === 404) {\n        throw new Error('Account not found');\n      } else if (resp.status !== 200) {\n        throw new Error(\"Bad response status: \".concat(resp.status));\n      } else {\n        return resp.json();\n      }\n    }).then(tokenList => {\n      if (tokenList.error) {\n        throw new Error(\"Unable to get token list: \".concat(tokenList.error));\n      }\n\n      return tokenList;\n    });\n  }\n  /**\n   * Get the number of tokens owned by an account.  If the account does not exist or has no\n   * tokens of this type, then 0 will be returned.\n   * @param {String} address the account's address\n   * @param {String} tokenType the type of token to query.\n   * @return {Promise} a promise that resolves to a BigInteger that encodes the number of tokens\n   *   held by this account.\n   */\n\n\n  getAccountBalance(address, tokenType) {\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/accounts/\").concat(address, \"/\").concat(tokenType, \"/balance\")).then(resp => {\n      if (resp.status === 404) {\n        // talking to an older blockstack core node without the accounts API\n        return Promise.resolve().then(() => new BN('0'));\n      } else if (resp.status !== 200) {\n        throw new Error(\"Bad response status: \".concat(resp.status));\n      } else {\n        return resp.json();\n      }\n    }).then(tokenBalance => {\n      if (tokenBalance.error) {\n        throw new Error(\"Unable to get account balance: \".concat(tokenBalance.error));\n      }\n\n      let balance = '0';\n\n      if (tokenBalance && tokenBalance.balance) {\n        balance = tokenBalance.balance;\n      }\n\n      return new BN(balance);\n    });\n  }\n  /**\n   * Performs a POST request to the given URL\n   * @param  {String} endpoint  the name of\n   * @param  {String} body [description]\n   * @return {Promise<Object|Error>} Returns a `Promise` that resolves to the object requested.\n   * In the event of an error, it rejects with:\n   * * a `RemoteServiceError` if there is a problem\n   * with the transaction broadcast service\n   * * `MissingParameterError` if you call the function without a required\n   * parameter\n   *\n   * @private\n   */\n\n\n  broadcastServiceFetchHelper(endpoint, body) {\n    const requestHeaders = {\n      Accept: 'application/json',\n      'Content-Type': 'application/json'\n    };\n    const options = {\n      method: 'POST',\n      headers: requestHeaders,\n      body: JSON.stringify(body)\n    };\n    const url = \"\".concat(this.broadcastServiceUrl, \"/v1/broadcast/\").concat(endpoint);\n    return fetchUtil_1.fetchPrivate(url, options).then(response => {\n      if (response.ok) {\n        return response.json();\n      } else {\n        throw new errors_1.RemoteServiceError(response);\n      }\n    });\n  }\n  /**\n  * Broadcasts a signed bitcoin transaction to the network optionally waiting to broadcast the\n  * transaction until a second transaction has a certain number of confirmations.\n  *\n  * @param  {string} transaction the hex-encoded transaction to broadcast\n  * @param  {string} transactionToWatch the hex transaction id of the transaction to watch for\n  * the specified number of confirmations before broadcasting the `transaction`\n  * @param  {number} confirmations the number of confirmations `transactionToWatch` must have\n  * before broadcasting `transaction`.\n  * @return {Promise<Object|Error>} Returns a Promise that resolves to an object with a\n  * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\n  *\n  * In the event of an error, it rejects with:\n  * * a `RemoteServiceError` if there is a problem\n  *   with the transaction broadcast service\n  * * `MissingParameterError` if you call the function without a required\n  *   parameter\n  * @private\n  */\n\n\n  broadcastTransaction(transaction, transactionToWatch = null, confirmations = 6) {\n    if (!transaction) {\n      const error = new errors_1.MissingParameterError('transaction');\n      return Promise.reject(error);\n    }\n\n    if (!confirmations && confirmations !== 0) {\n      const error = new errors_1.MissingParameterError('confirmations');\n      return Promise.reject(error);\n    }\n\n    if (transactionToWatch === null) {\n      return this.btc.broadcastTransaction(transaction);\n    } else {\n      /*\n       * POST /v1/broadcast/transaction\n       * Request body:\n       * JSON.stringify({\n       *  transaction,\n       *  transactionToWatch,\n       *  confirmations\n       * })\n       */\n      const endpoint = TX_BROADCAST_SERVICE_TX_ENDPOINT;\n      const requestBody = {\n        transaction,\n        transactionToWatch,\n        confirmations\n      };\n      return this.broadcastServiceFetchHelper(endpoint, requestBody);\n    }\n  }\n  /**\n   * Broadcasts a zone file to the Atlas network via the transaction broadcast service.\n   *\n   * @param  {String} zoneFile the zone file to be broadcast to the Atlas network\n   * @param  {String} transactionToWatch the hex transaction id of the transaction\n   * to watch for confirmation before broadcasting the zone file to the Atlas network\n   * @return {Promise<Object|Error>} Returns a Promise that resolves to an object with a\n   * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\n   *\n   * In the event of an error, it rejects with:\n   * * a `RemoteServiceError` if there is a problem\n   *   with the transaction broadcast service\n   * * `MissingParameterError` if you call the function without a required\n   *   parameter\n   * @private\n   */\n\n\n  broadcastZoneFile(zoneFile, transactionToWatch = null) {\n    if (!zoneFile) {\n      return Promise.reject(new errors_1.MissingParameterError('zoneFile'));\n    } // TODO: validate zonefile\n\n\n    if (transactionToWatch) {\n      // broadcast via transaction broadcast service\n\n      /*\n       * POST /v1/broadcast/zone-file\n       * Request body:\n       * JSON.stringify({\n       *  zoneFile,\n       *  transactionToWatch\n       * })\n       */\n      const requestBody = {\n        zoneFile,\n        transactionToWatch\n      };\n      const endpoint = TX_BROADCAST_SERVICE_ZONE_FILE_ENDPOINT;\n      return this.broadcastServiceFetchHelper(endpoint, requestBody);\n    } else {\n      // broadcast via core endpoint\n      // zone file is two words but core's api treats it as one word 'zonefile'\n      const requestBody = {\n        zonefile: zoneFile\n      };\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/zonefile/\"), {\n        method: 'POST',\n        body: JSON.stringify(requestBody),\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      }).then(resp => {\n        const json = resp.json();\n        return json.then(respObj => {\n          if (respObj.hasOwnProperty('error')) {\n            throw new errors_1.RemoteServiceError(resp);\n          }\n\n          return respObj.servers;\n        });\n      });\n    }\n  }\n  /**\n   * Sends the preorder and registration transactions and zone file\n   * for a Blockstack name registration\n   * along with the to the transaction broadcast service.\n   *\n   * The transaction broadcast:\n   *\n   * * immediately broadcasts the preorder transaction\n   * * broadcasts the register transactions after the preorder transaction\n   * has an appropriate number of confirmations\n   * * broadcasts the zone file to the Atlas network after the register transaction\n   * has an appropriate number of confirmations\n   *\n   * @param  {String} preorderTransaction the hex-encoded, signed preorder transaction generated\n   * using the `makePreorder` function\n   * @param  {String} registerTransaction the hex-encoded, signed register transaction generated\n   * using the `makeRegister` function\n   * @param  {String} zoneFile the zone file to be broadcast to the Atlas network\n   * @return {Promise<Object|Error>} Returns a Promise that resolves to an object with a\n   * `transaction_hash` key containing the transaction hash of the broadcasted transaction.\n   *\n   * In the event of an error, it rejects with:\n   * * a `RemoteServiceError` if there is a problem\n   *   with the transaction broadcast service\n   * * `MissingParameterError` if you call the function without a required\n   *   parameter\n   * @private\n   */\n\n\n  broadcastNameRegistration(preorderTransaction, registerTransaction, zoneFile) {\n    /*\n       * POST /v1/broadcast/registration\n       * Request body:\n       * JSON.stringify({\n       * preorderTransaction,\n       * registerTransaction,\n       * zoneFile\n       * })\n       */\n    if (!preorderTransaction) {\n      const error = new errors_1.MissingParameterError('preorderTransaction');\n      return Promise.reject(error);\n    }\n\n    if (!registerTransaction) {\n      const error = new errors_1.MissingParameterError('registerTransaction');\n      return Promise.reject(error);\n    }\n\n    if (!zoneFile) {\n      const error = new errors_1.MissingParameterError('zoneFile');\n      return Promise.reject(error);\n    }\n\n    const requestBody = {\n      preorderTransaction,\n      registerTransaction,\n      zoneFile\n    };\n    const endpoint = TX_BROADCAST_SERVICE_REGISTRATION_ENDPOINT;\n    return this.broadcastServiceFetchHelper(endpoint, requestBody);\n  }\n  /**\n   * @ignore\n   */\n\n\n  getFeeRate() {\n    return fetchUtil_1.fetchPrivate('https://bitcoinfees.earn.com/api/v1/fees/recommended').then(resp => resp.json()).then(rates => Math.floor(rates.fastestFee));\n  }\n  /**\n   * @ignore\n   */\n\n\n  countDustOutputs() {\n    throw new Error('Not implemented.');\n  }\n  /**\n   * @ignore\n   */\n\n\n  getUTXOs(address) {\n    return this.getNetworkedUTXOs(address).then(networkedUTXOs => {\n      let returnSet = networkedUTXOs.concat();\n\n      if (this.includeUtxoMap.hasOwnProperty(address)) {\n        returnSet = networkedUTXOs.concat(this.includeUtxoMap[address]);\n      } // aaron: I am *well* aware this is O(n)*O(m) runtime\n      //    however, clients should clear the exclude set periodically\n\n\n      const excludeSet = this.excludeUtxoSet;\n      returnSet = returnSet.filter(utxo => {\n        const inExcludeSet = excludeSet.reduce((inSet, utxoToCheck) => inSet || utxoToCheck.tx_hash === utxo.tx_hash && utxoToCheck.tx_output_n === utxo.tx_output_n, false);\n        return !inExcludeSet;\n      });\n      return returnSet;\n    });\n  }\n  /**\n   * This will modify the network's utxo set to include UTXOs\n   *  from the given transaction and exclude UTXOs *spent* in\n   *  that transaction\n   * @param {String} txHex - the hex-encoded transaction to use\n   * @return {void} no return value, this modifies the UTXO config state\n   * @private\n   * @ignore\n   */\n\n\n  modifyUTXOSetFrom(txHex) {\n    const tx = bitcoinjs_lib_1.Transaction.fromHex(txHex);\n    const excludeSet = this.excludeUtxoSet.concat();\n    tx.ins.forEach(utxoUsed => {\n      const reverseHash = Buffer.from(utxoUsed.hash);\n      reverseHash.reverse();\n      excludeSet.push({\n        tx_hash: reverseHash.toString('hex'),\n        tx_output_n: utxoUsed.index\n      });\n    });\n    this.excludeUtxoSet = excludeSet;\n    const txHash = Buffer.from(tx.getHash().reverse()).toString('hex');\n    tx.outs.forEach((utxoCreated, txOutputN) => {\n      const isNullData = function isNullData(script) {\n        try {\n          bitcoinjs_lib_1.payments.embed({\n            output: script\n          }, {\n            validate: true\n          });\n          return true;\n        } catch (_) {\n          return false;\n        }\n      };\n\n      if (isNullData(utxoCreated.script)) {\n        return;\n      }\n\n      const address = bitcoinjs_lib_1.address.fromOutputScript(utxoCreated.script, this.layer1);\n      let includeSet = [];\n\n      if (this.includeUtxoMap.hasOwnProperty(address)) {\n        includeSet = includeSet.concat(this.includeUtxoMap[address]);\n      }\n\n      includeSet.push({\n        tx_hash: txHash,\n        confirmations: 0,\n        value: utxoCreated.value,\n        tx_output_n: txOutputN\n      });\n      this.includeUtxoMap[address] = includeSet;\n    });\n  }\n\n  resetUTXOs(address) {\n    delete this.includeUtxoMap[address];\n    this.excludeUtxoSet = [];\n  }\n  /**\n  * @ignore\n  */\n\n\n  getConsensusHash() {\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.blockstackAPIUrl, \"/v1/blockchains/bitcoin/consensus\")).then(resp => resp.json()).then(x => x.consensus_hash);\n  }\n\n  getTransactionInfo(txHash) {\n    return this.btc.getTransactionInfo(txHash);\n  }\n  /**\n   * @ignore\n   */\n\n\n  getBlockHeight() {\n    return this.btc.getBlockHeight();\n  }\n\n  getNetworkedUTXOs(address) {\n    return this.btc.getNetworkedUTXOs(address);\n  }\n\n}\n\nexports.BlockstackNetwork = BlockstackNetwork;\n/**\n * @ignore\n */\n\nclass LocalRegtest extends BlockstackNetwork {\n  constructor(apiUrl, broadcastServiceUrl, bitcoinAPI) {\n    super(apiUrl, broadcastServiceUrl, bitcoinAPI, bitcoinjs_lib_1.networks.testnet);\n  }\n\n  getFeeRate() {\n    return Promise.resolve(Math.floor(0.00001000 * SATOSHIS_PER_BTC));\n  }\n\n}\n\nexports.LocalRegtest = LocalRegtest;\n/**\n * @ignore\n */\n\nclass BitcoindAPI extends BitcoinNetwork {\n  constructor(bitcoindUrl, bitcoindCredentials) {\n    super();\n    this.bitcoindUrl = bitcoindUrl;\n    this.bitcoindCredentials = bitcoindCredentials;\n    this.importedBefore = {};\n  }\n\n  broadcastTransaction(transaction) {\n    const jsonRPC = {\n      jsonrpc: '1.0',\n      method: 'sendrawtransaction',\n      params: [transaction]\n    };\n    const authString = Buffer.from(\"\".concat(this.bitcoindCredentials.username, \":\").concat(this.bitcoindCredentials.password)).toString('base64');\n    const headers = {\n      Authorization: \"Basic \".concat(authString)\n    };\n    return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n      method: 'POST',\n      body: JSON.stringify(jsonRPC),\n      headers\n    }).then(resp => resp.json()).then(respObj => respObj.result);\n  }\n\n  getBlockHeight() {\n    const jsonRPC = {\n      jsonrpc: '1.0',\n      method: 'getblockcount'\n    };\n    const authString = Buffer.from(\"\".concat(this.bitcoindCredentials.username, \":\").concat(this.bitcoindCredentials.password)).toString('base64');\n    const headers = {\n      Authorization: \"Basic \".concat(authString)\n    };\n    return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n      method: 'POST',\n      body: JSON.stringify(jsonRPC),\n      headers\n    }).then(resp => resp.json()).then(respObj => respObj.result);\n  }\n\n  getTransactionInfo(txHash) {\n    const jsonRPC = {\n      jsonrpc: '1.0',\n      method: 'gettransaction',\n      params: [txHash]\n    };\n    const authString = Buffer.from(\"\".concat(this.bitcoindCredentials.username, \":\").concat(this.bitcoindCredentials.password)).toString('base64');\n    const headers = {\n      Authorization: \"Basic \".concat(authString)\n    };\n    return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n      method: 'POST',\n      body: JSON.stringify(jsonRPC),\n      headers\n    }).then(resp => resp.json()).then(respObj => respObj.result).then(txInfo => txInfo.blockhash).then(blockhash => {\n      const jsonRPCBlock = {\n        jsonrpc: '1.0',\n        method: 'getblockheader',\n        params: [blockhash]\n      };\n      headers.Authorization = \"Basic \".concat(authString);\n      return fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n        method: 'POST',\n        body: JSON.stringify(jsonRPCBlock),\n        headers\n      });\n    }).then(resp => resp.json()).then(respObj => {\n      if (!respObj || !respObj.result) {\n        // unconfirmed \n        throw new Error('Unconfirmed transaction');\n      } else {\n        return {\n          block_height: respObj.result.height\n        };\n      }\n    });\n  }\n\n  getNetworkedUTXOs(address) {\n    const jsonRPCImport = {\n      jsonrpc: '1.0',\n      method: 'importaddress',\n      params: [address]\n    };\n    const jsonRPCUnspent = {\n      jsonrpc: '1.0',\n      method: 'listunspent',\n      params: [0, 9999999, [address]]\n    };\n    const authString = Buffer.from(\"\".concat(this.bitcoindCredentials.username, \":\").concat(this.bitcoindCredentials.password)).toString('base64');\n    const headers = {\n      Authorization: \"Basic \".concat(authString)\n    };\n    const importPromise = this.importedBefore[address] ? Promise.resolve() : fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n      method: 'POST',\n      body: JSON.stringify(jsonRPCImport),\n      headers\n    }).then(() => {\n      this.importedBefore[address] = true;\n    });\n    return importPromise.then(() => fetchUtil_1.fetchPrivate(this.bitcoindUrl, {\n      method: 'POST',\n      body: JSON.stringify(jsonRPCUnspent),\n      headers\n    })).then(resp => resp.json()).then(x => x.result).then(utxos => utxos.map(x => ({\n      value: Math.round(x.amount * SATOSHIS_PER_BTC),\n      confirmations: x.confirmations,\n      tx_hash: x.txid,\n      tx_output_n: x.vout\n    })));\n  }\n\n}\n\nexports.BitcoindAPI = BitcoindAPI;\n/**\n * @ignore\n */\n\nclass InsightClient extends BitcoinNetwork {\n  constructor(insightUrl = 'https://utxo.technofractal.com/') {\n    super();\n    this.apiUrl = insightUrl;\n  }\n\n  broadcastTransaction(transaction) {\n    const jsonData = {\n      rawtx: transaction\n    };\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.apiUrl, \"/tx/send\"), {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify(jsonData)\n    }).then(resp => resp.json());\n  }\n\n  getBlockHeight() {\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.apiUrl, \"/status\")).then(resp => resp.json()).then(status => status.blocks);\n  }\n\n  getTransactionInfo(txHash) {\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.apiUrl, \"/tx/\").concat(txHash)).then(resp => resp.json()).then(transactionInfo => {\n      if (transactionInfo.error) {\n        throw new Error(\"Error finding transaction: \".concat(transactionInfo.error));\n      }\n\n      return fetchUtil_1.fetchPrivate(\"\".concat(this.apiUrl, \"/block/\").concat(transactionInfo.blockHash));\n    }).then(resp => resp.json()).then(blockInfo => ({\n      block_height: blockInfo.height\n    }));\n  }\n\n  getNetworkedUTXOs(address) {\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.apiUrl, \"/addr/\").concat(address, \"/utxo\")).then(resp => resp.json()).then(utxos => utxos.map(x => ({\n      value: x.satoshis,\n      confirmations: x.confirmations,\n      tx_hash: x.txid,\n      tx_output_n: x.vout\n    })));\n  }\n\n}\n\nexports.InsightClient = InsightClient;\n/**\n * @ignore\n */\n\nclass BlockchainInfoApi extends BitcoinNetwork {\n  constructor(blockchainInfoUrl = 'https://blockchain.info') {\n    super();\n    this.utxoProviderUrl = blockchainInfoUrl;\n  }\n\n  getBlockHeight() {\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.utxoProviderUrl, \"/latestblock?cors=true\")).then(resp => resp.json()).then(blockObj => blockObj.height);\n  }\n\n  getNetworkedUTXOs(address) {\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.utxoProviderUrl, \"/unspent?format=json&active=\").concat(address, \"&cors=true\")).then(resp => {\n      if (resp.status === 500) {\n        logger_1.Logger.debug('UTXO provider 500 usually means no UTXOs: returning []');\n        return {\n          unspent_outputs: []\n        };\n      } else {\n        return resp.json();\n      }\n    }).then(utxoJSON => utxoJSON.unspent_outputs).then(utxoList => utxoList.map(utxo => {\n      const utxoOut = {\n        value: utxo.value,\n        tx_output_n: utxo.tx_output_n,\n        confirmations: utxo.confirmations,\n        tx_hash: utxo.tx_hash_big_endian\n      };\n      return utxoOut;\n    }));\n  }\n\n  getTransactionInfo(txHash) {\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.utxoProviderUrl, \"/rawtx/\").concat(txHash, \"?cors=true\")).then(resp => {\n      if (resp.status === 200) {\n        return resp.json();\n      } else {\n        throw new Error(\"Could not lookup transaction info for '\".concat(txHash, \"'. Server error.\"));\n      }\n    }).then(respObj => ({\n      block_height: respObj.block_height\n    }));\n  }\n\n  broadcastTransaction(transaction) {\n    const form = new FormData();\n    form.append('tx', transaction);\n    return fetchUtil_1.fetchPrivate(\"\".concat(this.utxoProviderUrl, \"/pushtx?cors=true\"), {\n      method: 'POST',\n      body: form\n    }).then(resp => {\n      const text = resp.text();\n      return text.then(respText => {\n        if (respText.toLowerCase().indexOf('transaction submitted') >= 0) {\n          const txHash = Buffer.from(bitcoinjs_lib_1.Transaction.fromHex(transaction).getHash().reverse()).toString('hex'); // big_endian\n\n          return txHash;\n        } else {\n          throw new errors_1.RemoteServiceError(resp, \"Broadcast transaction failed with message: \".concat(respText));\n        }\n      });\n    });\n  }\n\n}\n\nexports.BlockchainInfoApi = BlockchainInfoApi;\n/**\n* @ignore\n*/\n\nconst LOCAL_REGTEST = new LocalRegtest('http://localhost:16268', 'http://localhost:16269', new BitcoindAPI('http://localhost:18332/', {\n  username: 'blockstack',\n  password: 'blockstacksystem'\n}));\n/**\n* @ignore\n*/\n\nconst MAINNET_DEFAULT = new BlockstackNetwork('https://core.blockstack.org', 'https://broadcast.blockstack.org', new BlockchainInfoApi());\n/**\n * Get WHOIS-like information for a name, including the address that owns it,\n * the block at which it expires, and the zone file anchored to it (if available).\n * @param {String} fullyQualifiedName the name to query.  Can be on-chain of off-chain.\n * @return {Promise} a promise that resolves to the WHOIS-like information\n */\n\nfunction getNameInfo(fullyQualifiedName) {\n  return config_1.config.network.getNameInfo(fullyQualifiedName);\n}\n\nexports.getNameInfo = getNameInfo;\n/**\n* @ignore\n*/\n\nexports.network = {\n  BlockstackNetwork,\n  LocalRegtest,\n  BlockchainInfoApi,\n  BitcoindAPI,\n  InsightClient,\n  defaults: {\n    LOCAL_REGTEST,\n    MAINNET_DEFAULT\n  }\n};","map":null,"metadata":{},"sourceType":"script"}