{"ast":null,"code":"// Generated by IcedCoffeeScript 108.0.8\n(function () {\n  var BlockCipher,\n      BufferedBlockAlgorithm,\n      Hasher,\n      StreamCipher,\n      WordArray,\n      util,\n      __hasProp = {}.hasOwnProperty,\n      __extends = function (child, parent) {\n    for (var key in parent) {\n      if (__hasProp.call(parent, key)) child[key] = parent[key];\n    }\n\n    function ctor() {\n      this.constructor = child;\n    }\n\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n    child.__super__ = parent.prototype;\n    return child;\n  };\n\n  WordArray = require('./wordarray').WordArray;\n  util = require('./util');\n\n  BufferedBlockAlgorithm = function () {\n    BufferedBlockAlgorithm.prototype._minBufferSize = 0;\n\n    function BufferedBlockAlgorithm() {\n      this.reset();\n    }\n\n    BufferedBlockAlgorithm.prototype.reset = function () {\n      this._data = new WordArray();\n      return this._nDataBytes = 0;\n    };\n\n    BufferedBlockAlgorithm.prototype._append = function (data) {\n      this._data.concat(data);\n\n      return this._nDataBytes += data.sigBytes;\n    };\n\n    BufferedBlockAlgorithm.prototype._process = function (doFlush) {\n      var blockSizeBytes, data, dataSigBytes, dataWords, nBlocksReady, nBytesReady, nWordsReady, offset, processedWords, _i, _ref;\n\n      data = this._data;\n      dataWords = data.words;\n      dataSigBytes = data.sigBytes;\n      blockSizeBytes = this.blockSize * 4;\n      nBlocksReady = dataSigBytes / blockSizeBytes;\n\n      if (doFlush) {\n        nBlocksReady = Math.ceil(nBlocksReady);\n      } else {\n        nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n      }\n\n      nWordsReady = nBlocksReady * this.blockSize;\n      nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n      if (nWordsReady) {\n        for (offset = _i = 0, _ref = this.blockSize; _ref > 0 ? _i < nWordsReady : _i > nWordsReady; offset = _i += _ref) {\n          this._doProcessBlock(dataWords, offset);\n        }\n\n        processedWords = dataWords.splice(0, nWordsReady);\n        data.sigBytes -= nBytesReady;\n      }\n\n      return new WordArray(processedWords, nBytesReady);\n    };\n\n    BufferedBlockAlgorithm.prototype.copy_to = function (out) {\n      out._data = this._data.clone();\n      return out._nDataBytes = this._nDataBytes;\n    };\n\n    BufferedBlockAlgorithm.prototype.clone = function () {\n      var obj;\n      obj = new BufferedBlockAlgorithm();\n      this.copy_to(obj);\n      return obj;\n    };\n\n    return BufferedBlockAlgorithm;\n  }();\n\n  Hasher = function (_super) {\n    __extends(Hasher, _super);\n\n    function Hasher() {\n      Hasher.__super__.constructor.call(this);\n    }\n\n    Hasher.prototype.reset = function () {\n      Hasher.__super__.reset.call(this);\n\n      this._doReset();\n\n      return this;\n    };\n\n    Hasher.prototype.update = function (messageUpdate) {\n      this._append(messageUpdate);\n\n      this._process();\n\n      return this;\n    };\n\n    Hasher.prototype.finalize = function (messageUpdate) {\n      if (messageUpdate) {\n        this._append(messageUpdate);\n      }\n\n      return this._doFinalize();\n    };\n\n    Hasher.prototype.bufhash = function (input) {\n      var out, wa_in, wa_out;\n      wa_in = WordArray.from_buffer(input);\n      wa_out = this.finalize(wa_in);\n      out = wa_out.to_buffer();\n      wa_in.scrub();\n      wa_out.scrub();\n      return out;\n    };\n\n    return Hasher;\n  }(BufferedBlockAlgorithm);\n\n  exports.BlockCipher = BlockCipher = function () {\n    function BlockCipher(key) {}\n\n    BlockCipher.prototype.encryptBlock = function (M, offset) {};\n\n    return BlockCipher;\n  }();\n\n  StreamCipher = function () {\n    function StreamCipher() {}\n\n    StreamCipher.prototype.encryptBlock = function (word_array, dst_offset) {\n      var n_words, pad;\n\n      if (dst_offset == null) {\n        dst_offset = 0;\n      }\n\n      pad = this.get_pad();\n      n_words = Math.min(word_array.words.length - dst_offset, this.bsiw);\n      word_array.xor(pad, {\n        dst_offset: dst_offset,\n        n_words: n_words\n      });\n      pad.scrub();\n      return this.bsiw;\n    };\n\n    StreamCipher.prototype.encrypt = function (word_array) {\n      var i, _i, _ref, _ref1;\n\n      for (i = _i = 0, _ref = word_array.words.length, _ref1 = this.bsiw; _ref1 > 0 ? _i < _ref : _i > _ref; i = _i += _ref1) {\n        this.encryptBlock(word_array, i);\n      }\n\n      return word_array;\n    };\n\n    StreamCipher.prototype.bulk_encrypt = function (_arg, cb) {\n      var async_args, input, progress_hook, slice_args, what;\n      input = _arg.input, progress_hook = _arg.progress_hook, what = _arg.what;\n      slice_args = {\n        update: function (_this) {\n          return function (lo, hi) {\n            var i, _i, _ref, _results;\n\n            _results = [];\n\n            for (i = _i = lo, _ref = _this.bsiw; _ref > 0 ? _i < hi : _i > hi; i = _i += _ref) {\n              _results.push(_this.encryptBlock(input, i));\n            }\n\n            return _results;\n          };\n        }(this),\n        finalize: function () {\n          return input;\n        },\n        default_n: this.bsiw * 1024\n      };\n      async_args = {\n        progress_hook: progress_hook,\n        cb: cb,\n        what: what\n      };\n      return util.bulk(input.sigBytes, slice_args, async_args);\n    };\n\n    return StreamCipher;\n  }();\n\n  exports.BlockCipher = BlockCipher;\n  exports.Hasher = Hasher;\n  exports.BufferedBlockAlgorithm = BufferedBlockAlgorithm;\n  exports.StreamCipher = StreamCipher;\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}