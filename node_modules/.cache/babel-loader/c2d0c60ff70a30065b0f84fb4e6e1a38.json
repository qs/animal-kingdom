{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n\nconst RIPEMD160 = require(\"ripemd160\"); // @ts-ignore\n\n\nconst BN = require(\"bn.js\");\n\nconst errors_1 = require(\"../errors\");\n/**\n *\n * @ignore\n */\n\n\nexports.DUST_MINIMUM = 5500;\n/**\n *\n * @ignore\n */\n\nfunction hash160(buff) {\n  const sha256 = bitcoinjs_lib_1.crypto.sha256(buff);\n  return new RIPEMD160().update(sha256).digest();\n}\n\nexports.hash160 = hash160;\n/**\n *\n * @ignore\n */\n\nfunction hash128(buff) {\n  return Buffer.from(bitcoinjs_lib_1.crypto.sha256(buff).slice(0, 16));\n}\n\nexports.hash128 = hash128; // COPIED FROM coinselect, because 1 byte matters sometimes.\n// baseline estimates, used to improve performance\n\nconst TX_EMPTY_SIZE = 4 + 1 + 1 + 4;\nconst TX_INPUT_BASE = 32 + 4 + 1 + 4;\nconst TX_INPUT_PUBKEYHASH = 107;\nconst TX_OUTPUT_BASE = 8 + 1;\nconst TX_OUTPUT_PUBKEYHASH = 25;\n\nfunction inputBytes(input) {\n  if (input && input.script && input.script.length > 0) {\n    return TX_INPUT_BASE + input.script.length;\n  } else {\n    return TX_INPUT_BASE + TX_INPUT_PUBKEYHASH;\n  }\n}\n\nfunction outputBytes(output) {\n  if (output && output.script && output.script.length > 0) {\n    return TX_OUTPUT_BASE + output.script.length;\n  } else {\n    return TX_OUTPUT_BASE + TX_OUTPUT_PUBKEYHASH;\n  }\n}\n\nfunction transactionBytes(inputs, outputs) {\n  return TX_EMPTY_SIZE + inputs.reduce((a, x) => a + inputBytes(x), 0) + outputs.reduce((a, x) => a + outputBytes(x), 0);\n}\n/**\n *\n * @ignore\n */\n\n\nfunction getTransactionInsideBuilder(txBuilder) {\n  return txBuilder.__TX;\n}\n\nexports.getTransactionInsideBuilder = getTransactionInsideBuilder;\n\nfunction getTransaction(txIn) {\n  if (txIn instanceof bitcoinjs_lib_1.Transaction) {\n    return txIn;\n  }\n\n  return getTransactionInsideBuilder(txIn);\n} //\n\n/**\n *\n * @ignore\n */\n\n\nfunction estimateTXBytes(txIn, additionalInputs, additionalOutputs) {\n  const innerTx = getTransaction(txIn);\n  const dummyInputs = new Array(additionalInputs);\n  dummyInputs.fill(null);\n  const dummyOutputs = new Array(additionalOutputs);\n  dummyOutputs.fill(null);\n  const inputs = [].concat(innerTx.ins, dummyInputs);\n  const outputs = [].concat(innerTx.outs, dummyOutputs);\n  return transactionBytes(inputs, outputs);\n}\n\nexports.estimateTXBytes = estimateTXBytes;\n/**\n *\n * @ignore\n */\n\nfunction sumOutputValues(txIn) {\n  const innerTx = getTransaction(txIn);\n  return innerTx.outs.reduce((agg, x) => agg + x.value, 0);\n}\n\nexports.sumOutputValues = sumOutputValues;\n/**\n *\n * @ignore\n */\n\nfunction decodeB40(input) {\n  // treat input as a base40 integer, and output a hex encoding\n  // of that integer.\n  //\n  //   for each digit of the string, find its location in `characters`\n  //    to get the value of the digit, then multiply by 40^(-index in input)\n  // e.g.,\n  // the 'right-most' character has value: (digit-value) * 40^0\n  //  the next character has value: (digit-value) * 40^1\n  //\n  // hence, we reverse the characters first, and use the index\n  //  to compute the value of each digit, then sum\n  const characters = '0123456789abcdefghijklmnopqrstuvwxyz-_.+';\n  const base = new BN(40);\n  const inputDigits = input.split('').reverse();\n  const digitValues = inputDigits.map((character, exponent) => new BN(characters.indexOf(character)).mul(base.pow(new BN(exponent))));\n  const sum = digitValues.reduce((agg, cur) => agg.add(cur), new BN(0));\n  return sum.toString(16, 2);\n}\n\nexports.decodeB40 = decodeB40;\n/**\n * Adds UTXOs to fund a transaction\n * @param {TransactionBuilder} txBuilderIn - a transaction builder object to add the inputs to. this\n *    object is _always_ mutated. If not enough UTXOs exist to fund, the tx builder object\n *    will still contain as many inputs as could be found.\n * @param {Array<{value: number, tx_hash: string, tx_output_n}>} utxos - the utxo set for the\n *    payer's address.\n * @param {number} amountToFund - the amount of satoshis to fund in the transaction. the payer's\n *    utxos will be included to fund up to this amount of *output* and the corresponding *fees*\n *    for those additional inputs\n * @param {number} feeRate - the satoshis/byte fee rate to use for fee calculation\n * @param {boolean} fundNewFees - if true, this function will fund `amountToFund` and any new fees\n *    associated with including the new inputs.\n *    if false, this function will fund _at most_ `amountToFund`\n * @returns {number} - the amount of leftover change (in satoshis)\n * @private\n * @ignore\n */\n\nfunction addUTXOsToFund(txBuilderIn, utxos, amountToFund, feeRate, fundNewFees = true) {\n  if (utxos.length === 0) {\n    throw new errors_1.NotEnoughFundsError(amountToFund);\n  } // how much are we increasing fees by adding an input ?\n\n\n  const newFees = feeRate * (estimateTXBytes(txBuilderIn, 1, 0) - estimateTXBytes(txBuilderIn, 0, 0));\n  let utxoThreshhold = amountToFund;\n\n  if (fundNewFees) {\n    utxoThreshhold += newFees;\n  }\n\n  const goodUtxos = utxos.filter(utxo => utxo.value >= utxoThreshhold);\n\n  if (goodUtxos.length > 0) {\n    goodUtxos.sort((a, b) => a.value - b.value);\n    const selected = goodUtxos[0];\n    let change = selected.value - amountToFund;\n\n    if (fundNewFees) {\n      change -= newFees;\n    }\n\n    txBuilderIn.addInput(selected.tx_hash, selected.tx_output_n);\n    return change;\n  } else {\n    utxos.sort((a, b) => b.value - a.value);\n    const largest = utxos[0];\n\n    if (newFees >= largest.value) {\n      throw new errors_1.NotEnoughFundsError(amountToFund);\n    }\n\n    txBuilderIn.addInput(largest.tx_hash, largest.tx_output_n);\n    let remainToFund = amountToFund - largest.value;\n\n    if (fundNewFees) {\n      remainToFund += newFees;\n    }\n\n    return addUTXOsToFund(txBuilderIn, utxos.slice(1), remainToFund, feeRate, fundNewFees);\n  }\n}\n\nexports.addUTXOsToFund = addUTXOsToFund;\n\nfunction signInputs(txB, defaultSigner, otherSigners) {\n  const txInner = getTransactionInsideBuilder(txB);\n  const signerArray = txInner.ins.map(() => defaultSigner);\n\n  if (otherSigners) {\n    otherSigners.forEach(signerPair => {\n      signerArray[signerPair.index] = signerPair.signer;\n    });\n  }\n\n  let signingPromise = Promise.resolve();\n\n  for (let i = 0; i < txInner.ins.length; i++) {\n    signingPromise = signingPromise.then(() => signerArray[i].signTransaction(txB, i));\n  }\n\n  return signingPromise.then(() => txB);\n}\n\nexports.signInputs = signInputs;","map":null,"metadata":{},"sourceType":"script"}