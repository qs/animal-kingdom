{"ast":null,"code":"// Generated by IcedCoffeeScript 108.0.8\n(function () {\n  var WordArray, X64Word, X64WordArray, buffer_to_ui8a, endian_reverse, ui8a_to_buffer, util;\n  util = require('./util');\n\n  buffer_to_ui8a = function (b) {\n    var i, ret, _i, _ref;\n\n    ret = new Uint8Array(b.length);\n\n    for (i = _i = 0, _ref = b.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n      ret[i] = b.readUInt8(i);\n    }\n\n    return ret;\n  };\n\n  ui8a_to_buffer = function (v) {\n    var i, ret, _i, _ref;\n\n    ret = new Buffer(v.length);\n\n    for (i = _i = 0, _ref = v.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n      ret.writeUInt8(v[i], i);\n    }\n\n    return ret;\n  };\n\n  endian_reverse = function (x) {\n    return x >>> 24 & 0xff | (x >>> 16 & 0xff) << 8 | (x >>> 8 & 0xff) << 16 | (x & 0xff) << 24;\n  };\n\n  exports.WordArray = WordArray = function () {\n    function WordArray(words, sigBytes) {\n      this.words = words || [];\n      this.sigBytes = sigBytes != null ? sigBytes : this.words.length * 4;\n    }\n\n    WordArray.prototype.concat = function (wordArray) {\n      var i, thatByte, thatSigBytes, thatWords, _i;\n\n      thatWords = wordArray.words;\n      thatSigBytes = wordArray.sigBytes;\n      this.clamp();\n\n      if (this.sigBytes % 4) {\n        for (i = _i = 0; 0 <= thatSigBytes ? _i < thatSigBytes : _i > thatSigBytes; i = 0 <= thatSigBytes ? ++_i : --_i) {\n          thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;\n          this.words[this.sigBytes + i >>> 2] |= thatByte << 24 - (this.sigBytes + i) % 4 * 8;\n        }\n      } else {\n        this.words = this.words.concat(thatWords);\n      }\n\n      this.sigBytes += thatSigBytes;\n      return this;\n    };\n\n    WordArray.prototype.clamp = function () {\n      this.words[this.sigBytes >>> 2] &= 0xffffffff << 32 - this.sigBytes % 4 * 8;\n      this.words.length = Math.ceil(this.sigBytes / 4);\n      return this;\n    };\n\n    WordArray.prototype.clone = function () {\n      return new WordArray(this.words.slice(0), this.sigBytes);\n    };\n\n    WordArray.prototype.to_buffer = function () {\n      var ch, out, p, w, _i, _len, _ref;\n\n      out = new Buffer(this.sigBytes);\n      p = 0;\n      _ref = this.words;\n\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        w = _ref[_i];\n\n        if (!(this.sigBytes - p >= 4)) {\n          continue;\n        }\n\n        w = util.fixup_uint32(w);\n        out.writeUInt32BE(w, p);\n        p += 4;\n      }\n\n      while (p < this.sigBytes) {\n        ch = this.words[p >>> 2] >>> 24 - p % 4 * 8 & 0xff;\n        out.writeUInt8(ch, p);\n        p++;\n      }\n\n      return out;\n    };\n\n    WordArray.prototype.endian_reverse = function () {\n      var i, w, _i, _len, _ref;\n\n      _ref = this.words;\n\n      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n        w = _ref[i];\n        this.words[i] = endian_reverse(w);\n      }\n\n      return this;\n    };\n\n    WordArray.prototype.split = function (n) {\n      var i, out, sz;\n\n      if (!(this.sigBytes % 4 === 0 && this.words.length % n === 0)) {\n        throw new Error(\"bad key alignment\");\n      }\n\n      sz = this.words.length / n;\n\n      out = function () {\n        var _i, _ref, _results;\n\n        _results = [];\n\n        for (i = _i = 0, _ref = this.words.length; sz > 0 ? _i < _ref : _i > _ref; i = _i += sz) {\n          _results.push(new WordArray(this.words.slice(i, i + sz)));\n        }\n\n        return _results;\n      }.call(this);\n\n      return out;\n    };\n\n    WordArray.prototype.to_utf8 = function () {\n      return this.to_buffer().toString('utf8');\n    };\n\n    WordArray.prototype.to_hex = function () {\n      return this.to_buffer().toString('hex');\n    };\n\n    WordArray.prototype.to_ui8a = function () {\n      return buffer_to_ui8a(this.to_buffer());\n    };\n\n    WordArray.alloc = function (b) {\n      if (Buffer.isBuffer(b)) {\n        return WordArray.from_buffer(b);\n      } else if (typeof b === 'object' && b instanceof WordArray) {\n        return b;\n      } else if (typeof b === 'string') {\n        return WordArray.from_hex(b);\n      } else {\n        return null;\n      }\n    };\n\n    WordArray.from_buffer = function (b) {\n      var ch, last, p, words;\n      words = [];\n      p = 0;\n\n      while (b.length - p >= 4) {\n        words.push(b.readUInt32BE(p));\n        p += 4;\n      }\n\n      if (p < b.length) {\n        last = 0;\n\n        while (p < b.length) {\n          ch = b.readUInt8(p);\n          last |= ch << 24 - p % 4 * 8;\n          p++;\n        }\n\n        last = util.fixup_uint32(last);\n        words.push(last);\n      }\n\n      return new WordArray(words, b.length);\n    };\n\n    WordArray.from_buffer_le = function (b) {\n      var ch, last, p, words;\n      words = [];\n      p = 0;\n\n      while (b.length - p >= 4) {\n        words.push(b.readUInt32LE(p));\n        p += 4;\n      }\n\n      if (p < b.length) {\n        last = 0;\n\n        while (p < b.length) {\n          ch = b.readUInt8(p);\n          last |= ch << p % 4 * 8;\n          p++;\n        }\n\n        last = util.fixup_uint32(last);\n        words.push(last);\n      }\n\n      return new WordArray(words, b.length);\n    };\n\n    WordArray.from_utf8 = function (s) {\n      return WordArray.from_buffer(new Buffer(s, 'utf8'));\n    };\n\n    WordArray.from_utf8_le = function (s) {\n      return WordArray.from_buffer_le(new Buffer(s, 'utf8'));\n    };\n\n    WordArray.from_hex = function (s) {\n      return WordArray.from_buffer(new Buffer(s, 'hex'));\n    };\n\n    WordArray.from_hex_le = function (s) {\n      return WordArray.from_buffer_le(new Buffer(s, 'hex'));\n    };\n\n    WordArray.from_ui8a = function (v) {\n      return WordArray.from_buffer(ui8a_to_buffer(v));\n    };\n\n    WordArray.from_i32a = function (v) {\n      return new WordArray(Array.apply([], v));\n    };\n\n    WordArray.prototype.equal = function (wa) {\n      var i, ret, w, _i, _len, _ref;\n\n      ret = true;\n\n      if (wa.sigBytes !== this.sigBytes) {\n        ret = false;\n      } else {\n        _ref = this.words;\n\n        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {\n          w = _ref[i];\n\n          if (util.fixup_uint32(w) !== util.fixup_uint32(wa.words[i])) {\n            ret = false;\n          }\n        }\n      }\n\n      return ret;\n    };\n\n    WordArray.prototype.xor = function (wa2, _arg) {\n      var dst_offset, i, n_words, src_offset, tmp, _i;\n\n      dst_offset = _arg.dst_offset, src_offset = _arg.src_offset, n_words = _arg.n_words;\n\n      if (!dst_offset) {\n        dst_offset = 0;\n      }\n\n      if (!src_offset) {\n        src_offset = 0;\n      }\n\n      if (n_words == null) {\n        n_words = wa2.words.length - src_offset;\n      }\n\n      if (this.words.length < dst_offset + n_words) {\n        throw new Error(\"dest range exceeded (\" + this.words.length + \" < \" + (dst_offset + n_words) + \")\");\n      }\n\n      if (wa2.words.length < src_offset + n_words) {\n        throw new Error(\"source range exceeded\");\n      }\n\n      for (i = _i = 0; 0 <= n_words ? _i < n_words : _i > n_words; i = 0 <= n_words ? ++_i : --_i) {\n        tmp = this.words[dst_offset + i] ^ wa2.words[src_offset + i];\n        this.words[dst_offset + i] = util.fixup_uint32(tmp);\n      }\n\n      return this;\n    };\n\n    WordArray.prototype.truncate = function (n_bytes) {\n      var n_words;\n\n      if (!(n_bytes <= this.sigBytes)) {\n        throw new Error(\"Cannot truncate: \" + n_bytes + \" > \" + this.sigBytes);\n      }\n\n      n_words = Math.ceil(n_bytes / 4);\n      return new WordArray(this.words.slice(0, n_words), n_bytes);\n    };\n\n    WordArray.prototype.unshift = function (n_words) {\n      var ret;\n\n      if (this.words.length >= n_words) {\n        ret = this.words.splice(0, n_words);\n        this.sigBytes -= n_words * 4;\n        return new WordArray(ret);\n      } else {\n        return null;\n      }\n    };\n\n    WordArray.prototype.is_scrubbed = function () {\n      var w, _i, _len, _ref;\n\n      _ref = this.words;\n\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        w = _ref[_i];\n\n        if (w !== 0) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    WordArray.prototype.scrub = function () {\n      return util.scrub_vec(this.words);\n    };\n\n    WordArray.prototype.cmp_ule = function (wa2) {\n      return util.buffer_cmp_ule(this.to_buffer(), wa2.to_buffer());\n    };\n\n    WordArray.prototype.slice = function (low, hi) {\n      var n, sb;\n      n = this.words.length;\n\n      if (!(low < hi && hi <= n)) {\n        throw new Error(\"Bad WordArray slice [\" + low + \",\" + hi + \")] when only \" + n + \" avail\");\n      }\n\n      sb = (hi - low) * 4;\n\n      if (hi === n) {\n        sb -= n * 4 - this.sigBytes;\n      }\n\n      return new WordArray(this.words.slice(low, hi), sb);\n    };\n\n    return WordArray;\n  }();\n\n  exports.X64Word = X64Word = function () {\n    function X64Word(high, low) {\n      this.high = high;\n      this.low = low;\n    }\n\n    X64Word.prototype.clone = function () {\n      return new X64Word(this.high, this.low);\n    };\n\n    return X64Word;\n  }();\n\n  exports.X64WordArray = X64WordArray = function () {\n    function X64WordArray(words, sigBytes) {\n      this.sigBytes = sigBytes;\n      this.words = words || [];\n\n      if (!this.sigBytes) {\n        this.sigBytes = this.words.length * 8;\n      }\n    }\n\n    X64WordArray.prototype.toX32 = function () {\n      var v, w, _i, _len, _ref;\n\n      v = [];\n      _ref = this.words;\n\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        w = _ref[_i];\n        v.push(w.high);\n        v.push(w.low);\n      }\n\n      return new WordArray(v, this.sigBytes);\n    };\n\n    X64WordArray.prototype.clone = function () {\n      var w;\n      return new X64WordArray(function () {\n        var _i, _len, _ref, _results;\n\n        _ref = this.words;\n        _results = [];\n\n        for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n          w = _ref[_i];\n\n          _results.push(w.clone());\n        }\n\n        return _results;\n      }.call(this), this.sigBytes);\n    };\n\n    return X64WordArray;\n  }();\n\n  exports.buffer_to_ui8a = buffer_to_ui8a;\n  exports.ui8a_to_buffer = ui8a_to_buffer;\n  exports.endian_reverse = endian_reverse;\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}