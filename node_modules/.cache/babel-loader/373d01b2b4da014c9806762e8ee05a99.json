{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst cheerio = require(\"cheerio\");\n\nconst service_1 = require(\"./service\");\n\nclass LinkedIn extends service_1.Service {\n  static getBaseUrls() {\n    const baseUrls = ['https://www.linkedin.com/feed/update/', 'http://www.linkedin.com/feed/update/', 'www.linkedin.com/feed/update/'];\n    return baseUrls;\n  }\n\n  static getProofUrl(proof) {\n    const baseUrls = this.getBaseUrls();\n    let proofUrl = proof.proof_url.toLowerCase();\n    proofUrl = super.prefixScheme(proofUrl);\n\n    for (let i = 0; i < baseUrls.length; i++) {\n      if (proofUrl.startsWith(\"\".concat(baseUrls[i]))) {\n        return proofUrl;\n      }\n    }\n\n    throw new Error(\"Proof url \".concat(proof.proof_url, \" is not valid for service \").concat(proof.service));\n  }\n\n  static normalizeUrl(proof) {\n    return '';\n  }\n\n  static shouldValidateIdentityInBody() {\n    return true;\n  }\n\n  static getProofIdentity(searchText) {\n    const $ = cheerio.load(searchText);\n    const profileLink = $('body > main header a');\n\n    if (profileLink !== undefined) {\n      if (profileLink.attr('href') === undefined) {\n        return '';\n      }\n\n      const url = profileLink.attr('href'); // Parse URL for identifier\n\n      const identifier = url.split('?').shift().split('/').pop();\n      return identifier;\n    } else {\n      return '';\n    }\n  }\n\n  static getProofStatement(searchText) {\n    const $ = cheerio.load(searchText);\n    const postContent = $('head > meta[property=\"og:title\"]');\n    let statement = '';\n\n    if (postContent !== undefined) {\n      statement = postContent.attr('content');\n    }\n\n    return statement;\n  }\n\n}\n\nexports.LinkedIn = LinkedIn;","map":null,"metadata":{},"sourceType":"script"}