{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst networks = require('./networks');\n\nconst payments = require('./payments');\n\nconst bscript = require('./script');\n\nconst types = require('./types');\n\nconst bech32 = require('bech32');\n\nconst bs58check = require('bs58check');\n\nconst typeforce = require('typeforce');\n\nfunction fromBase58Check(address) {\n  const payload = bs58check.decode(address); // TODO: 4.0.0, move to \"toOutputScript\"\n\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 21) throw new TypeError(address + ' is too long');\n  const version = payload.readUInt8(0);\n  const hash = payload.slice(1);\n  return {\n    version,\n    hash\n  };\n}\n\nexports.fromBase58Check = fromBase58Check;\n\nfunction fromBech32(address) {\n  const result = bech32.decode(address);\n  const data = bech32.fromWords(result.words.slice(1));\n  return {\n    version: result.words[0],\n    prefix: result.prefix,\n    data: Buffer.from(data)\n  };\n}\n\nexports.fromBech32 = fromBech32;\n\nfunction toBase58Check(hash, version) {\n  typeforce(types.tuple(types.Hash160bit, types.UInt8), arguments);\n  const payload = Buffer.allocUnsafe(21);\n  payload.writeUInt8(version, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\n\nexports.toBase58Check = toBase58Check;\n\nfunction toBech32(data, version, prefix) {\n  const words = bech32.toWords(data);\n  words.unshift(version);\n  return bech32.encode(prefix, words);\n}\n\nexports.toBech32 = toBech32;\n\nfunction fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n\n  try {\n    return payments.p2pkh({\n      output,\n      network\n    }).address;\n  } catch (e) {}\n\n  try {\n    return payments.p2sh({\n      output,\n      network\n    }).address;\n  } catch (e) {}\n\n  try {\n    return payments.p2wpkh({\n      output,\n      network\n    }).address;\n  } catch (e) {}\n\n  try {\n    return payments.p2wsh({\n      output,\n      network\n    }).address;\n  } catch (e) {}\n\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\n\nexports.fromOutputScript = fromOutputScript;\n\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash) return payments.p2pkh({\n      hash: decodeBase58.hash\n    }).output;\n    if (decodeBase58.version === network.scriptHash) return payments.p2sh({\n      hash: decodeBase58.hash\n    }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32) throw new Error(address + ' has an invalid prefix');\n\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20) return payments.p2wpkh({\n          hash: decodeBech32.data\n        }).output;\n        if (decodeBech32.data.length === 32) return payments.p2wsh({\n          hash: decodeBech32.data\n        }).output;\n      }\n    }\n  }\n\n  throw new Error(address + ' has no matching Script');\n}\n\nexports.toOutputScript = toOutputScript;","map":null,"metadata":{},"sourceType":"script"}