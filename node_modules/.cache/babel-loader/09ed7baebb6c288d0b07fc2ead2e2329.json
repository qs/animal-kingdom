{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // @ts-ignore: Could not find a declaration file for module\n\nconst jsontokens_1 = require(\"jsontokens\");\n\nrequire(\"cross-fetch/polyfill\");\n\nconst fetchUtil_1 = require(\"../fetchUtil\");\n/**\n * Create an authentication token to be sent to the Core API server\n * in order to generate a Core session JWT.\n *\n * @param {String} appDomain  The unique application identifier (e.g. foo.app, www.foo.com, etc).\n * @param {Array} appMethods  The list of API methods this application will need.\n * @param {String} appPrivateKey  The application-specific private key\n * @param {String|null} blockchainID  This is the blockchain ID of the requester\n * @param {String} thisDevice Identifier of the current device\n *\n * @return {String} a JWT signed by the app's private key\n * @deprecated\n * @private\n * @ignore\n */\n\n\nfunction makeCoreSessionRequest(appDomain, appMethods, appPrivateKey, blockchainID = null, thisDevice = null) {\n  if (thisDevice === null) {\n    thisDevice = '.default';\n  }\n\n  const appPublicKey = jsontokens_1.SECP256K1Client.derivePublicKey(appPrivateKey);\n  const appPublicKeys = [{\n    public_key: appPublicKey,\n    device_id: thisDevice\n  }];\n  const authBody = {\n    version: 1,\n    blockchain_id: blockchainID,\n    app_private_key: appPrivateKey,\n    app_domain: appDomain,\n    methods: appMethods,\n    app_public_keys: appPublicKeys,\n    device_id: thisDevice\n  }; // make token\n\n  const tokenSigner = new jsontokens_1.TokenSigner('ES256k', appPrivateKey);\n  const token = tokenSigner.sign(authBody);\n  return token;\n}\n\nexports.makeCoreSessionRequest = makeCoreSessionRequest;\n/**\n * Send Core a request for a session token.\n *\n * @param {String} coreHost host name of the core node\n * @param {Number} corePort port number of the core node\n * @param {String} coreAuthRequest  a signed JWT encoding the authentication request\n * @param {String} apiPassword the API password for Core\n *\n * @return {Promise} the resolves to a JWT signed with the Core API server's private key\n * that authorizes the bearer to carry out the requested operations and rejects\n * with an error message otherwise\n * @deprecated\n * @private\n * @ignore\n */\n\nfunction sendCoreSessionRequest(coreHost, corePort, coreAuthRequest, apiPassword) {\n  return Promise.resolve().then(() => {\n    if (!apiPassword) {\n      throw new Error('Missing API password');\n    }\n  }).then(() => {\n    const options = {\n      headers: {\n        Authorization: \"bearer \".concat(apiPassword)\n      }\n    };\n    const url = \"http://\".concat(coreHost, \":\").concat(corePort, \"/v1/auth?authRequest=\").concat(coreAuthRequest);\n    return fetchUtil_1.fetchPrivate(url, options);\n  }).then(response => {\n    if (!response.ok) {\n      throw new Error('HTTP status not OK');\n    }\n\n    return response.text();\n  }).then(responseText => {\n    const responseJson = JSON.parse(responseText);\n    const token = responseJson.token;\n\n    if (!token) {\n      throw new Error('Failed to get Core session token');\n    }\n\n    return token;\n  }).catch(error => {\n    console.error(error);\n    throw new Error('Invalid Core response: not JSON');\n  });\n}\n\nexports.sendCoreSessionRequest = sendCoreSessionRequest;\n/**\n * Get a core session token.  Generate an auth request, sign it, send it to Core,\n * and get back a session token.\n *\n * @param {String} coreHost Core API server's hostname\n * @param {Number} corePort Core API server's port number\n * @param {String} apiPassword core api password\n * @param  {String} appPrivateKey Application's private key\n * @param  {String} blockchainId blockchain ID of the user signing in.\n * `null` if user has no blockchain ID\n * @param {String} authRequest authentication request token\n * @param {String} deviceId identifier for the current device\n *\n * @return {Promise} a Promise that resolves to a Core session token or rejects\n * with an error message.\n * @deprecated\n * @private\n * @ignore\n */\n\nfunction getCoreSession(coreHost, corePort, apiPassword, appPrivateKey, blockchainId = null, authRequest = null, deviceId = '0') {\n  if (!authRequest) {\n    return Promise.reject('No authRequest provided');\n  }\n\n  try {\n    const authRequestObject = jsontokens_1.decodeToken(authRequest);\n\n    if (!authRequestObject) {\n      return Promise.reject('Invalid authRequest in URL query string');\n    }\n\n    if (!authRequestObject.payload) {\n      return Promise.reject('Invalid authRequest in URL query string');\n    }\n\n    const payload = authRequestObject.payload;\n\n    if (typeof payload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    const appDomain = payload.domain_name;\n\n    if (!appDomain) {\n      return Promise.reject('No domain_name in authRequest');\n    }\n\n    const appMethods = payload.scopes;\n    const coreAuthRequest = makeCoreSessionRequest(appDomain, appMethods, appPrivateKey, blockchainId, deviceId);\n    return sendCoreSessionRequest(coreHost, corePort, coreAuthRequest, apiPassword);\n  } catch (e) {\n    console.error(e.stack);\n    return Promise.reject('Failed to parse authRequest in URL');\n  }\n}\n\nexports.getCoreSession = getCoreSession;","map":null,"metadata":{},"sourceType":"script"}