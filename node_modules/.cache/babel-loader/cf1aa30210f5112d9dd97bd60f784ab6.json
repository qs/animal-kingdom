{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst combiner_1 = require('./combiner');\n\nconst parser_1 = require('./parser');\n\nconst typeFields_1 = require('./typeFields');\n\nconst utils_1 = require('./utils');\n\nclass Psbt {\n  constructor(tx) {\n    this.inputs = [];\n    this.outputs = [];\n    this.globalMap = {\n      unsignedTx: tx\n    };\n  }\n\n  static fromBase64(data, txFromBuffer) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, txFromBuffer);\n  }\n\n  static fromHex(data, txFromBuffer) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, txFromBuffer);\n  }\n\n  static fromBuffer(buffer, txFromBuffer) {\n    const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);\n    const psbt = new this(results.globalMap.unsignedTx);\n    Object.assign(psbt, results);\n    return psbt;\n  }\n\n  toBase64() {\n    const buffer = this.toBuffer();\n    return buffer.toString('base64');\n  }\n\n  toHex() {\n    const buffer = this.toBuffer();\n    return buffer.toString('hex');\n  }\n\n  toBuffer() {\n    return parser_1.psbtToBuffer(this);\n  }\n\n  updateGlobal(updateData) {\n    utils_1.updateGlobal(updateData, this.globalMap);\n    return this;\n  }\n\n  updateInput(inputIndex, updateData) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.updateInput(updateData, input);\n    return this;\n  }\n\n  updateOutput(outputIndex, updateData) {\n    const output = utils_1.checkForOutput(this.outputs, outputIndex);\n    utils_1.updateOutput(updateData, output);\n    return this;\n  }\n\n  addUnknownKeyValToGlobal(keyVal) {\n    utils_1.checkHasKey(keyVal, this.globalMap.unknownKeyVals, utils_1.getEnumLength(typeFields_1.GlobalTypes));\n    if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];\n    this.globalMap.unknownKeyVals.push(keyVal);\n    return this;\n  }\n\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.checkHasKey(keyVal, input.unknownKeyVals, utils_1.getEnumLength(typeFields_1.InputTypes));\n    if (!input.unknownKeyVals) input.unknownKeyVals = [];\n    input.unknownKeyVals.push(keyVal);\n    return this;\n  }\n\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    const output = utils_1.checkForOutput(this.outputs, outputIndex);\n    utils_1.checkHasKey(keyVal, output.unknownKeyVals, utils_1.getEnumLength(typeFields_1.OutputTypes));\n    if (!output.unknownKeyVals) output.unknownKeyVals = [];\n    output.unknownKeyVals.push(keyVal);\n    return this;\n  }\n\n  addInput(inputData) {\n    this.globalMap.unsignedTx.addInput(inputData);\n    this.inputs.push({\n      unknownKeyVals: []\n    });\n    const addKeyVals = inputData.unknownKeyVals || [];\n    const inputIndex = this.inputs.length - 1;\n\n    if (!Array.isArray(addKeyVals)) {\n      throw new Error('unknownKeyVals must be an Array');\n    }\n\n    addKeyVals.forEach(keyVal => this.addUnknownKeyValToInput(inputIndex, keyVal));\n    utils_1.addInputAttributes(this.inputs, inputData);\n    return this;\n  }\n\n  addOutput(outputData) {\n    this.globalMap.unsignedTx.addOutput(outputData);\n    this.outputs.push({\n      unknownKeyVals: []\n    });\n    const addKeyVals = outputData.unknownKeyVals || [];\n    const outputIndex = this.outputs.length - 1;\n\n    if (!Array.isArray(addKeyVals)) {\n      throw new Error('unknownKeyVals must be an Array');\n    }\n\n    addKeyVals.forEach(keyVal => this.addUnknownKeyValToInput(outputIndex, keyVal));\n    utils_1.addOutputAttributes(this.outputs, outputData);\n    return this;\n  }\n\n  clearFinalizedInput(inputIndex) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.inputCheckUncleanFinalized(inputIndex, input);\n\n    for (const key of Object.keys(input)) {\n      if (!['witnessUtxo', 'nonWitnessUtxo', 'finalScriptSig', 'finalScriptWitness', 'unknownKeyVals'].includes(key)) {\n        // @ts-ignore\n        delete input[key];\n      }\n    }\n\n    return this;\n  }\n\n  combine(...those) {\n    // Combine this with those.\n    // Return self for chaining.\n    const result = combiner_1.combine([this].concat(those));\n    Object.assign(this, result);\n    return this;\n  }\n\n  getTransaction() {\n    return this.globalMap.unsignedTx.toBuffer();\n  }\n\n}\n\nexports.Psbt = Psbt;","map":null,"metadata":{},"sourceType":"script"}