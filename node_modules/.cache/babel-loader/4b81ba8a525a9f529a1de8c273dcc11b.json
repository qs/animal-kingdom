{"ast":null,"code":"// Generated by IcedCoffeeScript 108.0.8\n(function () {\n  var HMAC_SHA256, Salsa20InnerCore, Scrypt, Timer, WordArray, blkcpy, blkxor, default_delay, endian_reverse, fixup_uint32, iced, pbkdf2, scrub_vec, scrypt, timer, ui8a_to_buffer, v_endian_reverse, __iced_k, __iced_k_noop, _ref, _ref1, _ref2;\n\n  iced = require('iced-runtime');\n\n  __iced_k = __iced_k_noop = function () {};\n\n  HMAC_SHA256 = require('./hmac').HMAC_SHA256;\n  pbkdf2 = require('./pbkdf2').pbkdf2;\n  _ref = require('./salsa20'), endian_reverse = _ref.endian_reverse, Salsa20InnerCore = _ref.Salsa20InnerCore;\n  _ref1 = require('./wordarray'), ui8a_to_buffer = _ref1.ui8a_to_buffer, WordArray = _ref1.WordArray;\n  _ref2 = require('./util'), fixup_uint32 = _ref2.fixup_uint32, default_delay = _ref2.default_delay, scrub_vec = _ref2.scrub_vec;\n\n  Timer = function () {\n    function Timer() {\n      this.tot = 0;\n    }\n\n    Timer.prototype.start = function () {\n      return this._t = Date.now();\n    };\n\n    Timer.prototype.stop = function () {\n      return this.tot += Date.now() - this._t;\n    };\n\n    return Timer;\n  }();\n\n  timer = new Timer();\n\n  blkcpy = function (D, S, d_offset, s_offset, len) {\n    var end, i, j;\n    j = d_offset << 4 | 0;\n    i = s_offset << 4 | 0;\n    end = i + (len << 4) | 0;\n\n    while (i < end) {\n      D[j] = S[i];\n      D[j + 1] = S[i + 1];\n      D[j + 2] = S[i + 2];\n      D[j + 3] = S[i + 3];\n      D[j + 4] = S[i + 4];\n      D[j + 5] = S[i + 5];\n      D[j + 6] = S[i + 6];\n      D[j + 7] = S[i + 7];\n      D[j + 8] = S[i + 8];\n      D[j + 9] = S[i + 9];\n      D[j + 10] = S[i + 10];\n      D[j + 11] = S[i + 11];\n      D[j + 12] = S[i + 12];\n      D[j + 13] = S[i + 13];\n      D[j + 14] = S[i + 14];\n      D[j + 15] = S[i + 15];\n      i += 16;\n      j += 16;\n    }\n\n    return true;\n  };\n\n  blkxor = function (D, S, s_offset, len) {\n    var i, j;\n    len = len << 4 | 0;\n    i = 0;\n    j = s_offset << 4 | 0;\n\n    while (i < len) {\n      D[i] ^= S[j];\n      D[i + 1] ^= S[j + 1];\n      D[i + 2] ^= S[j + 2];\n      D[i + 3] ^= S[j + 3];\n      D[i + 4] ^= S[j + 4];\n      D[i + 5] ^= S[j + 5];\n      D[i + 6] ^= S[j + 6];\n      D[i + 7] ^= S[j + 7];\n      D[i + 8] ^= S[j + 8];\n      D[i + 9] ^= S[j + 9];\n      D[i + 10] ^= S[j + 10];\n      D[i + 11] ^= S[j + 11];\n      D[i + 12] ^= S[j + 12];\n      D[i + 13] ^= S[j + 13];\n      D[i + 14] ^= S[j + 14];\n      D[i + 15] ^= S[j + 15];\n      i += 16;\n      j += 16;\n    }\n\n    return true;\n  };\n\n  v_endian_reverse = function (v) {\n    var e, i, _i, _len;\n\n    for (i = _i = 0, _len = v.length; _i < _len; i = ++_i) {\n      e = v[i];\n      v[i] = endian_reverse(e);\n    }\n\n    return true;\n  };\n\n  Scrypt = function () {\n    function Scrypt(_arg) {\n      var N, c, c0, c1;\n      N = _arg.N, this.r = _arg.r, this.p = _arg.p, c = _arg.c, c0 = _arg.c0, c1 = _arg.c1, this.klass = _arg.klass;\n      this.N || (this.N = 1 << (N || 15));\n      this.r || (this.r = 8);\n      this.p || (this.p = 1);\n      this.c0 = c0 || c || 1;\n      this.c1 = c1 || c || 1;\n      this.klass || (this.klass = HMAC_SHA256);\n      this.X16_tmp = new Int32Array(0x10);\n      this.s20ic = new Salsa20InnerCore(8);\n    }\n\n    Scrypt.prototype.salsa20_8 = function (B) {\n      var X, i, x, _i, _len;\n\n      X = this.s20ic._core(B);\n\n      for (i = _i = 0, _len = X.length; _i < _len; i = ++_i) {\n        x = X[i];\n        B[i] += x;\n      }\n\n      return true;\n    };\n\n    Scrypt.prototype.pbkdf2 = function (_arg, cb) {\n      var c, dkLen, key, progress_hook, salt, wa, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      key = _arg.key, salt = _arg.salt, dkLen = _arg.dkLen, progress_hook = _arg.progress_hook, c = _arg.c;\n      (function (_this) {\n        return function (__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/triplesec/src/scrypt.iced\",\n            funcname: \"Scrypt.pbkdf2\"\n          });\n          pbkdf2({\n            key: key,\n            salt: salt,\n            c: c,\n            dkLen: dkLen,\n            klass: _this.klass,\n            progress_hook: progress_hook\n          }, __iced_deferrals.defer({\n            assign_fn: function () {\n              return function () {\n                return wa = arguments[0];\n              };\n            }(),\n            lineno: 109\n          }));\n\n          __iced_deferrals._fulfill();\n        };\n      })(this)(function (_this) {\n        return function () {\n          return cb(wa);\n        };\n      }(this));\n    };\n\n    Scrypt.prototype.blockmix_salsa8 = function (B, Y) {\n      var X, i, _i, _ref3;\n\n      X = this.X16_tmp;\n      blkcpy(X, B, 0, 2 * this.r - 1, 1);\n\n      for (i = _i = 0, _ref3 = 2 * this.r; 0 <= _ref3 ? _i < _ref3 : _i > _ref3; i = 0 <= _ref3 ? ++_i : --_i) {\n        blkxor(X, B, i, 1);\n        this.salsa20_8(X);\n        blkcpy(Y, X, i, 0, 1);\n      }\n\n      i = 0;\n\n      while (i < this.r) {\n        blkcpy(B, Y, i, i * 2, 1);\n        i++;\n      }\n\n      i = 0;\n\n      while (i < this.r) {\n        blkcpy(B, Y, i + this.r, i * 2 + 1, 1);\n        i++;\n      }\n\n      return true;\n    };\n\n    Scrypt.prototype.smix = function (_arg, cb) {\n      var B, V, X, XY, Y, i, j, lim, progress_hook, stop, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      B = _arg.B, V = _arg.V, XY = _arg.XY, progress_hook = _arg.progress_hook;\n      X = XY;\n      lim = 2 * this.r;\n      Y = XY.subarray(0x10 * lim);\n      blkcpy(X, B, 0, 0, lim);\n      i = 0;\n      (function (_this) {\n        return function (__iced_k) {\n          var _while;\n\n          _while = function (__iced_k) {\n            var _break, _continue, _next;\n\n            _break = __iced_k;\n\n            _continue = function () {\n              return iced.trampoline(function () {\n                return _while(__iced_k);\n              });\n            };\n\n            _next = _continue;\n\n            if (!(i < _this.N)) {\n              return _break();\n            } else {\n              stop = Math.min(_this.N, i + 2048);\n\n              while (i < stop) {\n                blkcpy(V, X, lim * i, 0, lim);\n\n                _this.blockmix_salsa8(X, Y);\n\n                i++;\n              }\n\n              if (typeof progress_hook === \"function\") {\n                progress_hook(i);\n              }\n\n              (function (__iced_k) {\n                __iced_deferrals = new iced.Deferrals(__iced_k, {\n                  parent: ___iced_passed_deferral,\n                  filename: \"/Users/max/src/keybase/triplesec/src/scrypt.iced\",\n                  funcname: \"Scrypt.smix\"\n                });\n                default_delay(0, 0, __iced_deferrals.defer({\n                  lineno: 166\n                }));\n\n                __iced_deferrals._fulfill();\n              })(_next);\n            }\n          };\n\n          _while(__iced_k);\n        };\n      })(this)(function (_this) {\n        return function () {\n          i = 0;\n\n          (function (__iced_k) {\n            var _while;\n\n            _while = function (__iced_k) {\n              var _break, _continue, _next;\n\n              _break = __iced_k;\n\n              _continue = function () {\n                return iced.trampoline(function () {\n                  return _while(__iced_k);\n                });\n              };\n\n              _next = _continue;\n\n              if (!(i < _this.N)) {\n                return _break();\n              } else {\n                stop = Math.min(_this.N, i + 256);\n\n                while (i < stop) {\n                  j = fixup_uint32(X[0x10 * (lim - 1)]) & _this.N - 1;\n                  blkxor(X, V, j * lim, lim);\n\n                  _this.blockmix_salsa8(X, Y);\n\n                  i++;\n                }\n\n                if (typeof progress_hook === \"function\") {\n                  progress_hook(i + _this.N);\n                }\n\n                (function (__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/triplesec/src/scrypt.iced\",\n                    funcname: \"Scrypt.smix\"\n                  });\n                  default_delay(0, 0, __iced_deferrals.defer({\n                    lineno: 183\n                  }));\n\n                  __iced_deferrals._fulfill();\n                })(_next);\n              }\n            };\n\n            _while(__iced_k);\n          })(function () {\n            blkcpy(B, X, 0, 0, lim);\n            return cb();\n          });\n        };\n      }(this));\n    };\n\n    Scrypt.prototype.run = function (_arg, cb) {\n      var B, MAX, V, XY, dkLen, err, j, key, lph, out, progress_hook, ret, salt, ___iced_passed_deferral, __iced_deferrals, __iced_k, _begin, _end, _positive;\n\n      __iced_k = __iced_k_noop;\n      ___iced_passed_deferral = iced.findDeferral(arguments);\n      key = _arg.key, salt = _arg.salt, dkLen = _arg.dkLen, progress_hook = _arg.progress_hook;\n      MAX = 0xffffffff;\n      err = ret = null;\n      err = dkLen > MAX ? err = new Error(\"asked for too much data\") : this.r * this.p >= 1 << 30 ? new Error(\"r & p are too big\") : this.r > MAX / 128 / this.p || this.r > MAX / 256 || this.N > MAX / 128 / this.r ? new Error(\"N is too big\") : null;\n      XY = new Int32Array(64 * this.r);\n      V = new Int32Array(32 * this.r * this.N);\n\n      lph = function (o) {\n        o.what += \" (pass 1)\";\n        return typeof progress_hook === \"function\" ? progress_hook(o) : void 0;\n      };\n\n      (function (_this) {\n        return function (__iced_k) {\n          __iced_deferrals = new iced.Deferrals(__iced_k, {\n            parent: ___iced_passed_deferral,\n            filename: \"/Users/max/src/keybase/triplesec/src/scrypt.iced\",\n            funcname: \"Scrypt.run\"\n          });\n\n          _this.pbkdf2({\n            key: key.clone(),\n            salt: salt,\n            dkLen: 128 * _this.r * _this.p,\n            c: _this.c0,\n            progress_hook: lph\n          }, __iced_deferrals.defer({\n            assign_fn: function () {\n              return function () {\n                return B = arguments[0];\n              };\n            }(),\n            lineno: 214\n          }));\n\n          __iced_deferrals._fulfill();\n        };\n      })(this)(function (_this) {\n        return function () {\n          B = new Int32Array(B.words);\n          v_endian_reverse(B);\n\n          lph = function (j) {\n            return function (i) {\n              return typeof progress_hook === \"function\" ? progress_hook({\n                i: i + j * _this.N * 2,\n                what: \"scrypt\",\n                total: _this.p * _this.N * 2\n              }) : void 0;\n            };\n          };\n\n          (function (__iced_k) {\n            var _i, _results, _while;\n\n            j = 0;\n            _begin = 0;\n            _end = _this.p;\n            _positive = _end > _begin;\n\n            _while = function (__iced_k) {\n              var _break, _continue, _next;\n\n              _break = __iced_k;\n\n              _continue = function () {\n                return iced.trampoline(function () {\n                  if (_positive) {\n                    j += 1;\n                  } else {\n                    j -= 1;\n                  }\n\n                  return _while(__iced_k);\n                });\n              };\n\n              _next = _continue;\n\n              if (!!(_positive === true && j >= _this.p || _positive === false && j <= _this.p)) {\n                return _break();\n              } else {\n                (function (__iced_k) {\n                  __iced_deferrals = new iced.Deferrals(__iced_k, {\n                    parent: ___iced_passed_deferral,\n                    filename: \"/Users/max/src/keybase/triplesec/src/scrypt.iced\",\n                    funcname: \"Scrypt.run\"\n                  });\n\n                  _this.smix({\n                    B: B.subarray(32 * _this.r * j),\n                    V: V,\n                    XY: XY,\n                    progress_hook: lph(j)\n                  }, __iced_deferrals.defer({\n                    lineno: 221\n                  }));\n\n                  __iced_deferrals._fulfill();\n                })(_next);\n              }\n            };\n\n            _while(__iced_k);\n          })(function () {\n            v_endian_reverse(B);\n\n            lph = function (o) {\n              o.what += \" (pass 2)\";\n              return typeof progress_hook === \"function\" ? progress_hook(o) : void 0;\n            };\n\n            (function (__iced_k) {\n              __iced_deferrals = new iced.Deferrals(__iced_k, {\n                parent: ___iced_passed_deferral,\n                filename: \"/Users/max/src/keybase/triplesec/src/scrypt.iced\",\n                funcname: \"Scrypt.run\"\n              });\n\n              _this.pbkdf2({\n                key: key,\n                salt: WordArray.from_i32a(B),\n                dkLen: dkLen,\n                c: _this.c1,\n                progress_hook: lph\n              }, __iced_deferrals.defer({\n                assign_fn: function () {\n                  return function () {\n                    return out = arguments[0];\n                  };\n                }(),\n                lineno: 229\n              }));\n\n              __iced_deferrals._fulfill();\n            })(function () {\n              scrub_vec(XY);\n              scrub_vec(V);\n              scrub_vec(B);\n              key.scrub();\n              return cb(out);\n            });\n          });\n        };\n      }(this));\n    };\n\n    return Scrypt;\n  }();\n\n  scrypt = function (_arg, cb) {\n    var N, c, c0, c1, dkLen, eng, key, klass, p, progress_hook, r, salt, wa, ___iced_passed_deferral, __iced_deferrals, __iced_k;\n\n    __iced_k = __iced_k_noop;\n    ___iced_passed_deferral = iced.findDeferral(arguments);\n    key = _arg.key, salt = _arg.salt, r = _arg.r, N = _arg.N, p = _arg.p, c0 = _arg.c0, c1 = _arg.c1, c = _arg.c, klass = _arg.klass, progress_hook = _arg.progress_hook, dkLen = _arg.dkLen;\n    eng = new Scrypt({\n      r: r,\n      N: N,\n      p: p,\n      c: c,\n      c0: c0,\n      c1: c1,\n      klass: klass\n    });\n    (function (_this) {\n      return function (__iced_k) {\n        __iced_deferrals = new iced.Deferrals(__iced_k, {\n          parent: ___iced_passed_deferral,\n          filename: \"/Users/max/src/keybase/triplesec/src/scrypt.iced\"\n        });\n        eng.run({\n          key: key,\n          salt: salt,\n          progress_hook: progress_hook,\n          dkLen: dkLen\n        }, __iced_deferrals.defer({\n          assign_fn: function () {\n            return function () {\n              return wa = arguments[0];\n            };\n          }(),\n          lineno: 259\n        }));\n\n        __iced_deferrals._fulfill();\n      };\n    })(this)(function (_this) {\n      return function () {\n        return cb(wa);\n      };\n    }(this));\n  };\n\n  exports.Scrypt = Scrypt;\n  exports.scrypt = scrypt;\n  exports.v_endian_reverse = v_endian_reverse;\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}