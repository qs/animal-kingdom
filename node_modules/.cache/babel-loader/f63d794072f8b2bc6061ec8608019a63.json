{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst url = require(\"url\");\n\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n\nconst config_1 = require(\"./config\");\n\nconst logger_1 = require(\"./logger\");\n/**\n *  @ignore\n */\n\n\nexports.BLOCKSTACK_HANDLER = 'blockstack';\n/**\n * Time\n * @private\n * @ignore\n */\n\nfunction nextYear() {\n  return new Date(new Date().setFullYear(new Date().getFullYear() + 1));\n}\n\nexports.nextYear = nextYear;\n/**\n * Time\n * @private\n * @ignore\n */\n\nfunction nextMonth() {\n  return new Date(new Date().setMonth(new Date().getMonth() + 1));\n}\n\nexports.nextMonth = nextMonth;\n/**\n * Time\n * @private\n * @ignore\n */\n\nfunction nextHour() {\n  return new Date(new Date().setHours(new Date().getHours() + 1));\n}\n\nexports.nextHour = nextHour;\n/**\n * Query Strings\n * @private\n * @ignore\n */\n\nfunction updateQueryStringParameter(uri, key, value) {\n  const re = new RegExp(\"([?&])\".concat(key, \"=.*?(&|$)\"), 'i');\n  const separator = uri.indexOf('?') !== -1 ? '&' : '?';\n\n  if (uri.match(re)) {\n    return uri.replace(re, \"$1\".concat(key, \"=\").concat(value, \"$2\"));\n  } else {\n    return \"\".concat(uri).concat(separator).concat(key, \"=\").concat(value);\n  }\n}\n\nexports.updateQueryStringParameter = updateQueryStringParameter;\n/**\n * Versioning\n * @param {string} v1 - the left half of the version inequality\n * @param {string} v2 - right half of the version inequality\n * @returns {bool} iff v1 >= v2\n * @private\n * @ignore\n */\n\nfunction isLaterVersion(v1, v2) {\n  if (v1 === undefined) {\n    v1 = '0.0.0';\n  }\n\n  if (v2 === undefined) {\n    v2 = '0.0.0';\n  }\n\n  const v1tuple = v1.split('.').map(x => parseInt(x, 10));\n  const v2tuple = v2.split('.').map(x => parseInt(x, 10));\n\n  for (let index = 0; index < v2.length; index++) {\n    if (index >= v1.length) {\n      v2tuple.push(0);\n    }\n\n    if (v1tuple[index] < v2tuple[index]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexports.isLaterVersion = isLaterVersion;\n/**\n * Time\n * @private\n * @ignore\n */\n\nfunction hexStringToECPair(skHex) {\n  const ecPairOptions = {\n    network: config_1.config.network.layer1,\n    compressed: true\n  };\n\n  if (skHex.length === 66) {\n    if (skHex.slice(64) !== '01') {\n      throw new Error('Improperly formatted private-key hex string. 66-length hex usually ' + 'indicates compressed key, but last byte must be == 1');\n    }\n\n    return bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(skHex.slice(0, 64), 'hex'), ecPairOptions);\n  } else if (skHex.length === 64) {\n    ecPairOptions.compressed = false;\n    return bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(skHex, 'hex'), ecPairOptions);\n  } else {\n    throw new Error('Improperly formatted private-key hex string: length should be 64 or 66.');\n  }\n}\n\nexports.hexStringToECPair = hexStringToECPair;\n/**\n *\n * @ignore\n */\n\nfunction ecPairToHexString(secretKey) {\n  const ecPointHex = secretKey.privateKey.toString('hex');\n\n  if (secretKey.compressed) {\n    return \"\".concat(ecPointHex, \"01\");\n  } else {\n    return ecPointHex;\n  }\n}\n\nexports.ecPairToHexString = ecPairToHexString;\n/**\n * Time\n * @private\n * @ignore\n */\n\nfunction ecPairToAddress(keyPair) {\n  return bitcoinjs_lib_1.address.toBase58Check(bitcoinjs_lib_1.crypto.hash160(keyPair.publicKey), keyPair.network.pubKeyHash);\n}\n\nexports.ecPairToAddress = ecPairToAddress;\n/**\n * UUIDs\n * @private\n * @ignore\n */\n\nfunction makeUUID4() {\n  let d = new Date().getTime();\n\n  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n    d += performance.now(); // use high-precision timer if available\n  }\n\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c === 'x' ? r : r & 0x3 | 0x8).toString(16);\n  });\n}\n\nexports.makeUUID4 = makeUUID4;\n/**\n * Checks if both urls pass the same origin check & are absolute\n * @param  {[type]}  uri1 first uri to check\n * @param  {[type]}  uri2 second uri to check\n * @return {Boolean} true if they pass the same origin check\n * @private\n * @ignore\n */\n\nfunction isSameOriginAbsoluteUrl(uri1, uri2) {\n  const parsedUri1 = url.parse(uri1);\n  const parsedUri2 = url.parse(uri2);\n  const port1 = parseInt(parsedUri1.port || '0', 10) | 0 || (parsedUri1.protocol === 'https:' ? 443 : 80);\n  const port2 = parseInt(parsedUri2.port || '0', 10) | 0 || (parsedUri2.protocol === 'https:' ? 443 : 80);\n  const match = {\n    scheme: parsedUri1.protocol === parsedUri2.protocol,\n    hostname: parsedUri1.hostname === parsedUri2.hostname,\n    port: port1 === port2,\n    absolute: (uri1.includes('http://') || uri1.includes('https://')) && (uri2.includes('http://') || uri2.includes('https://'))\n  };\n  return match.scheme && match.hostname && match.port && match.absolute;\n}\n\nexports.isSameOriginAbsoluteUrl = isSameOriginAbsoluteUrl;\n/**\n * Returns the global scope `Window`, `WorkerGlobalScope`, or `NodeJS.Global` if available in the\n * currently executing environment.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/self\n * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope\n *\n * This could be switched to `globalThis` once it is standardized and widely available.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis\n */\n\nfunction getGlobalScope() {\n  if (typeof self !== 'undefined') {\n    return self;\n  }\n\n  if (typeof window !== 'undefined') {\n    return window;\n  } // This function is meant to be called when accessing APIs that are typically only available in\n  // web-browser/DOM environments, but we also want to support situations where running in Node.js \n  // environment, and a polyfill was added to the Node.js `global` object scope without adding the \n  // `window` global object as well. \n\n\n  if (typeof global !== 'undefined') {\n    return global;\n  }\n\n  throw new Error('Unexpected runtime environment - no supported global scope (`window`, `self`, `global`) available');\n}\n\nfunction getAPIUsageErrorMessage(scopeObject, apiName, usageDesc) {\n  if (usageDesc) {\n    return \"Use of '\".concat(usageDesc, \"' requires `\").concat(apiName, \"` which is unavailable on the '\").concat(scopeObject, \"' object within the currently executing environment.\");\n  } else {\n    return \"`\".concat(apiName, \"` is unavailable on the '\").concat(scopeObject, \"' object within the currently executing environment.\");\n  }\n}\n/**\n * Returns an object from the global scope (`Window` or `WorkerGlobalScope`) if it\n * is available within the currently executing environment.\n * When executing within the Node.js runtime these APIs are unavailable and will be\n * `undefined` unless the API is provided via polyfill.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n * @ignore\n */\n\n\nfunction getGlobalObject(name, {\n  throwIfUnavailable,\n  usageDesc,\n  returnEmptyObject\n} = {}) {\n  let globalScope;\n\n  try {\n    globalScope = getGlobalScope();\n\n    if (globalScope) {\n      const obj = globalScope[name];\n\n      if (obj) {\n        return obj;\n      }\n    }\n  } catch (error) {\n    logger_1.Logger.error(\"Error getting object '\".concat(name, \"' from global scope '\").concat(globalScope, \"': \").concat(error));\n  }\n\n  if (throwIfUnavailable) {\n    const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n    logger_1.Logger.error(errMsg);\n    throw new Error(errMsg);\n  }\n\n  if (returnEmptyObject) {\n    return {};\n  }\n\n  return undefined;\n}\n\nexports.getGlobalObject = getGlobalObject;\n/**\n * Returns a specified subset of objects from the global scope (`Window` or `WorkerGlobalScope`)\n * if they are available within the currently executing environment.\n * When executing within the Node.js runtime these APIs are unavailable will be `undefined`\n * unless the API is provided via polyfill.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Window/self\n * @ignore\n */\n\nfunction getGlobalObjects(names, {\n  throwIfUnavailable,\n  usageDesc,\n  returnEmptyObject\n} = {}) {\n  let globalScope;\n\n  try {\n    globalScope = getGlobalScope();\n  } catch (error) {\n    logger_1.Logger.error(\"Error getting global scope: \".concat(error));\n\n    if (throwIfUnavailable) {\n      const errMsg = getAPIUsageErrorMessage(globalScope, names[0].toString(), usageDesc);\n      logger_1.Logger.error(errMsg);\n      throw errMsg;\n    } else if (returnEmptyObject) {\n      globalScope = {};\n    }\n  }\n\n  const result = {};\n\n  for (let i = 0; i < names.length; i++) {\n    const name = names[i];\n\n    try {\n      if (globalScope) {\n        const obj = globalScope[name];\n\n        if (obj) {\n          result[name] = obj;\n        } else if (throwIfUnavailable) {\n          const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n          logger_1.Logger.error(errMsg);\n          throw new Error(errMsg);\n        } else if (returnEmptyObject) {\n          result[name] = {};\n        }\n      }\n    } catch (error) {\n      if (throwIfUnavailable) {\n        const errMsg = getAPIUsageErrorMessage(globalScope, name.toString(), usageDesc);\n        logger_1.Logger.error(errMsg);\n        throw new Error(errMsg);\n      }\n    }\n  }\n\n  return result;\n}\n\nexports.getGlobalObjects = getGlobalObjects;","map":null,"metadata":{},"sourceType":"script"}