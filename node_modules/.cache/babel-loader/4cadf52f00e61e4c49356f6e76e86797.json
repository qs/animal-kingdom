{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\"); // @ts-ignore: Could not find a declaration file for module\n\n\nconst jsontokens_1 = require(\"jsontokens\");\n\nconst utils_1 = require(\"../utils\");\n/**\n  * Signs a profile token\n  * @param {Object} profile - the JSON of the profile to be signed\n  * @param {String} privateKey - the signing private key\n  * @param {Object} subject - the entity that the information is about\n  * @param {Object} issuer - the entity that is issuing the token\n  * @param {String} signingAlgorithm - the signing algorithm to use\n  * @param {Date} issuedAt - the time of issuance of the token\n  * @param {Date} expiresAt - the time of expiration of the token\n  * @returns {Object} - the signed profile token\n  *\n  */\n\n\nfunction signProfileToken(profile, privateKey, subject, issuer, signingAlgorithm = 'ES256K', issuedAt = new Date(), expiresAt = utils_1.nextYear()) {\n  if (signingAlgorithm !== 'ES256K') {\n    throw new Error('Signing algorithm not supported');\n  }\n\n  const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(privateKey);\n\n  if (!subject) {\n    subject = {\n      publicKey\n    };\n  }\n\n  if (!issuer) {\n    issuer = {\n      publicKey\n    };\n  }\n\n  const tokenSigner = new jsontokens_1.TokenSigner(signingAlgorithm, privateKey);\n  const payload = {\n    jti: utils_1.makeUUID4(),\n    iat: issuedAt.toISOString(),\n    exp: expiresAt.toISOString(),\n    subject,\n    issuer,\n    claim: profile\n  };\n  return tokenSigner.sign(payload);\n}\n\nexports.signProfileToken = signProfileToken;\n/**\n  * Wraps a token for a profile token file\n  * @param {String} token - the token to be wrapped\n  * @returns {Object} - including `token` and `decodedToken`\n  */\n\nfunction wrapProfileToken(token) {\n  return {\n    token,\n    decodedToken: jsontokens_1.decodeToken(token)\n  };\n}\n\nexports.wrapProfileToken = wrapProfileToken;\n/**\n  * Verifies a profile token\n  * @param {String} token - the token to be verified\n  * @param {String} publicKeyOrAddress - the public key or address of the\n  *   keypair that is thought to have signed the token\n  * @returns {Object} - the verified, decoded profile token\n  * @throws {Error} - throws an error if token verification fails\n  */\n\nfunction verifyProfileToken(token, publicKeyOrAddress) {\n  const decodedToken = jsontokens_1.decodeToken(token);\n  const payload = decodedToken.payload;\n\n  if (typeof payload === 'string') {\n    throw new Error('Unexpected token payload type of string');\n  } // Inspect and verify the subject\n\n\n  if (payload.hasOwnProperty('subject')) {\n    if (!payload.subject.hasOwnProperty('publicKey')) {\n      throw new Error('Token doesn\\'t have a subject public key');\n    }\n  } else {\n    throw new Error('Token doesn\\'t have a subject');\n  } // Inspect and verify the issuer\n\n\n  if (payload.hasOwnProperty('issuer')) {\n    if (!payload.issuer.hasOwnProperty('publicKey')) {\n      throw new Error('Token doesn\\'t have an issuer public key');\n    }\n  } else {\n    throw new Error('Token doesn\\'t have an issuer');\n  } // Inspect and verify the claim\n\n\n  if (!payload.hasOwnProperty('claim')) {\n    throw new Error('Token doesn\\'t have a claim');\n  }\n\n  const issuerPublicKey = payload.issuer.publicKey;\n  const publicKeyBuffer = Buffer.from(issuerPublicKey, 'hex');\n  const compressedKeyPair = bitcoinjs_lib_1.ECPair.fromPublicKey(publicKeyBuffer, {\n    compressed: true\n  });\n  const compressedAddress = utils_1.ecPairToAddress(compressedKeyPair);\n  const uncompressedKeyPair = bitcoinjs_lib_1.ECPair.fromPublicKey(publicKeyBuffer, {\n    compressed: false\n  });\n  const uncompressedAddress = utils_1.ecPairToAddress(uncompressedKeyPair);\n\n  if (publicKeyOrAddress === issuerPublicKey) {// pass\n  } else if (publicKeyOrAddress === compressedAddress) {// pass\n  } else if (publicKeyOrAddress === uncompressedAddress) {// pass\n  } else {\n    throw new Error('Token issuer public key does not match the verifying value');\n  }\n\n  const tokenVerifier = new jsontokens_1.TokenVerifier(decodedToken.header.alg, issuerPublicKey);\n\n  if (!tokenVerifier) {\n    throw new Error('Invalid token verifier');\n  }\n\n  const tokenVerified = tokenVerifier.verify(token);\n\n  if (!tokenVerified) {\n    throw new Error('Token verification failed');\n  }\n\n  return decodedToken;\n}\n\nexports.verifyProfileToken = verifyProfileToken;\n/**\n  * Extracts a profile from an encoded token and optionally verifies it,\n  * if `publicKeyOrAddress` is provided.\n  * @param {String} token - the token to be extracted\n  * @param {String} publicKeyOrAddress - the public key or address of the\n  *   keypair that is thought to have signed the token\n  * @returns {Object} - the profile extracted from the encoded token\n  * @throws {Error} - if the token isn't signed by the provided `publicKeyOrAddress`\n  */\n\nfunction extractProfile(token, publicKeyOrAddress = null) {\n  let decodedToken;\n\n  if (publicKeyOrAddress) {\n    decodedToken = verifyProfileToken(token, publicKeyOrAddress);\n  } else {\n    decodedToken = jsontokens_1.decodeToken(token);\n  }\n\n  let profile = {};\n\n  if (decodedToken.hasOwnProperty('payload')) {\n    const payload = decodedToken.payload;\n\n    if (typeof payload === 'string') {\n      throw new Error('Unexpected token payload type of string');\n    }\n\n    if (payload.hasOwnProperty('claim')) {\n      profile = payload.claim;\n    }\n  }\n\n  return profile;\n}\n\nexports.extractProfile = extractProfile;","map":null,"metadata":{},"sourceType":"script"}