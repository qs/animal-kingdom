{"ast":null,"code":"// Generated by IcedCoffeeScript 108.0.8\n(function () {\n  var Global,\n      Hasher,\n      SHA3,\n      WordArray,\n      X64Word,\n      X64WordArray,\n      glbl,\n      _ref,\n      __hasProp = {}.hasOwnProperty,\n      __extends = function (child, parent) {\n    for (var key in parent) {\n      if (__hasProp.call(parent, key)) child[key] = parent[key];\n    }\n\n    function ctor() {\n      this.constructor = child;\n    }\n\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n    child.__super__ = parent.prototype;\n    return child;\n  };\n\n  _ref = require('./wordarray'), WordArray = _ref.WordArray, X64Word = _ref.X64Word, X64WordArray = _ref.X64WordArray;\n  Hasher = require('./algbase').Hasher;\n\n  Global = function () {\n    function Global() {\n      this.RHO_OFFSETS = [];\n      this.PI_INDEXES = [];\n      this.ROUND_CONSTANTS = [];\n      this.T = [];\n      this.compute_rho_offsets();\n      this.compute_pi_indexes();\n      this.compute_round_constants();\n      this.make_reusables();\n    }\n\n    Global.prototype.compute_rho_offsets = function () {\n      var newX, newY, t, x, y, _i, _results;\n\n      x = 1;\n      y = 0;\n      _results = [];\n\n      for (t = _i = 0; _i < 24; t = ++_i) {\n        this.RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;\n        newX = y % 5;\n        newY = (2 * x + 3 * y) % 5;\n        x = newX;\n\n        _results.push(y = newY);\n      }\n\n      return _results;\n    };\n\n    Global.prototype.compute_pi_indexes = function () {\n      var x, y, _i, _results;\n\n      _results = [];\n\n      for (x = _i = 0; _i < 5; x = ++_i) {\n        _results.push(function () {\n          var _j, _results1;\n\n          _results1 = [];\n\n          for (y = _j = 0; _j < 5; y = ++_j) {\n            _results1.push(this.PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5);\n          }\n\n          return _results1;\n        }.call(this));\n      }\n\n      return _results;\n    };\n\n    Global.prototype.compute_round_constants = function () {\n      var LFSR, bitPosition, i, j, roundConstantLsw, roundConstantMsw, _i, _j, _results;\n\n      LFSR = 0x01;\n      _results = [];\n\n      for (i = _i = 0; _i < 24; i = ++_i) {\n        roundConstantMsw = 0;\n        roundConstantLsw = 0;\n\n        for (j = _j = 0; _j < 7; j = ++_j) {\n          if (LFSR & 0x01) {\n            bitPosition = (1 << j) - 1;\n\n            if (bitPosition < 32) {\n              roundConstantLsw ^= 1 << bitPosition;\n            } else {\n              roundConstantMsw ^= 1 << bitPosition - 32;\n            }\n          }\n\n          if (LFSR & 0x80) {\n            LFSR = LFSR << 1 ^ 0x71;\n          } else {\n            LFSR <<= 1;\n          }\n        }\n\n        _results.push(this.ROUND_CONSTANTS[i] = new X64Word(roundConstantMsw, roundConstantLsw));\n      }\n\n      return _results;\n    };\n\n    Global.prototype.make_reusables = function () {\n      var i;\n      return this.T = function () {\n        var _i, _results;\n\n        _results = [];\n\n        for (i = _i = 0; _i < 25; i = ++_i) {\n          _results.push(new X64Word(0, 0));\n        }\n\n        return _results;\n      }();\n    };\n\n    return Global;\n  }();\n\n  glbl = new Global();\n\n  exports.SHA3 = SHA3 = function (_super) {\n    __extends(SHA3, _super);\n\n    function SHA3() {\n      return SHA3.__super__.constructor.apply(this, arguments);\n    }\n\n    SHA3.outputLength = 512;\n    SHA3.prototype.outputLength = SHA3.outputLength;\n    SHA3.blockSize = (1600 - 2 * SHA3.outputLength) / 32;\n    SHA3.prototype.blockSize = SHA3.blockSize;\n    SHA3.output_size = SHA3.outputLength / 8;\n    SHA3.prototype.output_size = SHA3.output_size;\n\n    SHA3.prototype._doReset = function () {\n      var i;\n      return this._state = function () {\n        var _i, _results;\n\n        _results = [];\n\n        for (i = _i = 0; _i < 25; i = ++_i) {\n          _results.push(new X64Word(0, 0));\n        }\n\n        return _results;\n      }();\n    };\n\n    SHA3.prototype._doProcessBlock = function (M, offset) {\n      var G, M2i, M2i1, T0, TLane, TPiLane, Tx, Tx1, Tx1Lane, Tx1Lsw, Tx1Msw, Tx2Lane, Tx4, i, lane, laneIndex, laneLsw, laneMsw, nBlockSizeLanes, rhoOffset, round, roundConstant, state, state0, tLsw, tMsw, x, y, _i, _j, _k, _l, _m, _n, _o, _p, _q, _results;\n\n      G = glbl;\n      state = this._state;\n      nBlockSizeLanes = this.blockSize / 2;\n\n      for (i = _i = 0; 0 <= nBlockSizeLanes ? _i < nBlockSizeLanes : _i > nBlockSizeLanes; i = 0 <= nBlockSizeLanes ? ++_i : --_i) {\n        M2i = M[offset + 2 * i];\n        M2i1 = M[offset + 2 * i + 1];\n        M2i = (M2i << 8 | M2i >>> 24) & 0x00ff00ff | (M2i << 24 | M2i >>> 8) & 0xff00ff00;\n        M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 0x00ff00ff | (M2i1 << 24 | M2i1 >>> 8) & 0xff00ff00;\n        lane = state[i];\n        lane.high ^= M2i1;\n        lane.low ^= M2i;\n      }\n\n      _results = [];\n\n      for (round = _j = 0; _j < 24; round = ++_j) {\n        for (x = _k = 0; _k < 5; x = ++_k) {\n          tMsw = tLsw = 0;\n\n          for (y = _l = 0; _l < 5; y = ++_l) {\n            lane = state[x + 5 * y];\n            tMsw ^= lane.high;\n            tLsw ^= lane.low;\n          }\n\n          Tx = G.T[x];\n          Tx.high = tMsw;\n          Tx.low = tLsw;\n        }\n\n        for (x = _m = 0; _m < 5; x = ++_m) {\n          Tx4 = G.T[(x + 4) % 5];\n          Tx1 = G.T[(x + 1) % 5];\n          Tx1Msw = Tx1.high;\n          Tx1Lsw = Tx1.low;\n          tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);\n          tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);\n\n          for (y = _n = 0; _n < 5; y = ++_n) {\n            lane = state[x + 5 * y];\n            lane.high ^= tMsw;\n            lane.low ^= tLsw;\n          }\n        }\n\n        for (laneIndex = _o = 1; _o < 25; laneIndex = ++_o) {\n          lane = state[laneIndex];\n          laneMsw = lane.high;\n          laneLsw = lane.low;\n          rhoOffset = G.RHO_OFFSETS[laneIndex];\n\n          if (rhoOffset < 32) {\n            tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;\n            tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;\n          } else {\n            tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;\n            tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;\n          }\n\n          TPiLane = G.T[G.PI_INDEXES[laneIndex]];\n          TPiLane.high = tMsw;\n          TPiLane.low = tLsw;\n        }\n\n        T0 = G.T[0];\n        state0 = state[0];\n        T0.high = state0.high;\n        T0.low = state0.low;\n\n        for (x = _p = 0; _p < 5; x = ++_p) {\n          for (y = _q = 0; _q < 5; y = ++_q) {\n            laneIndex = x + 5 * y;\n            lane = state[laneIndex];\n            TLane = G.T[laneIndex];\n            Tx1Lane = G.T[(x + 1) % 5 + 5 * y];\n            Tx2Lane = G.T[(x + 2) % 5 + 5 * y];\n            lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;\n            lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;\n          }\n        }\n\n        lane = state[0];\n        roundConstant = G.ROUND_CONSTANTS[round];\n        lane.high ^= roundConstant.high;\n\n        _results.push(lane.low ^= roundConstant.low);\n      }\n\n      return _results;\n    };\n\n    SHA3.prototype._doFinalize = function () {\n      var blockSizeBits, data, dataWords, hashWords, i, lane, laneLsw, laneMsw, nBitsLeft, nBitsTotal, outputLengthBytes, outputLengthLanes, state, _i;\n\n      data = this._data;\n      dataWords = data.words;\n      nBitsTotal = this._nDataBytes * 8;\n      nBitsLeft = data.sigBytes * 8;\n      blockSizeBits = this.blockSize * 32;\n      dataWords[nBitsLeft >>> 5] |= 0x1 << 24 - nBitsLeft % 32;\n      dataWords[(Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 0x80;\n      data.sigBytes = dataWords.length * 4;\n\n      this._process();\n\n      state = this._state;\n      outputLengthBytes = this.outputLength / 8;\n      outputLengthLanes = outputLengthBytes / 8;\n      hashWords = [];\n\n      for (i = _i = 0; 0 <= outputLengthLanes ? _i < outputLengthLanes : _i > outputLengthLanes; i = 0 <= outputLengthLanes ? ++_i : --_i) {\n        lane = state[i];\n        laneMsw = lane.high;\n        laneLsw = lane.low;\n        laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 0x00ff00ff | (laneMsw << 24 | laneMsw >>> 8) & 0xff00ff00;\n        laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 0x00ff00ff | (laneLsw << 24 | laneLsw >>> 8) & 0xff00ff00;\n        hashWords.push(laneLsw);\n        hashWords.push(laneMsw);\n      }\n\n      return new WordArray(hashWords, outputLengthBytes);\n    };\n\n    SHA3.prototype.copy_to = function (obj) {\n      var s;\n\n      SHA3.__super__.copy_to.call(this, obj);\n\n      return obj._state = function () {\n        var _i, _len, _ref1, _results;\n\n        _ref1 = this._state;\n        _results = [];\n\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          s = _ref1[_i];\n\n          _results.push(s.clone());\n        }\n\n        return _results;\n      }.call(this);\n    };\n\n    SHA3.prototype.scrub = function () {};\n\n    SHA3.prototype.clone = function () {\n      var out;\n      out = new SHA3();\n      this.copy_to(out);\n      return out;\n    };\n\n    return SHA3;\n  }(Hasher);\n\n  exports.transform = function (x) {\n    var out;\n    out = new SHA3().finalize(x);\n    x.scrub();\n    return out;\n  };\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}