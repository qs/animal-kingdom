{"ast":null,"code":"/*\n * This module is intended to be executed both on client side and server side.\n * No error should be thrown. (soft error handling)\n */\n(function () {\n  var root = {}; // Dependencies --------------------------------------------------------------\n\n  root.async = typeof require === 'function' ? require('async') : window.async;\n\n  if (typeof root.async !== 'object') {\n    throw new Error('Module async is required (https://github.com/caolan/async)');\n  }\n\n  var async = root.async;\n\n  function _extend(origin, add) {\n    if (!add || typeof add !== 'object') {\n      return origin;\n    }\n\n    var keys = Object.keys(add);\n    var i = keys.length;\n\n    while (i--) {\n      origin[keys[i]] = add[keys[i]];\n    }\n\n    return origin;\n  }\n\n  function _merge() {\n    var ret = {};\n    var args = Array.prototype.slice.call(arguments);\n    var keys = null;\n    var i = null;\n    args.forEach(function (arg) {\n      if (arg && arg.constructor === Object) {\n        keys = Object.keys(arg);\n        i = keys.length;\n\n        while (i--) {\n          ret[keys[i]] = arg[keys[i]];\n        }\n      }\n    });\n    return ret;\n  } // Customisable class (Base class) -------------------------------------------\n  // Use with operation \"new\" to extend Validation and Sanitization themselves,\n  // not their prototype. In other words, constructor shall be call to extend\n  // those functions, instead of being in their constructor, like this:\n  //\t\t_extend(Validation, new Customisable);\n\n\n  function Customisable() {\n    this.custom = {};\n\n    this.extend = function (custom) {\n      return _extend(this.custom, custom);\n    };\n\n    this.reset = function () {\n      this.custom = {};\n    };\n\n    this.remove = function (fields) {\n      if (!_typeIs.array(fields)) {\n        fields = [fields];\n      }\n\n      fields.forEach(function (field) {\n        delete this.custom[field];\n      }, this);\n    };\n  } // Inspection class (Base class) ---------------------------------------------\n  // Use to extend Validation and Sanitization prototypes. Inspection\n  // constructor shall be called in derived class constructor.\n\n\n  function Inspection(schema, custom) {\n    var _stack = ['@'];\n    this._schema = schema;\n    this._custom = {};\n\n    if (custom != null) {\n      for (var key in custom) {\n        if (custom.hasOwnProperty(key)) {\n          this._custom['$' + key] = custom[key];\n        }\n      }\n    }\n\n    this._getDepth = function () {\n      return _stack.length;\n    };\n\n    this._dumpStack = function () {\n      return _stack.map(function (i) {\n        return i.replace(/^\\[/g, '\\u001b\\u001c\\u001d\\u001e');\n      }).join('.').replace(/\\.\\u001b\\u001c\\u001d\\u001e/g, '[');\n    };\n\n    this._deeperObject = function (name) {\n      _stack.push(/^[a-z$_][a-z0-9$_]*$/i.test(name) ? name : '[\"' + name + '\"]');\n\n      return this;\n    };\n\n    this._deeperArray = function (i) {\n      _stack.push('[' + i + ']');\n\n      return this;\n    };\n\n    this._back = function () {\n      _stack.pop();\n\n      return this;\n    };\n  } // Simple types --------------------------------------------------------------\n  // If the property is not defined or is not in this list:\n\n\n  var _typeIs = {\n    \"function\": function (element) {\n      return typeof element === 'function';\n    },\n    \"string\": function (element) {\n      return typeof element === 'string';\n    },\n    \"number\": function (element) {\n      return typeof element === 'number' && !isNaN(element);\n    },\n    \"integer\": function (element) {\n      return typeof element === 'number' && element % 1 === 0;\n    },\n    \"NaN\": function (element) {\n      return typeof element === 'number' && isNaN(element);\n    },\n    \"boolean\": function (element) {\n      return typeof element === 'boolean';\n    },\n    \"null\": function (element) {\n      return element === null;\n    },\n    \"date\": function (element) {\n      return element != null && element instanceof Date;\n    },\n    \"object\": function (element) {\n      return element != null && element.constructor === Object;\n    },\n    \"array\": function (element) {\n      return element != null && element.constructor === Array;\n    },\n    \"any\": function (element) {\n      return true;\n    }\n  };\n\n  function _simpleType(type, candidate) {\n    if (typeof type == 'function') {\n      return candidate instanceof type;\n    }\n\n    type = type in _typeIs ? type : 'any';\n    return _typeIs[type](candidate);\n  }\n\n  function _realType(candidate) {\n    for (var i in _typeIs) {\n      if (_simpleType(i, candidate)) {\n        if (i !== 'any') {\n          return i;\n        }\n\n        return 'an instance of ' + candidate.constructor.name;\n      }\n    }\n  }\n\n  function getIndexes(a, value) {\n    var indexes = [];\n    var i = a.indexOf(value);\n\n    while (i !== -1) {\n      indexes.push(i);\n      i = a.indexOf(value, i + 1);\n    }\n\n    return indexes;\n  } // Available formats ---------------------------------------------------------\n\n\n  var _formats = {\n    'void': /^$/,\n    'url': /^(https?|ftp):\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)?(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i,\n    'date-time': /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d{3})?(Z?|(-|\\+)\\d{2}:\\d{2})$/,\n    'date': /^\\d{4}-\\d{2}-\\d{2}$/,\n    'coolDateTime': /^\\d{4}(-|\\/)\\d{2}(-|\\/)\\d{2}(T| )\\d{2}:\\d{2}:\\d{2}(\\.\\d{3})?Z?$/,\n    'time': /^\\d{2}\\:\\d{2}\\:\\d{2}$/,\n    'color': /^#([0-9a-f])+$/i,\n    'email': /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?$/i,\n    'numeric': /^[0-9]+$/,\n    'integer': /^\\-?[0-9]+$/,\n    'decimal': /^\\-?[0-9]*\\.?[0-9]+$/,\n    'alpha': /^[a-z]+$/i,\n    'alphaNumeric': /^[a-z0-9]+$/i,\n    'alphaDash': /^[a-z0-9_-]+$/i,\n    'javascript': /^[a-z_\\$][a-z0-9_\\$]*$/i,\n    'upperString': /^[A-Z ]*$/,\n    'lowerString': /^[a-z ]*$/\n  }; // Validation ------------------------------------------------------------------\n\n  var _validationAttribut = {\n    optional: function (schema, candidate) {\n      var opt = typeof schema.optional === 'boolean' ? schema.optional : schema.optional === 'true'; // Default is false\n\n      if (opt === true) {\n        return;\n      }\n\n      if (typeof candidate === 'undefined') {\n        this.report('is missing and not optional', null, 'optional');\n      }\n    },\n    type: function (schema, candidate) {\n      // return because optional function already handle this case\n      if (typeof candidate === 'undefined' || typeof schema.type !== 'string' && !(schema.type instanceof Array) && typeof schema.type !== 'function') {\n        return;\n      }\n\n      var types = _typeIs.array(schema.type) ? schema.type : [schema.type];\n      var typeIsValid = types.some(function (type) {\n        return _simpleType(type, candidate);\n      });\n\n      if (!typeIsValid) {\n        types = types.map(function (t) {\n          return typeof t === 'function' ? 'and instance of ' + t.name : t;\n        });\n        this.report('must be ' + types.join(' or ') + ', but is ' + _realType(candidate), null, 'type');\n      }\n    },\n    uniqueness: function (schema, candidate) {\n      if (typeof schema.uniqueness === 'string') {\n        schema.uniqueness = schema.uniqueness === 'true';\n      }\n\n      if (typeof schema.uniqueness !== 'boolean' || schema.uniqueness === false || !_typeIs.array(candidate) && typeof candidate !== 'string') {\n        return;\n      }\n\n      var reported = [];\n\n      for (var i = 0; i < candidate.length; i++) {\n        if (reported.indexOf(candidate[i]) >= 0) {\n          continue;\n        }\n\n        var indexes = getIndexes(candidate, candidate[i]);\n\n        if (indexes.length > 1) {\n          reported.push(candidate[i]);\n          this.report('has value [' + candidate[i] + '] more than once at indexes [' + indexes.join(', ') + ']', null, 'uniqueness');\n        }\n      }\n    },\n    pattern: function (schema, candidate) {\n      var self = this;\n      var regexs = schema.pattern;\n\n      if (typeof candidate !== 'string') {\n        return;\n      }\n\n      var matches = false;\n\n      if (!_typeIs.array(regexs)) {\n        regexs = [regexs];\n      }\n\n      regexs.forEach(function (regex) {\n        if (typeof regex === 'string' && regex in _formats) {\n          regex = _formats[regex];\n        }\n\n        if (regex instanceof RegExp) {\n          if (regex.test(candidate)) {\n            matches = true;\n          }\n        }\n      });\n\n      if (!matches) {\n        self.report('must match [' + regexs.join(' or ') + '], but is equal to \"' + candidate + '\"', null, 'pattern');\n      }\n    },\n    validDate: function (schema, candidate) {\n      if (String(schema.validDate) === 'true' && candidate instanceof Date && isNaN(candidate.getTime())) {\n        this.report('must be a valid date', null, 'validDate');\n      }\n    },\n    minLength: function (schema, candidate) {\n      if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {\n        return;\n      }\n\n      var minLength = Number(schema.minLength);\n\n      if (isNaN(minLength)) {\n        return;\n      }\n\n      if (candidate.length < minLength) {\n        this.report('must be longer than ' + minLength + ' elements, but it has ' + candidate.length, null, 'minLength');\n      }\n    },\n    maxLength: function (schema, candidate) {\n      if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {\n        return;\n      }\n\n      var maxLength = Number(schema.maxLength);\n\n      if (isNaN(maxLength)) {\n        return;\n      }\n\n      if (candidate.length > maxLength) {\n        this.report('must be shorter than ' + maxLength + ' elements, but it has ' + candidate.length, null, 'maxLength');\n      }\n    },\n    exactLength: function (schema, candidate) {\n      if (typeof candidate !== 'string' && !_typeIs.array(candidate)) {\n        return;\n      }\n\n      var exactLength = Number(schema.exactLength);\n\n      if (isNaN(exactLength)) {\n        return;\n      }\n\n      if (candidate.length !== exactLength) {\n        this.report('must have exactly ' + exactLength + ' elements, but it have ' + candidate.length, null, 'exactLength');\n      }\n    },\n    lt: function (schema, candidate) {\n      var limit = Number(schema.lt);\n\n      if (typeof candidate !== 'number' || isNaN(limit)) {\n        return;\n      }\n\n      if (candidate >= limit) {\n        this.report('must be less than ' + limit + ', but is equal to \"' + candidate + '\"', null, 'lt');\n      }\n    },\n    lte: function (schema, candidate) {\n      var limit = Number(schema.lte);\n\n      if (typeof candidate !== 'number' || isNaN(limit)) {\n        return;\n      }\n\n      if (candidate > limit) {\n        this.report('must be less than or equal to ' + limit + ', but is equal to \"' + candidate + '\"', null, 'lte');\n      }\n    },\n    gt: function (schema, candidate) {\n      var limit = Number(schema.gt);\n\n      if (typeof candidate !== 'number' || isNaN(limit)) {\n        return;\n      }\n\n      if (candidate <= limit) {\n        this.report('must be greater than ' + limit + ', but is equal to \"' + candidate + '\"', null, 'gt');\n      }\n    },\n    gte: function (schema, candidate) {\n      var limit = Number(schema.gte);\n\n      if (typeof candidate !== 'number' || isNaN(limit)) {\n        return;\n      }\n\n      if (candidate < limit) {\n        this.report('must be greater than or equal to ' + limit + ', but is equal to \"' + candidate + '\"', null, 'gte');\n      }\n    },\n    eq: function (schema, candidate) {\n      if (typeof candidate !== 'number' && typeof candidate !== 'string' && typeof candidate !== 'boolean') {\n        return;\n      }\n\n      var limit = schema.eq;\n\n      if (typeof limit !== 'number' && typeof limit !== 'string' && typeof limit !== 'boolean' && !_typeIs.array(limit)) {\n        return;\n      }\n\n      if (_typeIs.array(limit)) {\n        for (var i = 0; i < limit.length; i++) {\n          if (candidate === limit[i]) {\n            return;\n          }\n        }\n\n        this.report('must be equal to [' + limit.map(function (l) {\n          return '\"' + l + '\"';\n        }).join(' or ') + '], but is equal to \"' + candidate + '\"', null, 'eq');\n      } else {\n        if (candidate !== limit) {\n          this.report('must be equal to \"' + limit + '\", but is equal to \"' + candidate + '\"', null, 'eq');\n        }\n      }\n    },\n    ne: function (schema, candidate) {\n      if (typeof candidate !== 'number' && typeof candidate !== 'string') {\n        return;\n      }\n\n      var limit = schema.ne;\n\n      if (typeof limit !== 'number' && typeof limit !== 'string' && !_typeIs.array(limit)) {\n        return;\n      }\n\n      if (_typeIs.array(limit)) {\n        for (var i = 0; i < limit.length; i++) {\n          if (candidate === limit[i]) {\n            this.report('must not be equal to \"' + limit[i] + '\"', null, 'ne');\n            return;\n          }\n        }\n      } else {\n        if (candidate === limit) {\n          this.report('must not be equal to \"' + limit + '\"', null, 'ne');\n        }\n      }\n    },\n    someKeys: function (schema, candidat) {\n      var _keys = schema.someKeys;\n\n      if (!_typeIs.object(candidat)) {\n        return;\n      }\n\n      var valid = _keys.some(function (action) {\n        return action in candidat;\n      });\n\n      if (!valid) {\n        this.report('must have at least key ' + _keys.map(function (i) {\n          return '\"' + i + '\"';\n        }).join(' or '), null, 'someKeys');\n      }\n    },\n    strict: function (schema, candidate) {\n      if (typeof schema.strict === 'string') {\n        schema.strict = schema.strict === 'true';\n      }\n\n      if (schema.strict !== true || !_typeIs.object(candidate) || !_typeIs.object(schema.properties)) {\n        return;\n      }\n\n      var self = this;\n\n      if (typeof schema.properties['*'] === 'undefined') {\n        var intruder = Object.keys(candidate).filter(function (key) {\n          return typeof schema.properties[key] === 'undefined';\n        });\n\n        if (intruder.length > 0) {\n          var msg = 'should not contains ' + (intruder.length > 1 ? 'properties' : 'property') + ' [' + intruder.map(function (i) {\n            return '\"' + i + '\"';\n          }).join(', ') + ']';\n          self.report(msg, null, 'strict');\n        }\n      }\n    },\n    exec: function (schema, candidate, callback) {\n      var self = this;\n\n      if (typeof callback === 'function') {\n        return this.asyncExec(schema, candidate, callback);\n      }\n\n      (_typeIs.array(schema.exec) ? schema.exec : [schema.exec]).forEach(function (exec) {\n        if (typeof exec === 'function') {\n          exec.call(self, schema, candidate);\n        }\n      });\n    },\n    properties: function (schema, candidate, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncProperties(schema, candidate, callback);\n      }\n\n      if (!(schema.properties instanceof Object) || !(candidate instanceof Object)) {\n        return;\n      }\n\n      var properties = schema.properties,\n          i;\n\n      if (properties['*'] != null) {\n        for (i in candidate) {\n          if (i in properties) {\n            continue;\n          }\n\n          this._deeperObject(i);\n\n          this._validate(properties['*'], candidate[i]);\n\n          this._back();\n        }\n      }\n\n      for (i in properties) {\n        if (i === '*') {\n          continue;\n        }\n\n        this._deeperObject(i);\n\n        this._validate(properties[i], candidate[i]);\n\n        this._back();\n      }\n    },\n    items: function (schema, candidate, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncItems(schema, candidate, callback);\n      }\n\n      if (!(schema.items instanceof Object) || !(candidate instanceof Object)) {\n        return;\n      }\n\n      var items = schema.items;\n      var i, l; // If provided schema is an array\n      // then call validate for each case\n      // else it is an Object\n      // then call validate for each key\n\n      if (_typeIs.array(items) && _typeIs.array(candidate)) {\n        for (i = 0, l = items.length; i < l; i++) {\n          this._deeperArray(i);\n\n          this._validate(items[i], candidate[i]);\n\n          this._back();\n        }\n      } else {\n        for (var key in candidate) {\n          if (candidate.hasOwnProperty(key)) {\n            this._deeperArray(key);\n\n            this._validate(items, candidate[key]);\n\n            this._back();\n          }\n        }\n      }\n    }\n  };\n  var _asyncValidationAttribut = {\n    asyncExec: function (schema, candidate, callback) {\n      var self = this;\n      async.eachSeries(_typeIs.array(schema.exec) ? schema.exec : [schema.exec], function (exec, done) {\n        if (typeof exec === 'function') {\n          if (exec.length > 2) {\n            return exec.call(self, schema, candidate, done);\n          }\n\n          exec.call(self, schema, candidate);\n        }\n\n        async.nextTick(done);\n      }, callback);\n    },\n    asyncProperties: function (schema, candidate, callback) {\n      if (!(schema.properties instanceof Object) || !_typeIs.object(candidate)) {\n        return callback();\n      }\n\n      var self = this;\n      var properties = schema.properties;\n      async.series([function (next) {\n        if (properties['*'] == null) {\n          return next();\n        }\n\n        async.eachSeries(Object.keys(candidate), function (i, done) {\n          if (i in properties) {\n            return async.nextTick(done);\n          }\n\n          self._deeperObject(i);\n\n          self._asyncValidate(properties['*'], candidate[i], function (err) {\n            self._back();\n\n            done(err);\n          });\n        }, next);\n      }, function (next) {\n        async.eachSeries(Object.keys(properties), function (i, done) {\n          if (i === '*') {\n            return async.nextTick(done);\n          }\n\n          self._deeperObject(i);\n\n          self._asyncValidate(properties[i], candidate[i], function (err) {\n            self._back();\n\n            done(err);\n          });\n        }, next);\n      }], callback);\n    },\n    asyncItems: function (schema, candidate, callback) {\n      if (!(schema.items instanceof Object) || !(candidate instanceof Object)) {\n        return callback();\n      }\n\n      var self = this;\n      var items = schema.items;\n      var i, l;\n\n      if (_typeIs.array(items) && _typeIs.array(candidate)) {\n        async.timesSeries(items.length, function (i, done) {\n          self._deeperArray(i);\n\n          self._asyncValidate(items[i], candidate[i], function (err, res) {\n            self._back();\n\n            done(err, res);\n          });\n\n          self._back();\n        }, callback);\n      } else {\n        async.eachSeries(Object.keys(candidate), function (key, done) {\n          self._deeperArray(key);\n\n          self._asyncValidate(items, candidate[key], function (err, res) {\n            self._back();\n\n            done(err, res);\n          });\n        }, callback);\n      }\n    }\n  }; // Validation Class ----------------------------------------------------------\n  // inherits from Inspection class (actually we just call Inspection\n  // constructor with the new context, because its prototype is empty\n\n  function Validation(schema, custom) {\n    Inspection.prototype.constructor.call(this, schema, _merge(Validation.custom, custom));\n    var _error = [];\n    this._basicFields = Object.keys(_validationAttribut);\n    this._customFields = Object.keys(this._custom);\n    this.origin = null;\n\n    this.report = function (message, code, reason) {\n      var newErr = {\n        code: code || this.userCode || null,\n        reason: reason || 'unknown',\n        message: this.userError || message || 'is invalid',\n        property: this.userAlias ? this.userAlias + ' (' + this._dumpStack() + ')' : this._dumpStack()\n      };\n\n      _error.push(newErr);\n\n      return this;\n    };\n\n    this.result = function () {\n      return {\n        error: _error,\n        valid: _error.length === 0,\n        format: function () {\n          if (this.valid === true) {\n            return 'Candidate is valid';\n          }\n\n          return this.error.map(function (i) {\n            return 'Property ' + i.property + ': ' + i.message;\n          }).join('\\n');\n        }\n      };\n    };\n  }\n\n  _extend(Validation.prototype, _validationAttribut);\n\n  _extend(Validation.prototype, _asyncValidationAttribut);\n\n  _extend(Validation, new Customisable());\n\n  Validation.prototype.validate = function (candidate, callback) {\n    this.origin = candidate;\n\n    if (typeof callback === 'function') {\n      var self = this;\n      return async.nextTick(function () {\n        self._asyncValidate(self._schema, candidate, function (err) {\n          self.origin = null;\n          callback(err, self.result());\n        });\n      });\n    }\n\n    return this._validate(this._schema, candidate).result();\n  };\n\n  Validation.prototype._validate = function (schema, candidate, callback) {\n    this.userCode = schema.code || null;\n    this.userError = schema.error || null;\n    this.userAlias = schema.alias || null;\n\n    this._basicFields.forEach(function (i) {\n      if ((i in schema || i === 'optional') && typeof this[i] === 'function') {\n        this[i](schema, candidate);\n      }\n    }, this);\n\n    this._customFields.forEach(function (i) {\n      if (i in schema && typeof this._custom[i] === 'function') {\n        this._custom[i].call(this, schema, candidate);\n      }\n    }, this);\n\n    return this;\n  };\n\n  Validation.prototype._asyncValidate = function (schema, candidate, callback) {\n    var self = this;\n    this.userCode = schema.code || null;\n    this.userError = schema.error || null;\n    this.userAlias = schema.alias || null;\n    async.series([function (next) {\n      async.eachSeries(Object.keys(_validationAttribut), function (i, done) {\n        async.nextTick(function () {\n          if ((i in schema || i === 'optional') && typeof self[i] === 'function') {\n            if (self[i].length > 2) {\n              return self[i](schema, candidate, done);\n            }\n\n            self[i](schema, candidate);\n          }\n\n          done();\n        });\n      }, next);\n    }, function (next) {\n      async.eachSeries(Object.keys(self._custom), function (i, done) {\n        async.nextTick(function () {\n          if (i in schema && typeof self._custom[i] === 'function') {\n            if (self._custom[i].length > 2) {\n              return self._custom[i].call(self, schema, candidate, done);\n            }\n\n            self._custom[i].call(self, schema, candidate);\n          }\n\n          done();\n        });\n      }, next);\n    }], callback);\n  }; // Sanitization ----------------------------------------------------------------\n  // functions called by _sanitization.type method.\n\n\n  var _forceType = {\n    number: function (post, schema) {\n      var n;\n\n      if (typeof post === 'number') {\n        return post;\n      } else if (post === '') {\n        if (typeof schema.def !== 'undefined') return schema.def;\n        return null;\n      } else if (typeof post === 'string') {\n        n = parseFloat(post.replace(/,/g, '.').replace(/ /g, ''));\n\n        if (typeof n === 'number') {\n          return n;\n        }\n      } else if (post instanceof Date) {\n        return +post;\n      }\n\n      return null;\n    },\n    integer: function (post, schema) {\n      var n;\n\n      if (typeof post === 'number' && post % 1 === 0) {\n        return post;\n      } else if (post === '') {\n        if (typeof schema.def !== 'undefined') return schema.def;\n        return null;\n      } else if (typeof post === 'string') {\n        n = parseInt(post.replace(/ /g, ''), 10);\n\n        if (typeof n === 'number') {\n          return n;\n        }\n      } else if (typeof post === 'number') {\n        return parseInt(post, 10);\n      } else if (typeof post === 'boolean') {\n        if (post) {\n          return 1;\n        }\n\n        return 0;\n      } else if (post instanceof Date) {\n        return +post;\n      }\n\n      return null;\n    },\n    string: function (post, schema) {\n      if (typeof post === 'boolean' || typeof post === 'number' || post instanceof Date) {\n        return post.toString();\n      } else if (_typeIs.array(post)) {\n        // If user authorize array and strings...\n        if (schema.items || schema.properties) return post;\n        return post.join(String(schema.joinWith || ','));\n      } else if (post instanceof Object) {\n        // If user authorize objects ans strings...\n        if (schema.items || schema.properties) return post;\n        return JSON.stringify(post);\n      } else if (typeof post === 'string' && post.length) {\n        return post;\n      }\n\n      return null;\n    },\n    date: function (post, schema) {\n      if (post instanceof Date) {\n        return post;\n      } else {\n        var d = new Date(post);\n\n        if (!isNaN(d.getTime())) {\n          // if valid date\n          return d;\n        }\n      }\n\n      return null;\n    },\n    boolean: function (post, schema) {\n      if (typeof post === 'undefined') return null;\n      if (typeof post === 'string' && post.toLowerCase() === 'false') return false;\n      return !!post;\n    },\n    object: function (post, schema) {\n      if (typeof post !== 'string' || _typeIs.object(post)) {\n        return post;\n      }\n\n      try {\n        return JSON.parse(post);\n      } catch (e) {\n        return null;\n      }\n    },\n    array: function (post, schema) {\n      if (_typeIs.array(post)) return post;\n      if (typeof post === 'undefined') return null;\n\n      if (typeof post === 'string') {\n        if (post.substring(0, 1) === '[' && post.slice(-1) === ']') {\n          try {\n            return JSON.parse(post);\n          } catch (e) {\n            return null;\n          }\n        }\n\n        return post.split(String(schema.splitWith || ','));\n      }\n\n      if (!_typeIs.array(post)) return [post];\n      return null;\n    }\n  };\n  var _applyRules = {\n    upper: function (post) {\n      return post.toUpperCase();\n    },\n    lower: function (post) {\n      return post.toLowerCase();\n    },\n    title: function (post) {\n      // Fix by seb (replace \\w\\S* by \\S* => exemple : coucou Ã§a va)\n      return post.replace(/\\S*/g, function (txt) {\n        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\n      });\n    },\n    capitalize: function (post) {\n      return post.charAt(0).toUpperCase() + post.substr(1).toLowerCase();\n    },\n    ucfirst: function (post) {\n      return post.charAt(0).toUpperCase() + post.substr(1);\n    },\n    trim: function (post) {\n      return post.trim();\n    }\n  }; // Every function return the future value of each property. Therefore you\n  // have to return post even if you do not change its value\n\n  var _sanitizationAttribut = {\n    strict: function (schema, post) {\n      if (typeof schema.strict === 'string') {\n        schema.strict = schema.strict === 'true';\n      }\n\n      if (schema.strict !== true) return post;\n      if (!_typeIs.object(schema.properties)) return post;\n      if (!_typeIs.object(post)) return post;\n      var that = this;\n      Object.keys(post).forEach(function (key) {\n        if (!(key in schema.properties)) {\n          delete post[key];\n        }\n      });\n      return post;\n    },\n    optional: function (schema, post) {\n      var opt = typeof schema.optional === 'boolean' ? schema.optional : schema.optional !== 'false'; // Default: true\n\n      if (opt === true) {\n        return post;\n      }\n\n      if (typeof post !== 'undefined') {\n        return post;\n      }\n\n      this.report();\n\n      if (schema.def === Date) {\n        return new Date();\n      }\n\n      return schema.def;\n    },\n    type: function (schema, post) {\n      // if (_typeIs['object'](post) || _typeIs.array(post)) {\n      // \treturn post;\n      // }\n      if (typeof schema.type !== 'string' || typeof _forceType[schema.type] !== 'function') {\n        return post;\n      }\n\n      var n;\n      var opt = typeof schema.optional === 'boolean' ? schema.optional : true;\n\n      if (typeof _forceType[schema.type] === 'function') {\n        n = _forceType[schema.type](post, schema);\n\n        if (n === null && !opt || !n && isNaN(n) || n === null && schema.type === 'string') {\n          n = schema.def;\n        }\n      } else if (!opt) {\n        n = schema.def;\n      }\n\n      if ((n != null || typeof schema.def !== 'undefined' && schema.def === n) && n !== post) {\n        this.report();\n        return n;\n      }\n\n      return post;\n    },\n    rules: function (schema, post) {\n      var rules = schema.rules;\n\n      if (typeof post !== 'string' || typeof rules !== 'string' && !_typeIs.array(rules)) {\n        return post;\n      }\n\n      var modified = false;\n      (_typeIs.array(rules) ? rules : [rules]).forEach(function (rule) {\n        if (typeof _applyRules[rule] === 'function') {\n          post = _applyRules[rule](post);\n          modified = true;\n        }\n      });\n\n      if (modified) {\n        this.report();\n      }\n\n      return post;\n    },\n    min: function (schema, post) {\n      var postTest = Number(post);\n\n      if (isNaN(postTest)) {\n        return post;\n      }\n\n      var min = Number(schema.min);\n\n      if (isNaN(min)) {\n        return post;\n      }\n\n      if (postTest < min) {\n        this.report();\n        return min;\n      }\n\n      return post;\n    },\n    max: function (schema, post) {\n      var postTest = Number(post);\n\n      if (isNaN(postTest)) {\n        return post;\n      }\n\n      var max = Number(schema.max);\n\n      if (isNaN(max)) {\n        return post;\n      }\n\n      if (postTest > max) {\n        this.report();\n        return max;\n      }\n\n      return post;\n    },\n    minLength: function (schema, post) {\n      var limit = Number(schema.minLength);\n\n      if (typeof post !== 'string' || isNaN(limit) || limit < 0) {\n        return post;\n      }\n\n      var str = '';\n      var gap = limit - post.length;\n\n      if (gap > 0) {\n        for (var i = 0; i < gap; i++) {\n          str += '-';\n        }\n\n        this.report();\n        return post + str;\n      }\n\n      return post;\n    },\n    maxLength: function (schema, post) {\n      var limit = Number(schema.maxLength);\n\n      if (typeof post !== 'string' || isNaN(limit) || limit < 0) {\n        return post;\n      }\n\n      if (post.length > limit) {\n        this.report();\n        return post.slice(0, limit);\n      }\n\n      return post;\n    },\n    properties: function (schema, post, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncProperties(schema, post, callback);\n      }\n\n      if (!post || typeof post !== 'object') {\n        return post;\n      }\n\n      var properties = schema.properties;\n      var tmp;\n      var i;\n\n      if (typeof properties['*'] !== 'undefined') {\n        for (i in post) {\n          if (i in properties) {\n            continue;\n          }\n\n          this._deeperObject(i);\n\n          tmp = this._sanitize(schema.properties['*'], post[i]);\n\n          if (typeof tmp !== 'undefined') {\n            post[i] = tmp;\n          }\n\n          this._back();\n        }\n      }\n\n      for (i in schema.properties) {\n        if (i !== '*') {\n          this._deeperObject(i);\n\n          tmp = this._sanitize(schema.properties[i], post[i]);\n\n          if (typeof tmp !== 'undefined') {\n            post[i] = tmp;\n          }\n\n          this._back();\n        }\n      }\n\n      return post;\n    },\n    items: function (schema, post, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncItems(schema, post, callback);\n      }\n\n      if (!(schema.items instanceof Object) || !(post instanceof Object)) {\n        return post;\n      }\n\n      var i;\n\n      if (_typeIs.array(schema.items) && _typeIs.array(post)) {\n        var minLength = schema.items.length < post.length ? schema.items.length : post.length;\n\n        for (i = 0; i < minLength; i++) {\n          this._deeperArray(i);\n\n          post[i] = this._sanitize(schema.items[i], post[i]);\n\n          this._back();\n        }\n      } else {\n        for (i in post) {\n          if (post.hasOwnProperty(i)) {\n            this._deeperArray(i);\n\n            post[i] = this._sanitize(schema.items, post[i]);\n\n            this._back();\n          }\n        }\n      }\n\n      return post;\n    },\n    exec: function (schema, post, callback) {\n      if (typeof callback === 'function') {\n        return this.asyncExec(schema, post, callback);\n      }\n\n      var execs = _typeIs.array(schema.exec) ? schema.exec : [schema.exec];\n      execs.forEach(function (exec) {\n        if (typeof exec === 'function') {\n          post = exec.call(this, schema, post);\n        }\n      }, this);\n      return post;\n    }\n  };\n  var _asyncSanitizationAttribut = {\n    asyncExec: function (schema, post, callback) {\n      var self = this;\n      var execs = _typeIs.array(schema.exec) ? schema.exec : [schema.exec];\n      async.eachSeries(execs, function (exec, done) {\n        if (typeof exec === 'function') {\n          if (exec.length > 2) {\n            return exec.call(self, schema, post, function (err, res) {\n              if (err) {\n                return done(err);\n              }\n\n              post = res;\n              done();\n            });\n          }\n\n          post = exec.call(self, schema, post);\n        }\n\n        done();\n      }, function (err) {\n        callback(err, post);\n      });\n    },\n    asyncProperties: function (schema, post, callback) {\n      if (!post || typeof post !== 'object') {\n        return callback(null, post);\n      }\n\n      var self = this;\n      var properties = schema.properties;\n      async.series([function (next) {\n        if (properties['*'] == null) {\n          return next();\n        }\n\n        var globing = properties['*'];\n        async.eachSeries(Object.keys(post), function (i, next) {\n          if (i in properties) {\n            return next();\n          }\n\n          self._deeperObject(i);\n\n          self._asyncSanitize(globing, post[i], function (err, res) {\n            if (err) {\n              /* Error can safely be ignored here */\n            }\n\n            if (typeof res !== 'undefined') {\n              post[i] = res;\n            }\n\n            self._back();\n\n            next();\n          });\n        }, next);\n      }, function (next) {\n        async.eachSeries(Object.keys(properties), function (i, next) {\n          if (i === '*') {\n            return next();\n          }\n\n          self._deeperObject(i);\n\n          self._asyncSanitize(properties[i], post[i], function (err, res) {\n            if (err) {\n              return next(err);\n            }\n\n            if (typeof res !== 'undefined') {\n              post[i] = res;\n            }\n\n            self._back();\n\n            next();\n          });\n        }, next);\n      }], function (err) {\n        return callback(err, post);\n      });\n    },\n    asyncItems: function (schema, post, callback) {\n      if (!(schema.items instanceof Object) || !(post instanceof Object)) {\n        return callback(null, post);\n      }\n\n      var self = this;\n      var items = schema.items;\n\n      if (_typeIs.array(items) && _typeIs.array(post)) {\n        var minLength = items.length < post.length ? items.length : post.length;\n        async.timesSeries(minLength, function (i, next) {\n          self._deeperArray(i);\n\n          self._asyncSanitize(items[i], post[i], function (err, res) {\n            if (err) {\n              return next(err);\n            }\n\n            post[i] = res;\n\n            self._back();\n\n            next();\n          });\n        }, function (err) {\n          callback(err, post);\n        });\n      } else {\n        async.eachSeries(Object.keys(post), function (key, next) {\n          self._deeperArray(key);\n\n          self._asyncSanitize(items, post[key], function (err, res) {\n            if (err) {\n              return next();\n            }\n\n            post[key] = res;\n\n            self._back();\n\n            next();\n          });\n        }, function (err) {\n          callback(err, post);\n        });\n      }\n\n      return post;\n    }\n  }; // Sanitization Class --------------------------------------------------------\n  // inherits from Inspection class (actually we just call Inspection\n  // constructor with the new context, because its prototype is empty\n\n  function Sanitization(schema, custom) {\n    Inspection.prototype.constructor.call(this, schema, _merge(Sanitization.custom, custom));\n    var _reporting = [];\n    this._basicFields = Object.keys(_sanitizationAttribut);\n    this._customFields = Object.keys(this._custom);\n    this.origin = null;\n\n    this.report = function (message) {\n      var newNot = {\n        message: message || 'was sanitized',\n        property: this.userAlias ? this.userAlias + ' (' + this._dumpStack() + ')' : this._dumpStack()\n      };\n\n      if (!_reporting.some(function (e) {\n        return e.property === newNot.property;\n      })) {\n        _reporting.push(newNot);\n      }\n    };\n\n    this.result = function (data) {\n      return {\n        data: data,\n        reporting: _reporting,\n        format: function () {\n          return this.reporting.map(function (i) {\n            return 'Property ' + i.property + ' ' + i.message;\n          }).join('\\n');\n        }\n      };\n    };\n  }\n\n  _extend(Sanitization.prototype, _sanitizationAttribut);\n\n  _extend(Sanitization.prototype, _asyncSanitizationAttribut);\n\n  _extend(Sanitization, new Customisable());\n\n  Sanitization.prototype.sanitize = function (post, callback) {\n    this.origin = post;\n\n    if (typeof callback === 'function') {\n      var self = this;\n      return this._asyncSanitize(this._schema, post, function (err, data) {\n        self.origin = null;\n        callback(err, self.result(data));\n      });\n    }\n\n    var data = this._sanitize(this._schema, post);\n\n    this.origin = null;\n    return this.result(data);\n  };\n\n  Sanitization.prototype._sanitize = function (schema, post) {\n    this.userAlias = schema.alias || null;\n\n    this._basicFields.forEach(function (i) {\n      if ((i in schema || i === 'optional') && typeof this[i] === 'function') {\n        post = this[i](schema, post);\n      }\n    }, this);\n\n    this._customFields.forEach(function (i) {\n      if (i in schema && typeof this._custom[i] === 'function') {\n        post = this._custom[i].call(this, schema, post);\n      }\n    }, this);\n\n    return post;\n  };\n\n  Sanitization.prototype._asyncSanitize = function (schema, post, callback) {\n    var self = this;\n    this.userAlias = schema.alias || null;\n    async.waterfall([function (next) {\n      async.reduce(self._basicFields, post, function (value, i, next) {\n        async.nextTick(function () {\n          if ((i in schema || i === 'optional') && typeof self[i] === 'function') {\n            if (self[i].length > 2) {\n              return self[i](schema, value, next);\n            }\n\n            value = self[i](schema, value);\n          }\n\n          next(null, value);\n        });\n      }, next);\n    }, function (inter, next) {\n      async.reduce(self._customFields, inter, function (value, i, next) {\n        async.nextTick(function () {\n          if (i in schema && typeof self._custom[i] === 'function') {\n            if (self._custom[i].length > 2) {\n              return self._custom[i].call(self, schema, value, next);\n            }\n\n            value = self._custom[i].call(self, schema, value);\n          }\n\n          next(null, value);\n        });\n      }, next);\n    }], callback);\n  }; // ---------------------------------------------------------------------------\n\n\n  var INT_MIN = -2147483648;\n  var INT_MAX = 2147483647;\n  var _rand = {\n    int: function (min, max) {\n      return min + (0 | Math.random() * (max - min + 1));\n    },\n    float: function (min, max) {\n      return Math.random() * (max - min) + min;\n    },\n    bool: function () {\n      return Math.random() > 0.5;\n    },\n    char: function (min, max) {\n      return String.fromCharCode(this.int(min, max));\n    },\n    fromList: function (list) {\n      return list[this.int(0, list.length - 1)];\n    }\n  };\n  var _formatSample = {\n    'date-time': function () {\n      return new Date().toISOString();\n    },\n    'date': function () {\n      return new Date().toISOString().replace(/T.*$/, '');\n    },\n    'time': function () {\n      return new Date().toLocaleTimeString({}, {\n        hour12: false\n      });\n    },\n    'color': function (min, max) {\n      var s = '#';\n\n      if (min < 1) {\n        min = 1;\n      }\n\n      for (var i = 0, l = _rand.int(min, max); i < l; i++) {\n        s += _rand.fromList('0123456789abcdefABCDEF');\n      }\n\n      return s;\n    },\n    'numeric': function () {\n      return '' + _rand.int(0, INT_MAX);\n    },\n    'integer': function () {\n      if (_rand.bool() === true) {\n        return '-' + this.numeric();\n      }\n\n      return this.numeric();\n    },\n    'decimal': function () {\n      return this.integer() + '.' + this.numeric();\n    },\n    'alpha': function (min, max) {\n      var s = '';\n\n      if (min < 1) {\n        min = 1;\n      }\n\n      for (var i = 0, l = _rand.int(min, max); i < l; i++) {\n        s += _rand.fromList('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ');\n      }\n\n      return s;\n    },\n    'alphaNumeric': function (min, max) {\n      var s = '';\n\n      if (min < 1) {\n        min = 1;\n      }\n\n      for (var i = 0, l = _rand.int(min, max); i < l; i++) {\n        s += _rand.fromList('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789');\n      }\n\n      return s;\n    },\n    'alphaDash': function (min, max) {\n      var s = '';\n\n      if (min < 1) {\n        min = 1;\n      }\n\n      for (var i = 0, l = _rand.int(min, max); i < l; i++) {\n        s += _rand.fromList('_-abcdefghijklmnopqrstuvwxyz_-ABCDEFGHIJKLMNOPQRSTUVWXYZ_-0123456789_-');\n      }\n\n      return s;\n    },\n    'javascript': function (min, max) {\n      var s = _rand.fromList('_$abcdefghijklmnopqrstuvwxyz_$ABCDEFGHIJKLMNOPQRSTUVWXYZ_$');\n\n      for (var i = 0, l = _rand.int(min, max - 1); i < l; i++) {\n        s += _rand.fromList('_$abcdefghijklmnopqrstuvwxyz_$ABCDEFGHIJKLMNOPQRSTUVWXYZ_$0123456789_$');\n      }\n\n      return s;\n    }\n  };\n\n  function _getLimits(schema) {\n    var min = INT_MIN;\n    var max = INT_MAX;\n\n    if (schema.gte != null) {\n      min = schema.gte;\n    } else if (schema.gt != null) {\n      min = schema.gt + 1;\n    }\n\n    if (schema.lte != null) {\n      max = schema.lte;\n    } else if (schema.lt != null) {\n      max = schema.lt - 1;\n    }\n\n    return {\n      min: min,\n      max: max\n    };\n  }\n\n  var _typeGenerator = {\n    string: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n\n      var s = '';\n      var minLength = schema.minLength != null ? schema.minLength : 0;\n      var maxLength = schema.maxLength != null ? schema.maxLength : 32;\n\n      if (typeof schema.pattern === 'string' && typeof _formatSample[schema.pattern] === 'function') {\n        return _formatSample[schema.pattern](minLength, maxLength);\n      }\n\n      var l = schema.exactLength != null ? schema.exactLength : _rand.int(minLength, maxLength);\n\n      for (var i = 0; i < l; i++) {\n        s += _rand.char(32, 126);\n      }\n\n      return s;\n    },\n    number: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n\n      var limit = _getLimits(schema);\n\n      var n = _rand.float(limit.min, limit.max);\n\n      if (schema.ne != null) {\n        var ne = _typeIs.array(schema.ne) ? schema.ne : [schema.ne];\n\n        while (ne.indexOf(n) !== -1) {\n          n = _rand.float(limit.min, limit.max);\n        }\n      }\n\n      return n;\n    },\n    integer: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n\n      var limit = _getLimits(schema);\n\n      var n = _rand.int(limit.min, limit.max);\n\n      if (schema.ne != null) {\n        var ne = _typeIs.array(schema.ne) ? schema.ne : [schema.ne];\n\n        while (ne.indexOf(n) !== -1) {\n          n = _rand.int(limit.min, limit.max);\n        }\n      }\n\n      return n;\n    },\n    boolean: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n\n      return _rand.bool();\n    },\n    \"null\": function (schema) {\n      return null;\n    },\n    date: function (schema) {\n      if (schema.eq != null) {\n        return schema.eq;\n      }\n\n      return new Date();\n    },\n    object: function (schema) {\n      var o = {};\n      var prop = schema.properties || {};\n\n      for (var key in prop) {\n        if (prop.hasOwnProperty(key)) {\n          if (prop[key].optional === true && _rand.bool() === true) {\n            continue;\n          }\n\n          if (key !== '*') {\n            o[key] = this.generate(prop[key]);\n          } else {\n            var rk = '__random_key_';\n            var randomKey = rk + 0;\n\n            var n = _rand.int(1, 9);\n\n            for (var i = 1; i <= n; i++) {\n              if (!(randomKey in prop)) {\n                o[randomKey] = this.generate(prop[key]);\n              }\n\n              randomKey = rk + i;\n            }\n          }\n        }\n      }\n\n      return o;\n    },\n    array: function (schema) {\n      var self = this;\n      var items = schema.items || {};\n      var minLength = schema.minLength != null ? schema.minLength : 0;\n      var maxLength = schema.maxLength != null ? schema.maxLength : 16;\n      var type;\n      var candidate;\n      var size;\n      var i;\n\n      if (_typeIs.array(items)) {\n        size = items.length;\n\n        if (schema.exactLength != null) {\n          size = schema.exactLength;\n        } else if (size < minLength) {\n          size = minLength;\n        } else if (size > maxLength) {\n          size = maxLength;\n        }\n\n        candidate = new Array(size);\n        type = null;\n\n        for (i = 0; i < size; i++) {\n          type = items[i].type || 'any';\n\n          if (_typeIs.array(type)) {\n            type = type[_rand.int(0, type.length - 1)];\n          }\n\n          candidate[i] = self[type](items[i]);\n        }\n      } else {\n        size = schema.exactLength != null ? schema.exactLength : _rand.int(minLength, maxLength);\n        candidate = new Array(size);\n        type = items.type || 'any';\n\n        if (_typeIs.array(type)) {\n          type = type[_rand.int(0, type.length - 1)];\n        }\n\n        for (i = 0; i < size; i++) {\n          candidate[i] = self[type](items);\n        }\n      }\n\n      return candidate;\n    },\n    any: function (schema) {\n      var fields = Object.keys(_typeGenerator);\n\n      var i = fields[_rand.int(0, fields.length - 2)];\n\n      return this[i](schema);\n    }\n  }; // CandidateGenerator Class (Singleton) --------------------------------------\n\n  function CandidateGenerator() {// Maybe extends Inspection class too ?\n  }\n\n  _extend(CandidateGenerator.prototype, _typeGenerator);\n\n  var _instance = null;\n\n  CandidateGenerator.instance = function () {\n    if (!(_instance instanceof CandidateGenerator)) {\n      _instance = new CandidateGenerator();\n    }\n\n    return _instance;\n  };\n\n  CandidateGenerator.prototype.generate = function (schema) {\n    var type = schema.type || 'any';\n\n    if (_typeIs.array(type)) {\n      type = type[_rand.int(0, type.length - 1)];\n    }\n\n    return this[type](schema);\n  }; // Exports ---------------------------------------------------------------------\n\n\n  var SchemaInspector = {}; // if server-side (node.js) else client-side\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = SchemaInspector;\n  } else {\n    window.SchemaInspector = SchemaInspector;\n  }\n\n  SchemaInspector.newSanitization = function (schema, custom) {\n    return new Sanitization(schema, custom);\n  };\n\n  SchemaInspector.newValidation = function (schema, custom) {\n    return new Validation(schema, custom);\n  };\n\n  SchemaInspector.Validation = Validation;\n  SchemaInspector.Sanitization = Sanitization;\n\n  SchemaInspector.sanitize = function (schema, post, custom, callback) {\n    if (arguments.length === 3 && typeof custom === 'function') {\n      callback = custom;\n      custom = null;\n    }\n\n    return new Sanitization(schema, custom).sanitize(post, callback);\n  };\n\n  SchemaInspector.validate = function (schema, candidate, custom, callback) {\n    if (arguments.length === 3 && typeof custom === 'function') {\n      callback = custom;\n      custom = null;\n    }\n\n    return new Validation(schema, custom).validate(candidate, callback);\n  };\n\n  SchemaInspector.generate = function (schema, n) {\n    if (typeof n === 'number') {\n      var r = new Array(n);\n\n      for (var i = 0; i < n; i++) {\n        r[i] = CandidateGenerator.instance().generate(schema);\n      }\n\n      return r;\n    }\n\n    return CandidateGenerator.instance().generate(schema);\n  };\n})();","map":null,"metadata":{},"sourceType":"script"}