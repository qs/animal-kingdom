{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst convert = require('../converter');\n\nconst tools_1 = require('../converter/tools');\n\nconst varuint = require('../converter/varint');\n\nconst typeFields_1 = require('../typeFields');\n\nfunction psbtFromBuffer(buffer, txGetter) {\n  let offset = 0;\n\n  function varSlice() {\n    const keyLen = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(keyLen);\n    const key = buffer.slice(offset, offset + keyLen);\n    offset += keyLen;\n    return key;\n  }\n\n  function readUInt32BE() {\n    const num = buffer.readUInt32BE(offset);\n    offset += 4;\n    return num;\n  }\n\n  function readUInt8() {\n    const num = buffer.readUInt8(offset);\n    offset += 1;\n    return num;\n  }\n\n  function getKeyValue() {\n    const key = varSlice();\n    const value = varSlice();\n    return {\n      key,\n      value\n    };\n  }\n\n  function checkEndOfKeyValPairs() {\n    if (offset >= buffer.length) {\n      throw new Error('Format Error: Unexpected End of PSBT');\n    }\n\n    const isEnd = buffer.readUInt8(offset) === 0;\n\n    if (isEnd) {\n      offset++;\n    }\n\n    return isEnd;\n  }\n\n  if (readUInt32BE() !== 0x70736274) {\n    throw new Error('Format Error: Invalid Magic Number');\n  }\n\n  if (readUInt8() !== 0xff) {\n    throw new Error('Format Error: Magic Number must be followed by 0xff separator');\n  }\n\n  const globalMapKeyVals = [];\n  const globalKeyIndex = {};\n\n  while (!checkEndOfKeyValPairs()) {\n    const keyVal = getKeyValue();\n    const hexKey = keyVal.key.toString('hex');\n\n    if (globalKeyIndex[hexKey]) {\n      throw new Error('Format Error: Keys must be unique for global keymap: key ' + hexKey);\n    }\n\n    globalKeyIndex[hexKey] = 1;\n    globalMapKeyVals.push(keyVal);\n  }\n\n  const unsignedTxMaps = globalMapKeyVals.filter(keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX);\n\n  if (unsignedTxMaps.length !== 1) {\n    throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n  }\n\n  const unsignedTx = txGetter(unsignedTxMaps[0].value); // Get input and output counts to loop the respective fields\n\n  const _unsignedTx$getInputO = unsignedTx.getInputOutputCounts(),\n        inputCount = _unsignedTx$getInputO.inputCount,\n        outputCount = _unsignedTx$getInputO.outputCount;\n\n  const inputKeyVals = [];\n  const outputKeyVals = []; // Get input fields\n\n  for (const index of tools_1.range(inputCount)) {\n    const inputKeyIndex = {};\n    const input = [];\n\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n\n      if (inputKeyIndex[hexKey]) {\n        throw new Error('Format Error: Keys must be unique for each input: ' + 'input index ' + index + ' key ' + hexKey);\n      }\n\n      inputKeyIndex[hexKey] = 1;\n      input.push(keyVal);\n    }\n\n    inputKeyVals.push(input);\n  }\n\n  for (const index of tools_1.range(outputCount)) {\n    const outputKeyIndex = {};\n    const output = [];\n\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n\n      if (outputKeyIndex[hexKey]) {\n        throw new Error('Format Error: Keys must be unique for each output: ' + 'output index ' + index + ' key ' + hexKey);\n      }\n\n      outputKeyIndex[hexKey] = 1;\n      output.push(keyVal);\n    }\n\n    outputKeyVals.push(output);\n  }\n\n  return psbtFromKeyVals(unsignedTx, {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals\n  });\n}\n\nexports.psbtFromBuffer = psbtFromBuffer;\n\nfunction checkKeyBuffer(type, keyBuf, keyNum) {\n  if (!keyBuf.equals(Buffer.from([keyNum]))) {\n    throw new Error(\"Format Error: Invalid \".concat(type, \" key: \").concat(keyBuf.toString('hex')));\n  }\n}\n\nexports.checkKeyBuffer = checkKeyBuffer;\n\nfunction psbtFromKeyVals(unsignedTx, {\n  globalMapKeyVals,\n  inputKeyVals,\n  outputKeyVals\n}) {\n  // That was easy :-)\n  const globalMap = {\n    unsignedTx\n  };\n  let txCount = 0;\n\n  for (const keyVal of globalMapKeyVals) {\n    // If a globalMap item needs pubkey, uncomment\n    // const pubkey = convert.globals.checkPubkey(keyVal);\n    switch (keyVal.key[0]) {\n      case typeFields_1.GlobalTypes.UNSIGNED_TX:\n        checkKeyBuffer('global', keyVal.key, typeFields_1.GlobalTypes.UNSIGNED_TX);\n\n        if (txCount > 0) {\n          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n        }\n\n        txCount++;\n        break;\n\n      case typeFields_1.GlobalTypes.GLOBAL_XPUB:\n        if (globalMap.globalXpub === undefined) {\n          globalMap.globalXpub = [];\n        }\n\n        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n        break;\n\n      default:\n        // This will allow inclusion during serialization.\n        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];\n        globalMap.unknownKeyVals.push(keyVal);\n    }\n  } // Get input and output counts to loop the respective fields\n\n\n  const inputCount = inputKeyVals.length;\n  const outputCount = outputKeyVals.length;\n  const inputs = [];\n  const outputs = []; // Get input fields\n\n  for (const index of tools_1.range(inputCount)) {\n    const input = {};\n\n    for (const keyVal of inputKeyVals[index]) {\n      convert.inputs.checkPubkey(keyVal);\n\n      switch (keyVal.key[0]) {\n        case typeFields_1.InputTypes.NON_WITNESS_UTXO:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.NON_WITNESS_UTXO);\n\n          if (input.nonWitnessUtxo !== undefined || input.witnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple [NON_]WITNESS_UTXO');\n          }\n\n          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.WITNESS_UTXO:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.WITNESS_UTXO);\n\n          if (input.nonWitnessUtxo !== undefined || input.witnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple [NON_]WITNESS_UTXO');\n          }\n\n          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.PARTIAL_SIG:\n          if (input.partialSig === undefined) {\n            input.partialSig = [];\n          }\n\n          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));\n          break;\n\n        case typeFields_1.InputTypes.SIGHASH_TYPE:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.SIGHASH_TYPE);\n\n          if (input.sighashType !== undefined) {\n            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n          }\n\n          input.sighashType = convert.inputs.sighashType.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.REDEEM_SCRIPT);\n\n          if (input.redeemScript !== undefined) {\n            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n          }\n\n          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.WITNESS_SCRIPT);\n\n          if (input.witnessScript !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n          }\n\n          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.BIP32_DERIVATION:\n          if (input.bip32Derivation === undefined) {\n            input.bip32Derivation = [];\n          }\n\n          input.bip32Derivation.push(convert.inputs.bip32Derivation.decode(keyVal));\n          break;\n\n        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.FINAL_SCRIPTSIG);\n          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.FINAL_SCRIPTWITNESS);\n          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(keyVal);\n          break;\n\n        case typeFields_1.InputTypes.POR_COMMITMENT:\n          checkKeyBuffer('input', keyVal.key, typeFields_1.InputTypes.POR_COMMITMENT);\n          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);\n          break;\n\n        default:\n          // This will allow inclusion during serialization.\n          if (!input.unknownKeyVals) input.unknownKeyVals = [];\n          input.unknownKeyVals.push(keyVal);\n      }\n    }\n\n    inputs.push(input);\n  }\n\n  for (const index of tools_1.range(outputCount)) {\n    const output = {};\n\n    for (const keyVal of outputKeyVals[index]) {\n      convert.outputs.checkPubkey(keyVal);\n\n      switch (keyVal.key[0]) {\n        case typeFields_1.OutputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer('output', keyVal.key, typeFields_1.OutputTypes.REDEEM_SCRIPT);\n\n          if (output.redeemScript !== undefined) {\n            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n          }\n\n          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);\n          break;\n\n        case typeFields_1.OutputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer('output', keyVal.key, typeFields_1.OutputTypes.WITNESS_SCRIPT);\n\n          if (output.witnessScript !== undefined) {\n            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n          }\n\n          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);\n          break;\n\n        case typeFields_1.OutputTypes.BIP32_DERIVATION:\n          if (output.bip32Derivation === undefined) {\n            output.bip32Derivation = [];\n          }\n\n          output.bip32Derivation.push(convert.outputs.bip32Derivation.decode(keyVal));\n          break;\n\n        default:\n          if (!output.unknownKeyVals) output.unknownKeyVals = [];\n          output.unknownKeyVals.push(keyVal);\n      }\n    }\n\n    outputs.push(output);\n  }\n\n  return {\n    globalMap,\n    inputs,\n    outputs\n  };\n}\n\nexports.psbtFromKeyVals = psbtFromKeyVals;","map":null,"metadata":{},"sourceType":"script"}