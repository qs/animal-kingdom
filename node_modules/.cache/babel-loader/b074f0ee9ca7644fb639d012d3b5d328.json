{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\"); // @ts-ignore\n\n\nconst BN = require(\"bn.js\");\n\nconst utils_1 = require(\"./utils\");\n\nconst config_1 = require(\"../config\"); // todo : add name length / character verification\n\n/**\n* @ignore\n*/\n\n\nclass BlockstackNamespace {\n  constructor(namespaceID) {\n    if (namespaceID.length > 19) {\n      throw new Error('Namespace ID too long (19 chars max)');\n    }\n\n    if (!namespaceID.match('[0123456789abcdefghijklmnopqrstuvwxyz_-]+')) {\n      throw new Error('Namespace ID can only use characters 0123456789abcdefghijklmnopqrstuvwxyz-_');\n    }\n\n    this.namespaceID = namespaceID;\n    this.version = -1;\n    this.lifetime = -1;\n    this.coeff = -1;\n    this.base = -1;\n    this.buckets = [-1];\n    this.nonalphaDiscount = -1;\n    this.noVowelDiscount = -1;\n  }\n\n  check() {\n    try {\n      this.setVersion(this.version);\n      this.setLifetime(this.lifetime);\n      this.setCoeff(this.coeff);\n      this.setBase(this.base);\n      this.setBuckets(this.buckets);\n      this.setNonalphaDiscount(this.nonalphaDiscount);\n      this.setNoVowelDiscount(this.noVowelDiscount);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  setVersion(version) {\n    if (version < 0 || version > Math.pow(2, 16) - 1) {\n      throw new Error('Invalid version: must be a 16-bit number');\n    }\n\n    this.version = version;\n  }\n\n  setLifetime(lifetime) {\n    if (lifetime < 0 || lifetime > Math.pow(2, 32) - 1) {\n      throw new Error('Invalid lifetime: must be a 32-bit number');\n    }\n\n    this.lifetime = lifetime;\n  }\n\n  setCoeff(coeff) {\n    if (coeff < 0 || coeff > 255) {\n      throw new Error('Invalid coeff: must be an 8-bit number');\n    }\n\n    this.coeff = coeff;\n  }\n\n  setBase(base) {\n    if (base < 0 || base > 255) {\n      throw new Error('Invalid base: must be an 8-bit number');\n    }\n\n    this.base = base;\n  }\n\n  setBuckets(buckets) {\n    if (buckets.length !== 16) {\n      throw new Error('Invalid buckets: must have 16 entries');\n    }\n\n    for (let i = 0; i < buckets.length; i++) {\n      if (buckets[i] < 0 || buckets[i] > 15) {\n        throw new Error('Invalid buckets: must be 4-bit numbers');\n      }\n    }\n\n    this.buckets = buckets.slice(0);\n  }\n\n  setNonalphaDiscount(nonalphaDiscount) {\n    if (nonalphaDiscount <= 0 || nonalphaDiscount > 15) {\n      throw new Error('Invalid nonalphaDiscount: must be a positive 4-bit number');\n    }\n\n    this.nonalphaDiscount = nonalphaDiscount;\n  }\n\n  setNoVowelDiscount(noVowelDiscount) {\n    if (noVowelDiscount <= 0 || noVowelDiscount > 15) {\n      throw new Error('Invalid noVowelDiscount: must be a positive 4-bit number');\n    }\n\n    this.noVowelDiscount = noVowelDiscount;\n  }\n\n  toHexPayload() {\n    const lifeHex = \"00000000\".concat(this.lifetime.toString(16)).slice(-8);\n    const coeffHex = \"00\".concat(this.coeff.toString(16)).slice(-2);\n    const baseHex = \"00\".concat(this.base.toString(16)).slice(-2);\n    const bucketHex = this.buckets.map(b => b.toString(16)).reduce((b1, b2) => b1 + b2, '');\n    const discountHex = this.nonalphaDiscount.toString(16) + this.noVowelDiscount.toString(16);\n    const versionHex = \"0000\".concat(this.version.toString(16)).slice(-4);\n    const namespaceIDHex = Buffer.from(this.namespaceID).toString('hex');\n    return lifeHex + coeffHex + baseHex + bucketHex + discountHex + versionHex + namespaceIDHex;\n  }\n\n}\n\nexports.BlockstackNamespace = BlockstackNamespace;\n/**\n* @ignore\n*/\n\nfunction asAmountV2(amount) {\n  // convert an AmountType v1 or v2 to an AmountTypeV2.\n  // the \"units\" of a v1 amount type are always 'BTC'\n  if (typeof amount === 'number') {\n    return {\n      units: 'BTC',\n      amount: new BN(String(amount))\n    };\n  } else {\n    return {\n      units: amount.units,\n      amount: amount.amount\n    };\n  }\n}\n/**\n* @ignore\n*/\n\n\nfunction makeTXbuilder() {\n  const txb = new bitcoinjs_lib_1.TransactionBuilder(config_1.config.network.layer1);\n  txb.setVersion(1);\n  return txb;\n}\n/**\n* @ignore\n*/\n\n\nfunction opEncode(opcode) {\n  // NOTE: must *always* a 3-character string\n  const res = \"\".concat(config_1.config.network.MAGIC_BYTES).concat(opcode);\n\n  if (res.length !== 3) {\n    throw new Error('Runtime error: invalid MAGIC_BYTES');\n  }\n\n  return res;\n}\n/**\n* @ignore\n*/\n\n\nfunction makePreorderSkeleton(fullyQualifiedName, consensusHash, preorderAddress, burnAddress, burn, registerAddress = null) {\n  // Returns a preorder tx skeleton.\n  //   with 3 outputs : 1. the Blockstack Preorder OP_RETURN data\n  //                    2. the Preorder's change address (5500 satoshi minimum)\n  //                    3. the BURN\n  //\n  // 0     2  3                                     23             39          47            66\n  // |-----|--|--------------------------------------|--------------|-----------|-------------|\n  // magic op  hash160(fqn,scriptPubkey,registerAddr) consensus hash token burn  token type\n  //                                                                 (optional)   (optional)\n  //\n  // output 0: name preorder code\n  // output 1: preorder address\n  // output 2: burn address\n  //\n  // Returns an unsigned serialized transaction.\n  const burnAmount = asAmountV2(burn);\n  const network = config_1.config.network;\n  const nameBuff = Buffer.from(utils_1.decodeB40(fullyQualifiedName), 'hex'); // base40\n\n  const scriptPublicKey = bitcoinjs_lib_1.address.toOutputScript(preorderAddress, network.layer1);\n  const dataBuffers = [nameBuff, scriptPublicKey];\n\n  if (!!registerAddress) {\n    const registerBuff = Buffer.from(registerAddress, 'ascii');\n    dataBuffers.push(registerBuff);\n  }\n\n  const dataBuff = Buffer.concat(dataBuffers);\n  const hashed = utils_1.hash160(dataBuff);\n  const opReturnBufferLen = burnAmount.units === 'BTC' ? 39 : 66;\n  const opReturnBuffer = Buffer.alloc(opReturnBufferLen);\n  opReturnBuffer.write(opEncode('?'), 0, 3, 'ascii');\n  hashed.copy(opReturnBuffer, 3);\n  opReturnBuffer.write(consensusHash, 23, 16, 'hex');\n\n  if (burnAmount.units !== 'BTC') {\n    const burnHex = burnAmount.amount.toString(16, 2);\n\n    if (burnHex.length > 16) {\n      // exceeds 2**64; can't fit\n      throw new Error(\"Cannot preorder '\".concat(fullyQualifiedName, \"': cannot fit price into 8 bytes\"));\n    }\n\n    const paddedBurnHex = \"0000000000000000\".concat(burnHex).slice(-16);\n    opReturnBuffer.write(paddedBurnHex, 39, 8, 'hex');\n    opReturnBuffer.write(burnAmount.units, 47, burnAmount.units.length, 'ascii');\n  }\n\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(preorderAddress, utils_1.DUST_MINIMUM);\n\n  if (burnAmount.units === 'BTC') {\n    const btcBurnAmount = burnAmount.amount.toNumber();\n    tx.addOutput(burnAddress, btcBurnAmount);\n  } else {\n    tx.addOutput(burnAddress, utils_1.DUST_MINIMUM);\n  }\n\n  return tx.buildIncomplete();\n}\n\nexports.makePreorderSkeleton = makePreorderSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeRegisterSkeleton(fullyQualifiedName, ownerAddress, valueHash = null, burnTokenAmountHex = null) {\n  // Returns a register tx skeleton.\n  //   with 2 outputs : 1. The register OP_RETURN\n  //                    2. The owner address (can be different from REGISTER address on renewals)\n  // You MUST make the first input a UTXO from the current OWNER *or* the\n  //   funder of the PREORDER\n  // in the case of a renewal, this would need to be modified to include a change address\n  //  as output (3) before the burn output (4)\n\n  /*\n    Formats\n       No zonefile hash, and pay with BTC:\n       0    2  3                                  39\n    |----|--|----------------------------------|\n    magic op   name.ns_id (up to 37 bytes)\n   \n    With zonefile hash, and pay with BTC:\n       0    2  3                                  39                  59\n    |----|--|----------------------------------|-------------------|\n    magic op   name.ns_id (37 bytes, 0-padded)     zone file hash\n       output 0: name registration code\n    output 1: owner address\n  */\n  let payload;\n\n  if (!!burnTokenAmountHex && !valueHash) {\n    // empty value hash\n    valueHash = '0000000000000000000000000000000000000000';\n  }\n\n  if (!!valueHash) {\n    if (valueHash.length !== 40) {\n      throw new Error('Value hash length incorrect. Expecting 20-bytes, hex-encoded');\n    }\n\n    if (!!burnTokenAmountHex) {\n      if (burnTokenAmountHex.length !== 16) {\n        throw new Error('Burn field length incorrect.  Expecting 8-bytes, hex-encoded');\n      }\n    }\n\n    const payloadLen = burnTokenAmountHex ? 65 : 57;\n    payload = Buffer.alloc(payloadLen, 0);\n    payload.write(fullyQualifiedName, 0, 37, 'ascii');\n    payload.write(valueHash, 37, 20, 'hex');\n\n    if (!!burnTokenAmountHex) {\n      payload.write(burnTokenAmountHex, 57, 8, 'hex');\n    }\n  } else {\n    payload = Buffer.from(fullyQualifiedName, 'ascii');\n  }\n\n  const opReturnBuffer = Buffer.concat([Buffer.from(opEncode(':'), 'ascii'), payload]);\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(ownerAddress, utils_1.DUST_MINIMUM);\n  return tx.buildIncomplete();\n}\n\nexports.makeRegisterSkeleton = makeRegisterSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeRenewalSkeleton(fullyQualifiedName, nextOwnerAddress, lastOwnerAddress, burnAddress, burn, valueHash = null) {\n  /*\n    Formats\n       No zonefile hash, and pay with BTC:\n       0    2  3                                  39\n    |----|--|----------------------------------|\n    magic op   name.ns_id (up to 37 bytes)\n   \n    With zonefile hash, and pay with BTC:\n       0    2  3                                  39                  59\n    |----|--|----------------------------------|-------------------|\n    magic op   name.ns_id (37 bytes, 0-padded)     zone file hash\n   \n   With renewal payment in a token:\n   (for register, tokens burned is not included)\n   (for renew, tokens burned is the number of tokens to burn)\n      0    2  3                                  39                  59                            67\n   |----|--|----------------------------------|-------------------|------------------------------|\n   magic op   name.ns_id (37 bytes, 0-padded)     zone file hash    tokens burned (big-endian)\n      output 0: renewal code\n   output 1: new owner address\n   output 2: current owner address\n   output 3: burn address\n  */\n  const burnAmount = asAmountV2(burn);\n  const network = config_1.config.network;\n  const burnTokenAmount = burnAmount.units === 'BTC' ? null : burnAmount.amount;\n  const burnBTCAmount = burnAmount.units === 'BTC' ? burnAmount.amount.toNumber() : utils_1.DUST_MINIMUM;\n  let burnTokenHex = null;\n\n  if (!!burnTokenAmount) {\n    const burnHex = burnTokenAmount.toString(16, 2);\n\n    if (burnHex.length > 16) {\n      // exceeds 2**64; can't fit \n      throw new Error(\"Cannot renew '\".concat(fullyQualifiedName, \"': cannot fit price into 8 bytes\"));\n    }\n\n    burnTokenHex = \"0000000000000000\".concat(burnHex).slice(-16);\n  }\n\n  const registerTX = makeRegisterSkeleton(fullyQualifiedName, nextOwnerAddress, valueHash, burnTokenHex);\n  const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(registerTX, network.layer1);\n  txB.addOutput(lastOwnerAddress, utils_1.DUST_MINIMUM);\n  txB.addOutput(burnAddress, burnBTCAmount);\n  return txB.buildIncomplete();\n}\n\nexports.makeRenewalSkeleton = makeRenewalSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeTransferSkeleton(fullyQualifiedName, consensusHash, newOwner, keepZonefile = false) {\n  // Returns a transfer tx skeleton.\n  //   with 2 outputs : 1. the Blockstack Transfer OP_RETURN data\n  //                    2. the new owner with a DUST_MINIMUM value (5500 satoshi)\n  //\n  // You MUST make the first input a UTXO from the current OWNER\n  //\n  // Returns an unsigned serialized transaction.\n\n  /*\n    Format\n       0     2  3    4                   20              36\n    |-----|--|----|-------------------|---------------|\n    magic op keep  hash128(name.ns_id) consensus hash\n             data?\n       output 0: transfer code\n    output 1: new owner\n  */\n  const opRet = Buffer.alloc(36);\n  let keepChar = '~';\n\n  if (keepZonefile) {\n    keepChar = '>';\n  }\n\n  opRet.write(opEncode('>'), 0, 3, 'ascii');\n  opRet.write(keepChar, 3, 1, 'ascii');\n  const hashed = utils_1.hash128(Buffer.from(fullyQualifiedName, 'ascii'));\n  hashed.copy(opRet, 4);\n  opRet.write(consensusHash, 20, 16, 'hex');\n  const opRetPayload = bitcoinjs_lib_1.payments.embed({\n    data: [opRet]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(opRetPayload, 0);\n  tx.addOutput(newOwner, utils_1.DUST_MINIMUM);\n  return tx.buildIncomplete();\n}\n\nexports.makeTransferSkeleton = makeTransferSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeUpdateSkeleton(fullyQualifiedName, consensusHash, valueHash) {\n  // Returns an update tx skeleton.\n  //   with 1 output : 1. the Blockstack update OP_RETURN\n  //\n  // You MUST make the first input a UTXO from the current OWNER\n  //\n  // Returns an unsigned serialized transaction.\n  //\n  // output 0: the revoke code\n\n  /*\n    Format:\n       0     2  3                                   19                      39\n    |-----|--|-----------------------------------|-----------------------|\n    magic op  hash128(name.ns_id,consensus hash) hash160(data)\n       output 0: update code\n  */\n  const opRet = Buffer.alloc(39);\n  const nameBuff = Buffer.from(fullyQualifiedName, 'ascii');\n  const consensusBuff = Buffer.from(consensusHash, 'ascii');\n  const hashedName = utils_1.hash128(Buffer.concat([nameBuff, consensusBuff]));\n  opRet.write(opEncode('+'), 0, 3, 'ascii');\n  hashedName.copy(opRet, 3);\n  opRet.write(valueHash, 19, 20, 'hex');\n  const opRetPayload = bitcoinjs_lib_1.payments.embed({\n    data: [opRet]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(opRetPayload, 0);\n  return tx.buildIncomplete();\n}\n\nexports.makeUpdateSkeleton = makeUpdateSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeRevokeSkeleton(fullyQualifiedName) {\n  // Returns a revoke tx skeleton\n  //    with 1 output: 1. the Blockstack revoke OP_RETURN\n  //\n  // You MUST make the first input a UTXO from the current OWNER\n  //\n  // Returns an unsigned serialized transaction\n\n  /*\n   Format:\n      0    2  3                             39\n   |----|--|-----------------------------|\n   magic op   name.ns_id (37 bytes)\n      output 0: the revoke code\n  */\n  const opRet = Buffer.alloc(3);\n  const nameBuff = Buffer.from(fullyQualifiedName, 'ascii');\n  opRet.write(opEncode('~'), 0, 3, 'ascii');\n  const opReturnBuffer = Buffer.concat([opRet, nameBuff]);\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  return tx.buildIncomplete();\n}\n\nexports.makeRevokeSkeleton = makeRevokeSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeNamespacePreorderSkeleton(namespaceID, consensusHash, preorderAddress, registerAddress, burn) {\n  // Returns a namespace preorder tx skeleton.\n  // Returns an unsigned serialized transaction.\n\n  /*\n   Formats:\n      Without STACKS:\n      0     2   3                                      23               39\n   |-----|---|--------------------------------------|----------------|\n   magic op  hash(ns_id,script_pubkey,reveal_addr)   consensus hash\n   \n   with STACKs:\n      0     2   3                                      23               39                         47\n   |-----|---|--------------------------------------|----------------|--------------------------|\n   magic op  hash(ns_id,script_pubkey,reveal_addr)   consensus hash    token fee (big-endian)\n      output 0: namespace preorder code\n   output 1: change address\n   otuput 2: burn address\n  */\n  const burnAmount = asAmountV2(burn);\n\n  if (burnAmount.units !== 'BTC' && burnAmount.units !== 'STACKS') {\n    throw new Error(\"Invalid burnUnits \".concat(burnAmount.units));\n  }\n\n  const network = config_1.config.network;\n  const burnAddress = network.getDefaultBurnAddress();\n  const namespaceIDBuff = Buffer.from(utils_1.decodeB40(namespaceID), 'hex'); // base40\n\n  const scriptPublicKey = bitcoinjs_lib_1.address.toOutputScript(preorderAddress, network.layer1);\n  const registerBuff = Buffer.from(registerAddress, 'ascii');\n  const dataBuffers = [namespaceIDBuff, scriptPublicKey, registerBuff];\n  const dataBuff = Buffer.concat(dataBuffers);\n  const hashed = utils_1.hash160(dataBuff);\n  let btcBurnAmount = utils_1.DUST_MINIMUM;\n  let opReturnBufferLen = 39;\n\n  if (burnAmount.units === 'STACKS') {\n    opReturnBufferLen = 47;\n  } else {\n    btcBurnAmount = burnAmount.amount.toNumber();\n  }\n\n  const opReturnBuffer = Buffer.alloc(opReturnBufferLen);\n  opReturnBuffer.write(opEncode('*'), 0, 3, 'ascii');\n  hashed.copy(opReturnBuffer, 3);\n  opReturnBuffer.write(consensusHash, 23, 16, 'hex');\n\n  if (burnAmount.units === 'STACKS') {\n    const burnHex = burnAmount.amount.toString(16, 2);\n    const paddedBurnHex = \"0000000000000000\".concat(burnHex).slice(-16);\n    opReturnBuffer.write(paddedBurnHex, 39, 8, 'hex');\n  }\n\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(preorderAddress, utils_1.DUST_MINIMUM);\n  tx.addOutput(burnAddress, btcBurnAmount);\n  return tx.buildIncomplete();\n}\n\nexports.makeNamespacePreorderSkeleton = makeNamespacePreorderSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeNamespaceRevealSkeleton(namespace, revealAddress) {\n  /*\n   Format:\n      0     2   3    7     8     9    10   11   12   13   14    15    16    17       18      20     39\n   |-----|---|----|-----|-----|----|----|----|----|----|-----|-----|-----|--------|-------|-------|\n   magic  op  life coeff. base 1-2  3-4  5-6  7-8  9-10 11-12 13-14 15-16 nonalpha version  ns ID\n                                                  bucket exponents        no-vowel\n                                                                          discounts\n   \n   output 0: namespace reveal code\n   output 1: reveal address\n  */\n  const hexPayload = namespace.toHexPayload();\n  const opReturnBuffer = Buffer.alloc(3 + hexPayload.length / 2);\n  opReturnBuffer.write(opEncode('&'), 0, 3, 'ascii');\n  opReturnBuffer.write(hexPayload, 3, hexPayload.length / 2, 'hex');\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(revealAddress, utils_1.DUST_MINIMUM);\n  return tx.buildIncomplete();\n}\n\nexports.makeNamespaceRevealSkeleton = makeNamespaceRevealSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeNamespaceReadySkeleton(namespaceID) {\n  /*\n   Format:\n      0     2  3  4           23\n   |-----|--|--|------------|\n   magic op  .  ns_id\n      output 0: namespace ready code\n   */\n  const opReturnBuffer = Buffer.alloc(3 + namespaceID.length + 1);\n  opReturnBuffer.write(opEncode('!'), 0, 3, 'ascii');\n  opReturnBuffer.write(\".\".concat(namespaceID), 3, namespaceID.length + 1, 'ascii');\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  return tx.buildIncomplete();\n}\n\nexports.makeNamespaceReadySkeleton = makeNamespaceReadySkeleton; // type bitcoin.payments.p2data bitcoin.payments.embed\n\n/**\n* @ignore\n*/\n\nfunction makeNameImportSkeleton(name, recipientAddr, zonefileHash) {\n  /*\n   Format:\n       0    2  3                             39\n    |----|--|-----------------------------|\n    magic op   name.ns_id (37 bytes)\n      Output 0: the OP_RETURN\n   Output 1: the recipient\n   Output 2: the zonefile hash\n  */\n  if (zonefileHash.length !== 40) {\n    throw new Error('Invalid zonefile hash: must be 20 bytes hex-encoded');\n  }\n\n  const network = config_1.config.network;\n  const opReturnBuffer = Buffer.alloc(3 + name.length);\n  opReturnBuffer.write(opEncode(';'), 0, 3, 'ascii');\n  opReturnBuffer.write(name, 3, name.length, 'ascii');\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  const zonefileHashB58 = bitcoinjs_lib_1.address.toBase58Check(Buffer.from(zonefileHash, 'hex'), network.layer1.pubKeyHash);\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(recipientAddr, utils_1.DUST_MINIMUM);\n  tx.addOutput(zonefileHashB58, utils_1.DUST_MINIMUM);\n  return tx.buildIncomplete();\n}\n\nexports.makeNameImportSkeleton = makeNameImportSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeAnnounceSkeleton(messageHash) {\n  /*\n    Format:\n       0    2  3                             23\n    |----|--|-----------------------------|\n    magic op   message hash (160-bit)\n       output 0: the OP_RETURN\n  */\n  if (messageHash.length !== 40) {\n    throw new Error('Invalid message hash: must be 20 bytes hex-encoded');\n  }\n\n  const opReturnBuffer = Buffer.alloc(3 + messageHash.length / 2);\n  opReturnBuffer.write(opEncode('#'), 0, 3, 'ascii');\n  opReturnBuffer.write(messageHash, 3, messageHash.length / 2, 'hex');\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  return tx.buildIncomplete();\n}\n\nexports.makeAnnounceSkeleton = makeAnnounceSkeleton;\n/**\n* @ignore\n*/\n\nfunction makeTokenTransferSkeleton(recipientAddress, consensusHash, tokenType, tokenAmount, scratchArea) {\n  /*\n   Format:\n       0     2  3              19         38          46                        80\n    |-----|--|--------------|----------|-----------|-------------------------|\n    magic op  consensus_hash token_type amount (BE) scratch area\n                             (ns_id)\n       output 0: token transfer code\n    output 1: recipient address\n  */\n  if (scratchArea.length > 34) {\n    throw new Error('Invalid scratch area: must be no more than 34 bytes');\n  }\n\n  const opReturnBuffer = Buffer.alloc(46 + scratchArea.length);\n  const tokenTypeHex = Buffer.from(tokenType).toString('hex');\n  const tokenTypeHexPadded = \"00000000000000000000000000000000000000\".concat(tokenTypeHex).slice(-38);\n  const tokenValueHex = tokenAmount.toString(16, 2);\n\n  if (tokenValueHex.length > 16) {\n    // exceeds 2**64; can't fit\n    throw new Error(\"Cannot send tokens: cannot fit \".concat(tokenAmount.toString(), \" into 8 bytes\"));\n  }\n\n  const tokenValueHexPadded = \"0000000000000000\".concat(tokenValueHex).slice(-16);\n  opReturnBuffer.write(opEncode('$'), 0, 3, 'ascii');\n  opReturnBuffer.write(consensusHash, 3, consensusHash.length / 2, 'hex');\n  opReturnBuffer.write(tokenTypeHexPadded, 19, tokenTypeHexPadded.length / 2, 'hex');\n  opReturnBuffer.write(tokenValueHexPadded, 38, tokenValueHexPadded.length / 2, 'hex');\n  opReturnBuffer.write(scratchArea, 46, scratchArea.length, 'ascii');\n  const nullOutput = bitcoinjs_lib_1.payments.embed({\n    data: [opReturnBuffer]\n  }).output;\n  const tx = makeTXbuilder();\n  tx.addOutput(nullOutput, 0);\n  tx.addOutput(recipientAddress, utils_1.DUST_MINIMUM);\n  return tx.buildIncomplete();\n}\n\nexports.makeTokenTransferSkeleton = makeTokenTransferSkeleton;","map":null,"metadata":{},"sourceType":"script"}