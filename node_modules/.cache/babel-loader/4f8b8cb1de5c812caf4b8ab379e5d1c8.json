{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst elliptic_1 = require(\"elliptic\");\n\nconst crypto = require(\"crypto\");\n\nconst keys_1 = require(\"../keys\");\n\nconst ecurve = new elliptic_1.ec('secp256k1');\n/**\n* @ignore\n*/\n\nfunction aes256CbcEncrypt(iv, key, plaintext) {\n  const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\n  return Buffer.concat([cipher.update(plaintext), cipher.final()]);\n}\n/**\n* @ignore\n*/\n\n\nfunction aes256CbcDecrypt(iv, key, ciphertext) {\n  const cipher = crypto.createDecipheriv('aes-256-cbc', key, iv);\n  return Buffer.concat([cipher.update(ciphertext), cipher.final()]);\n}\n/**\n* @ignore\n*/\n\n\nfunction hmacSha256(key, content) {\n  return crypto.createHmac('sha256', key).update(content).digest();\n}\n/**\n* @ignore\n*/\n\n\nfunction equalConstTime(b1, b2) {\n  if (b1.length !== b2.length) {\n    return false;\n  }\n\n  let res = 0;\n\n  for (let i = 0; i < b1.length; i++) {\n    res |= b1[i] ^ b2[i]; // jshint ignore:line\n  }\n\n  return res === 0;\n}\n/**\n* @ignore\n*/\n\n\nfunction sharedSecretToKeys(sharedSecret) {\n  // generate mac and encryption key from shared secret\n  const hashedSecret = crypto.createHash('sha512').update(sharedSecret).digest();\n  return {\n    encryptionKey: hashedSecret.slice(0, 32),\n    hmacKey: hashedSecret.slice(32)\n  };\n}\n/**\n* @ignore\n*/\n\n\nfunction getHexFromBN(bnInput) {\n  const hexOut = bnInput.toString('hex');\n\n  if (hexOut.length === 64) {\n    return hexOut;\n  } else if (hexOut.length < 64) {\n    // pad with leading zeros\n    // the padStart function would require node 9\n    const padding = '0'.repeat(64 - hexOut.length);\n    return \"\".concat(padding).concat(hexOut);\n  } else {\n    throw new Error('Generated a > 32-byte BN for encryption. Failing.');\n  }\n}\n\nexports.getHexFromBN = getHexFromBN;\n/**\n * Encrypt content to elliptic curve publicKey using ECIES\n * @param {String} publicKey - secp256k1 public key hex string\n * @param {String | Buffer} content - content to encrypt\n * @return {Object} Object containing (hex encoded):\n *  iv (initialization vector), cipherText (cipher text),\n *  mac (message authentication code), ephemeral public key\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n *\n * @private\n * @ignore\n */\n\nfunction encryptECIES(publicKey, content) {\n  const isString = typeof content === 'string'; // always copy to buffer\n\n  const plainText = content instanceof Buffer ? Buffer.from(content) : Buffer.from(content);\n  const ecPK = ecurve.keyFromPublic(publicKey, 'hex').getPublic();\n  const ephemeralSK = ecurve.genKeyPair();\n  const ephemeralPK = ephemeralSK.getPublic();\n  const sharedSecret = ephemeralSK.derive(ecPK);\n  const sharedSecretHex = getHexFromBN(sharedSecret);\n  const sharedKeys = sharedSecretToKeys(Buffer.from(sharedSecretHex, 'hex'));\n  const initializationVector = crypto.randomBytes(16);\n  const cipherText = aes256CbcEncrypt(initializationVector, sharedKeys.encryptionKey, plainText);\n  const macData = Buffer.concat([initializationVector, Buffer.from(ephemeralPK.encode('array', true)), cipherText]);\n  const mac = hmacSha256(sharedKeys.hmacKey, macData);\n  return {\n    iv: initializationVector.toString('hex'),\n    ephemeralPK: ephemeralPK.encode('hex', true),\n    cipherText: cipherText.toString('hex'),\n    mac: mac.toString('hex'),\n    wasString: isString\n  };\n}\n\nexports.encryptECIES = encryptECIES;\n/**\n * Decrypt content encrypted using ECIES\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} cipherObject - object to decrypt, should contain:\n *  iv (initialization vector), cipherText (cipher text),\n *  mac (message authentication code), ephemeralPublicKey\n *  wasString (boolean indicating with or not to return a buffer or string on decrypt)\n * @return {Buffer} plaintext\n * @throws {Error} if unable to decrypt\n * @private\n * @ignore\n */\n\nfunction decryptECIES(privateKey, cipherObject) {\n  const ecSK = ecurve.keyFromPrivate(privateKey, 'hex');\n  const ephemeralPK = ecurve.keyFromPublic(cipherObject.ephemeralPK, 'hex').getPublic();\n  const sharedSecret = ecSK.derive(ephemeralPK);\n  const sharedSecretBuffer = Buffer.from(getHexFromBN(sharedSecret), 'hex');\n  const sharedKeys = sharedSecretToKeys(sharedSecretBuffer);\n  const ivBuffer = Buffer.from(cipherObject.iv, 'hex');\n  const cipherTextBuffer = Buffer.from(cipherObject.cipherText, 'hex');\n  const macData = Buffer.concat([ivBuffer, Buffer.from(ephemeralPK.encode('array', true)), cipherTextBuffer]);\n  const actualMac = hmacSha256(sharedKeys.hmacKey, macData);\n  const expectedMac = Buffer.from(cipherObject.mac, 'hex');\n\n  if (!equalConstTime(expectedMac, actualMac)) {\n    throw new Error('Decryption failed: failure in MAC check');\n  }\n\n  const plainText = aes256CbcDecrypt(ivBuffer, sharedKeys.encryptionKey, cipherTextBuffer);\n\n  if (cipherObject.wasString) {\n    return plainText.toString();\n  } else {\n    return plainText;\n  }\n}\n\nexports.decryptECIES = decryptECIES;\n/**\n * Sign content using ECDSA\n *\n * @param {String} privateKey - secp256k1 private key hex string\n * @param {Object} content - content to sign\n * @return {Object} contains:\n * signature - Hex encoded DER signature\n * public key - Hex encoded private string taken from privateKey\n * @private\n * @ignore\n */\n\nfunction signECDSA(privateKey, content) {\n  const contentBuffer = content instanceof Buffer ? content : Buffer.from(content);\n  const ecPrivate = ecurve.keyFromPrivate(privateKey, 'hex');\n  const publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n  const contentHash = crypto.createHash('sha256').update(contentBuffer).digest();\n  const signature = ecPrivate.sign(contentHash);\n  const signatureString = signature.toDER('hex');\n  return {\n    signature: signatureString,\n    publicKey\n  };\n}\n\nexports.signECDSA = signECDSA;\n/**\n* @ignore\n*/\n\nfunction getBuffer(content) {\n  if (content instanceof Buffer) return content;else if (content instanceof ArrayBuffer) return Buffer.from(content);else return Buffer.from(content);\n}\n/**\n * Verify content using ECDSA\n * @param {String | Buffer} content - Content to verify was signed\n * @param {String} publicKey - secp256k1 private key hex string\n * @param {String} signature - Hex encoded DER signature\n * @return {Boolean} returns true when signature matches publickey + content, false if not\n * @private\n * @ignore\n */\n\n\nfunction verifyECDSA(content, publicKey, signature) {\n  const contentBuffer = getBuffer(content);\n  const ecPublic = ecurve.keyFromPublic(publicKey, 'hex');\n  const contentHash = crypto.createHash('sha256').update(contentBuffer).digest();\n  return ecPublic.verify(contentHash, signature);\n}\n\nexports.verifyECDSA = verifyECDSA;","map":null,"metadata":{},"sourceType":"script"}