{"ast":null,"code":"// Generated by IcedCoffeeScript 108.0.8\n(function () {\n  var Hasher,\n      SHA1,\n      W,\n      WordArray,\n      transform,\n      __hasProp = {}.hasOwnProperty,\n      __extends = function (child, parent) {\n    for (var key in parent) {\n      if (__hasProp.call(parent, key)) child[key] = parent[key];\n    }\n\n    function ctor() {\n      this.constructor = child;\n    }\n\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n    child.__super__ = parent.prototype;\n    return child;\n  };\n\n  WordArray = require('./wordarray').WordArray;\n  Hasher = require('./algbase').Hasher;\n  W = [];\n\n  SHA1 = function (_super) {\n    __extends(SHA1, _super);\n\n    function SHA1() {\n      return SHA1.__super__.constructor.apply(this, arguments);\n    }\n\n    SHA1.blockSize = 512 / 32;\n    SHA1.prototype.blockSize = SHA1.blockSize;\n    SHA1.output_size = 20;\n    SHA1.prototype.output_size = SHA1.output_size;\n\n    SHA1.prototype._doReset = function () {\n      return this._hash = new WordArray([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);\n    };\n\n    SHA1.prototype._doProcessBlock = function (M, offset) {\n      var H, a, b, c, d, e, i, n, t, _i;\n\n      H = this._hash.words;\n      a = H[0];\n      b = H[1];\n      c = H[2];\n      d = H[3];\n      e = H[4];\n\n      for (i = _i = 0; _i < 80; i = ++_i) {\n        if (i < 16) {\n          W[i] = M[offset + i] | 0;\n        } else {\n          n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n          W[i] = n << 1 | n >>> 31;\n        }\n\n        t = (a << 5 | a >>> 27) + e + W[i];\n\n        if (i < 20) {\n          t += (b & c | ~b & d) + 0x5a827999;\n        } else if (i < 40) {\n          t += (b ^ c ^ d) + 0x6ed9eba1;\n        } else if (i < 60) {\n          t += (b & c | b & d | c & d) - 0x70e44324;\n        } else {\n          t += (b ^ c ^ d) - 0x359d3e2a;\n        }\n\n        e = d;\n        d = c;\n        c = b << 30 | b >>> 2;\n        b = a;\n        a = t;\n      }\n\n      H[0] = H[0] + a | 0;\n      H[1] = H[1] + b | 0;\n      H[2] = H[2] + c | 0;\n      H[3] = H[3] + d | 0;\n      return H[4] = H[4] + e | 0;\n    };\n\n    SHA1.prototype._doFinalize = function () {\n      var data, dataWords, nBitsLeft, nBitsTotal;\n      data = this._data;\n      dataWords = data.words;\n      nBitsTotal = this._nDataBytes * 8;\n      nBitsLeft = data.sigBytes * 8;\n      dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;\n      dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n      dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n      data.sigBytes = dataWords.length * 4;\n\n      this._process();\n\n      return this._hash;\n    };\n\n    SHA1.prototype.copy_to = function (obj) {\n      SHA1.__super__.copy_to.call(this, obj);\n\n      return obj._hash = this._hash.clone();\n    };\n\n    SHA1.prototype.clone = function () {\n      var out;\n      out = new SHA1();\n      this.copy_to(out);\n      return out;\n    };\n\n    return SHA1;\n  }(Hasher);\n\n  transform = transform = function (x) {\n    var out;\n    out = new SHA1().finalize(x);\n    x.scrub();\n    return out;\n  };\n\n  exports.SHA1 = SHA1;\n  exports.transform = transform;\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}