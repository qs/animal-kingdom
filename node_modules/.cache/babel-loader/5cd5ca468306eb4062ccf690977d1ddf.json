{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"cross-fetch/polyfill\"); // @ts-ignore: Could not find a declaration file for module\n\n\nconst jsontokens_1 = require(\"jsontokens\");\n\nconst keys_1 = require(\"../keys\");\n\nconst utils_1 = require(\"../utils\");\n\nconst dids_1 = require(\"../dids\");\n\nconst ec_1 = require(\"../encryption/ec\");\n\nconst logger_1 = require(\"../logger\");\n\nconst authConstants_1 = require(\"./authConstants\");\n\nconst userSession_1 = require(\"./userSession\");\n\nconst VERSION = '1.3.1';\n/**\n * Generates a ECDSA keypair to\n * use as the ephemeral app transit private key\n * @param {SessionData} session - session object in which key will be stored\n * @return {String} the hex encoded private key\n * @private\n * @ignore\n */\n\nfunction generateTransitKey() {\n  const transitKey = keys_1.makeECPrivateKey();\n  return transitKey;\n}\n\nexports.generateTransitKey = generateTransitKey;\n/**\n * Generates an authentication request that can be sent to the Blockstack\n * browser for the user to approve sign in. This authentication request can\n * then be used for sign in by passing it to the `redirectToSignInWithAuthRequest`\n * method.\n *\n * *Note: This method should only be used if you want to roll your own authentication\n * flow. Typically you'd use `redirectToSignIn` which takes care of this\n * under the hood.*\n *\n * @param  {String} transitPrivateKey - hex encoded transit private key\n * @param {String} redirectURI - location to redirect user to after sign in approval\n * @param {String} manifestURI - location of this app's manifest file\n * @param {Array<String>} scopes - the permissions this app is requesting\n * @param {String} appDomain - the origin of this app\n * @param {Number} expiresAt - the time at which this request is no longer valid\n * @param {Object} extraParams - Any extra parameters you'd like to pass to the authenticator.\n * Use this to pass options that aren't part of the Blockstack auth spec, but might be supported\n * by special authenticators.\n * @return {String} the authentication request\n */\n\nfunction makeAuthRequest(transitPrivateKey, redirectURI, manifestURI, scopes = authConstants_1.DEFAULT_SCOPE.slice(), appDomain, expiresAt = utils_1.nextMonth().getTime(), extraParams = {}) {\n  if (!transitPrivateKey) {\n    transitPrivateKey = new userSession_1.UserSession().generateAndStoreTransitKey();\n  }\n\n  const getWindowOrigin = paramName => {\n    const location = utils_1.getGlobalObject('location', {\n      throwIfUnavailable: true,\n      usageDesc: \"makeAuthRequest([\".concat(paramName, \"=undefined])\")\n    });\n    return location.origin;\n  };\n\n  if (!redirectURI) {\n    redirectURI = \"\".concat(getWindowOrigin('redirectURI'), \"/\");\n  }\n\n  if (!manifestURI) {\n    manifestURI = \"\".concat(getWindowOrigin('manifestURI'), \"/manifest.json\");\n  }\n\n  if (!appDomain) {\n    appDomain = getWindowOrigin('appDomain');\n  }\n  /* Create the payload */\n\n\n  const payload = Object.assign({}, extraParams, {\n    jti: utils_1.makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: null,\n    public_keys: [],\n    domain_name: appDomain,\n    manifest_uri: manifestURI,\n    redirect_uri: redirectURI,\n    version: VERSION,\n    do_not_include_profile: true,\n    supports_hub_url: true,\n    scopes\n  });\n  logger_1.Logger.info(\"blockstack.js: generating v\".concat(VERSION, \" auth request\"));\n  /* Convert the private key to a public key to an issuer */\n\n  const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(transitPrivateKey);\n  payload.public_keys = [publicKey];\n  const address = keys_1.publicKeyToAddress(publicKey);\n  payload.iss = dids_1.makeDIDFromAddress(address);\n  /* Sign and return the token */\n\n  const tokenSigner = new jsontokens_1.TokenSigner('ES256k', transitPrivateKey);\n  const token = tokenSigner.sign(payload);\n  return token;\n}\n\nexports.makeAuthRequest = makeAuthRequest;\n/**\n * Encrypts the private key for decryption by the given\n * public key.\n * @param  {String} publicKey  [description]\n * @param  {String} privateKey [description]\n * @return {String} hex encoded ciphertext\n * @private\n * @ignore\n */\n\nfunction encryptPrivateKey(publicKey, privateKey) {\n  const encryptedObj = ec_1.encryptECIES(publicKey, privateKey);\n  const encryptedJSON = JSON.stringify(encryptedObj);\n  return Buffer.from(encryptedJSON).toString('hex');\n}\n\nexports.encryptPrivateKey = encryptPrivateKey;\n/**\n * Decrypts the hex encrypted private key\n * @param  {String} privateKey  the private key corresponding to the public\n * key for which the ciphertext was encrypted\n * @param  {String} hexedEncrypted the ciphertext\n * @return {String}  the decrypted private key\n * @throws {Error} if unable to decrypt\n *\n * @private\n * @ignore\n */\n\nfunction decryptPrivateKey(privateKey, hexedEncrypted) {\n  const unhexedString = Buffer.from(hexedEncrypted, 'hex').toString();\n  const encryptedObj = JSON.parse(unhexedString);\n  const decrypted = ec_1.decryptECIES(privateKey, encryptedObj);\n\n  if (typeof decrypted !== 'string') {\n    throw new Error('Unable to correctly decrypt private key');\n  } else {\n    return decrypted;\n  }\n}\n\nexports.decryptPrivateKey = decryptPrivateKey;\n/**\n * Generates a signed authentication response token for an app. This\n * token is sent back to apps which use contents to access the\n * resources and data requested by the app.\n *\n * @param  {String} privateKey the identity key of the Blockstack ID generating\n * the authentication response\n * @param  {Object} profile the profile object for the Blockstack ID\n * @param  {String} username the username of the Blockstack ID if any, otherwise `null`\n * @param  {AuthMetadata} metadata an object containing metadata sent as part of the authentication\n * response including `email` if requested and available and a URL to the profile\n * @param  {String} coreToken core session token when responding to a legacy auth request\n * or `null` for current direct to gaia authentication requests\n * @param  {String} appPrivateKey the application private key. This private key is\n * unique and specific for every Blockstack ID and application combination.\n * @param  {Number} expiresAt an integer in the same format as\n * `new Date().getTime()`, milliseconds since the Unix epoch\n * @param {String} transitPublicKey the public key provide by the app\n * in its authentication request with which secrets will be encrypted\n * @param {String} hubUrl URL to the write path of the user's Gaia hub\n * @param {String} blockstackAPIUrl URL to the API endpoint to use\n * @param {String} associationToken JWT that binds the app key to the identity key\n * @return {String} signed and encoded authentication response token\n * @private\n * @ignore\n */\n\nfunction makeAuthResponse(privateKey, profile = {}, username = null, metadata, coreToken = null, appPrivateKey = null, expiresAt = utils_1.nextMonth().getTime(), transitPublicKey = null, hubUrl = null, blockstackAPIUrl = null, associationToken = null) {\n  /* Convert the private key to a public key to an issuer */\n  const publicKey = jsontokens_1.SECP256K1Client.derivePublicKey(privateKey);\n  const address = keys_1.publicKeyToAddress(publicKey);\n  /* See if we should encrypt with the transit key */\n\n  let privateKeyPayload = appPrivateKey;\n  let coreTokenPayload = coreToken;\n  let additionalProperties = {};\n\n  if (appPrivateKey !== undefined && appPrivateKey !== null) {\n    logger_1.Logger.info(\"blockstack.js: generating v\".concat(VERSION, \" auth response\"));\n\n    if (transitPublicKey !== undefined && transitPublicKey !== null) {\n      privateKeyPayload = encryptPrivateKey(transitPublicKey, appPrivateKey);\n\n      if (coreToken !== undefined && coreToken !== null) {\n        coreTokenPayload = encryptPrivateKey(transitPublicKey, coreToken);\n      }\n    }\n\n    additionalProperties = {\n      email: metadata.email ? metadata.email : null,\n      profile_url: metadata.profileUrl ? metadata.profileUrl : null,\n      hubUrl,\n      blockstackAPIUrl,\n      associationToken,\n      version: VERSION\n    };\n  } else {\n    logger_1.Logger.info('blockstack.js: generating legacy auth response');\n  }\n  /* Create the payload */\n\n\n  const payload = Object.assign({}, {\n    jti: utils_1.makeUUID4(),\n    iat: Math.floor(new Date().getTime() / 1000),\n    exp: Math.floor(expiresAt / 1000),\n    iss: dids_1.makeDIDFromAddress(address),\n    private_key: privateKeyPayload,\n    public_keys: [publicKey],\n    profile,\n    username,\n    core_token: coreTokenPayload\n  }, additionalProperties);\n  /* Sign and return the token */\n\n  const tokenSigner = new jsontokens_1.TokenSigner('ES256k', privateKey);\n  return tokenSigner.sign(payload);\n}\n\nexports.makeAuthResponse = makeAuthResponse;","map":null,"metadata":{},"sourceType":"script"}