{"ast":null,"code":"// Generated by IcedCoffeeScript 108.0.8\n(function () {\n  var Global,\n      Hasher,\n      SHA256,\n      WordArray,\n      glbl,\n      transform,\n      __hasProp = {}.hasOwnProperty,\n      __extends = function (child, parent) {\n    for (var key in parent) {\n      if (__hasProp.call(parent, key)) child[key] = parent[key];\n    }\n\n    function ctor() {\n      this.constructor = child;\n    }\n\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n    child.__super__ = parent.prototype;\n    return child;\n  };\n\n  WordArray = require('./wordarray').WordArray;\n  Hasher = require('./algbase').Hasher;\n\n  Global = function () {\n    function Global() {\n      this.H = [];\n      this.K = [];\n      this.W = [];\n      this.init();\n    }\n\n    Global.prototype.isPrime = function (n) {\n      var f, sqn, _i;\n\n      if (n === 2 || n === 3 || n === 5 || n === 7) {\n        return true;\n      }\n\n      if (n === 1 || n === 4 || n === 6 || n === 8 || n === 9) {\n        return false;\n      }\n\n      sqn = Math.ceil(Math.sqrt(n));\n\n      for (f = _i = 2; 2 <= sqn ? _i <= sqn : _i >= sqn; f = 2 <= sqn ? ++_i : --_i) {\n        if (n % f === 0) {\n          return false;\n        }\n      }\n\n      return true;\n    };\n\n    Global.prototype.getFractionalBits = function (n) {\n      return (n - (n | 0)) * 0x100000000 | 0;\n    };\n\n    Global.prototype.init = function () {\n      var n, nPrime, _results;\n\n      n = 2;\n      nPrime = 0;\n      _results = [];\n\n      while (nPrime < 64) {\n        if (this.isPrime(n)) {\n          if (nPrime < 8) {\n            this.H[nPrime] = this.getFractionalBits(Math.pow(n, 1 / 2));\n          }\n\n          this.K[nPrime] = this.getFractionalBits(Math.pow(n, 1 / 3));\n          nPrime++;\n        }\n\n        _results.push(n++);\n      }\n\n      return _results;\n    };\n\n    return Global;\n  }();\n\n  glbl = new Global();\n\n  SHA256 = function (_super) {\n    __extends(SHA256, _super);\n\n    function SHA256() {\n      return SHA256.__super__.constructor.apply(this, arguments);\n    }\n\n    SHA256.blockSize = 512 / 32;\n    SHA256.prototype.blockSize = SHA256.blockSize;\n    SHA256.output_size = 256 / 8;\n    SHA256.prototype.output_size = SHA256.output_size;\n\n    SHA256.prototype._doReset = function () {\n      return this._hash = new WordArray(glbl.H.slice(0));\n    };\n\n    SHA256.prototype.get_output_size = function () {\n      return this.output_size;\n    };\n\n    SHA256.prototype._doProcessBlock = function (M, offset) {\n      var H, K, W, a, b, c, ch, d, e, f, g, gamma0, gamma0x, gamma1, gamma1x, h, i, maj, sigma0, sigma1, t1, t2, _i;\n\n      H = this._hash.words;\n      W = glbl.W;\n      K = glbl.K;\n      a = H[0];\n      b = H[1];\n      c = H[2];\n      d = H[3];\n      e = H[4];\n      f = H[5];\n      g = H[6];\n      h = H[7];\n\n      for (i = _i = 0; _i < 64; i = ++_i) {\n        if (i < 16) {\n          W[i] = M[offset + i] | 0;\n        } else {\n          gamma0x = W[i - 15];\n          gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;\n          gamma1x = W[i - 2];\n          gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;\n          W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n        }\n\n        ch = e & f ^ ~e & g;\n        maj = a & b ^ a & c ^ b & c;\n        sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);\n        sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);\n        t1 = h + sigma1 + ch + K[i] + W[i];\n        t2 = sigma0 + maj;\n        h = g;\n        g = f;\n        f = e;\n        e = d + t1 | 0;\n        d = c;\n        c = b;\n        b = a;\n        a = t1 + t2 | 0;\n      }\n\n      H[0] = H[0] + a | 0;\n      H[1] = H[1] + b | 0;\n      H[2] = H[2] + c | 0;\n      H[3] = H[3] + d | 0;\n      H[4] = H[4] + e | 0;\n      H[5] = H[5] + f | 0;\n      H[6] = H[6] + g | 0;\n      return H[7] = H[7] + h | 0;\n    };\n\n    SHA256.prototype._doFinalize = function () {\n      var data, dataWords, nBitsLeft, nBitsTotal;\n      data = this._data;\n      dataWords = data.words;\n      nBitsTotal = this._nDataBytes * 8;\n      nBitsLeft = data.sigBytes * 8;\n      dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;\n      dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n      dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;\n      data.sigBytes = dataWords.length * 4;\n\n      this._process();\n\n      return this._hash;\n    };\n\n    SHA256.prototype.scrub = function () {\n      return this._hash.scrub();\n    };\n\n    SHA256.prototype.copy_to = function (obj) {\n      SHA256.__super__.copy_to.call(this, obj);\n\n      return obj._hash = this._hash.clone();\n    };\n\n    SHA256.prototype.clone = function () {\n      var out;\n      out = new SHA256();\n      this.copy_to(out);\n      return out;\n    };\n\n    return SHA256;\n  }(Hasher);\n\n  transform = function (x) {\n    var out;\n    out = new SHA256().finalize(x);\n    x.scrub();\n    return out;\n  };\n\n  exports.SHA256 = SHA256;\n  exports.transform = transform;\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}