{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n\nconst utils_1 = require(\"./utils\");\n\nconst skeletons_1 = require(\"./skeletons\");\n\nconst config_1 = require(\"../config\");\n\nconst errors_1 = require(\"../errors\");\n\nconst signers_1 = require(\"./signers\");\n\nconst dummyConsensusHash = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';\nconst dummyZonefileHash = 'ffffffffffffffffffffffffffffffffffffffff';\n/**\n* @ignore\n*/\n\nfunction addOwnerInput(utxos, ownerAddress, txB, addChangeOut = true) {\n  // add an owner UTXO and a change out.\n  if (utxos.length <= 0) {\n    throw new Error('Owner has no UTXOs for UPDATE.');\n  }\n\n  utxos.sort((a, b) => a.value - b.value);\n  const ownerUTXO = utxos[0];\n  const ownerInput = txB.addInput(ownerUTXO.tx_hash, ownerUTXO.tx_output_n);\n\n  if (addChangeOut) {\n    txB.addOutput(ownerAddress, ownerUTXO.value);\n  }\n\n  return {\n    index: ownerInput,\n    value: ownerUTXO.value\n  };\n}\n/**\n* @ignore\n*/\n\n\nfunction fundTransaction(txB, paymentAddress, utxos, feeRate, inAmounts, changeIndex = null) {\n  // change index for the payer.\n  if (changeIndex === null) {\n    changeIndex = txB.addOutput(paymentAddress, utils_1.DUST_MINIMUM);\n  } // fund the transaction fee.\n\n\n  const txFee = utils_1.estimateTXBytes(txB, 0, 0) * feeRate;\n  const outAmounts = utils_1.sumOutputValues(txB);\n  const change = utils_1.addUTXOsToFund(txB, utxos, txFee + outAmounts - inAmounts, feeRate);\n  const txInner = utils_1.getTransactionInsideBuilder(txB);\n  const txOut = txInner.outs[changeIndex];\n  txOut.value += change;\n  return txB;\n}\n/**\n* @ignore\n*/\n\n\nfunction returnTransactionHex(txB, buildIncomplete = false) {\n  if (buildIncomplete) {\n    return txB.buildIncomplete().toHex();\n  } else {\n    return txB.build().toHex();\n  }\n}\n/**\n* @ignore\n*/\n\n\nfunction getTransactionSigner(input) {\n  if (typeof input === 'string') {\n    return signers_1.PubkeyHashSigner.fromHexString(input);\n  } else {\n    return input;\n  }\n}\n/**\n * Estimates cost of a preorder transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to preorder\n * @param {String} destinationAddress - the address to receive the name (this\n *    must be passed as the 'registrationAddress' in the register transaction)\n * @param {String} paymentAddress - the address funding the preorder\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the preorder. This includes a 5500 satoshi dust output for the preorder.\n *    Even though this is a change output, the payer must supply enough funds\n *    to generate this output, so we include it in the cost.\n * @private\n */\n\n\nfunction estimatePreorder(fullyQualifiedName, destinationAddress, paymentAddress, paymentUtxos = 1) {\n  const network = config_1.config.network;\n  const preorderPromise = network.getNamePrice(fullyQualifiedName).then(namePrice => skeletons_1.makePreorderSkeleton(fullyQualifiedName, dummyConsensusHash, paymentAddress, network.getDefaultBurnAddress(), namePrice, destinationAddress));\n  return Promise.all([network.getFeeRate(), preorderPromise]).then(([feeRate, preorderTX]) => {\n    const outputsValue = utils_1.sumOutputValues(preorderTX);\n    const txFee = feeRate * utils_1.estimateTXBytes(preorderTX, paymentUtxos, 0);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of a register transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to register\n * @param {String} registerAddress - the address to receive the name\n * @param {String} paymentAddress - the address funding the register\n * @param {Boolean} includingZonefile - whether or not we will broadcast\n *    a zonefile hash as part  of the register\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the register.\n * @private\n */\n\n\nfunction estimateRegister(fullyQualifiedName, registerAddress, paymentAddress, includingZonefile = false, paymentUtxos = 1) {\n  const network = config_1.config.network;\n  let valueHash;\n\n  if (includingZonefile) {\n    valueHash = dummyZonefileHash;\n  }\n\n  const registerTX = skeletons_1.makeRegisterSkeleton(fullyQualifiedName, registerAddress, valueHash);\n  return network.getFeeRate().then(feeRate => {\n    const outputsValue = utils_1.sumOutputValues(registerTX); // 1 additional output for payer change\n\n    const txFee = feeRate * utils_1.estimateTXBytes(registerTX, paymentUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of an update transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to update\n * @param {String} ownerAddress - the owner of the name\n * @param {String} paymentAddress - the address funding the update\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the update.\n * @private\n */\n\n\nfunction estimateUpdate(fullyQualifiedName, ownerAddress, paymentAddress, paymentUtxos = 1) {\n  const network = config_1.config.network;\n  const updateTX = skeletons_1.makeUpdateSkeleton(fullyQualifiedName, dummyConsensusHash, dummyZonefileHash);\n  return network.getFeeRate().then(feeRate => {\n    const outputsValue = utils_1.sumOutputValues(updateTX); // 1 additional input for the owner\n    // 2 additional outputs for owner / payer change\n\n    const txFee = feeRate * utils_1.estimateTXBytes(updateTX, 1 + paymentUtxos, 2);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of an transfer transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to transfer\n * @param {String} destinationAddress - the next owner of the name\n * @param {String} ownerAddress - the current owner of the name\n * @param {String} paymentAddress - the address funding the transfer\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the transfer.\n * @private\n */\n\n\nfunction estimateTransfer(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress, paymentUtxos = 1) {\n  const network = config_1.config.network;\n  const transferTX = skeletons_1.makeTransferSkeleton(fullyQualifiedName, dummyConsensusHash, destinationAddress);\n  return network.getFeeRate().then(feeRate => {\n    const outputsValue = utils_1.sumOutputValues(transferTX); // 1 additional input for the owner\n    // 2 additional outputs for owner / payer change\n\n    const txFee = feeRate * utils_1.estimateTXBytes(transferTX, 1 + paymentUtxos, 2);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of an transfer transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to renew\n * @param {String} destinationAddress - the next owner of the name\n * @param {String} ownerAddress - the current owner of the name\n * @param {String} paymentAddress - the address funding the transfer\n * @param {Boolean} includingZonefile - whether or not we will broadcast a zonefile hash\n      in the renewal operation\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the transfer.\n * @private\n */\n\n\nfunction estimateRenewal(fullyQualifiedName, destinationAddress, ownerAddress, paymentAddress, includingZonefile = false, paymentUtxos = 1) {\n  const network = config_1.config.network;\n  let valueHash;\n\n  if (includingZonefile) {\n    valueHash = dummyZonefileHash;\n  }\n\n  const renewalPromise = network.getNamePrice(fullyQualifiedName).then(namePrice => skeletons_1.makeRenewalSkeleton(fullyQualifiedName, destinationAddress, ownerAddress, network.getDefaultBurnAddress(), namePrice, valueHash));\n  return Promise.all([network.getFeeRate(), renewalPromise]).then(([feeRate, renewalTX]) => {\n    const outputsValue = utils_1.sumOutputValues(renewalTX); // 1 additional input for the owner\n    // and renewal skeleton includes all outputs for owner change, but not for payer change.\n\n    const txFee = feeRate * utils_1.estimateTXBytes(renewalTX, 1 + paymentUtxos, 1);\n    return txFee + outputsValue - 5500; // don't count the dust change for old owner.\n  });\n}\n/**\n * Estimates cost of a revoke transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to revoke\n * @param {String} ownerAddress - the current owner of the name\n * @param {String} paymentAddress  the address funding the revoke\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund the\n *    revoke.\n * @private\n */\n\n\nfunction estimateRevoke(fullyQualifiedName, ownerAddress, paymentAddress, paymentUtxos = 1) {\n  const network = config_1.config.network;\n  const revokeTX = skeletons_1.makeRevokeSkeleton(fullyQualifiedName);\n  return Promise.all([network.getFeeRate()]).then(([feeRate]) => {\n    const outputsValue = utils_1.sumOutputValues(revokeTX); // 1 additional input for owner\n    // 1 additional output for payer change\n\n    const txFee = feeRate * utils_1.estimateTXBytes(revokeTX, 1 + paymentUtxos, 2);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of a namespace preorder transaction for a namespace\n * @param {String} namespaceID - the namespace to preorder\n * @param {String} revealAddress - the address to receive the namespace (this\n *    must be passed as the 'revealAddress' in the namespace-reveal transaction)\n * @param {String} paymentAddress - the address funding the preorder\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address.\n * @returns {Promise} - a promise which resolves to the satoshi cost to fund\n *    the preorder. This includes a 5500 satoshi dust output for the preorder.\n *    Even though this is a change output, the payer must supply enough funds\n *    to generate this output, so we include it in the cost.\n * @private\n */\n\n\nfunction estimateNamespacePreorder(namespaceID, revealAddress, paymentAddress, paymentUtxos = 1) {\n  const network = config_1.config.network;\n  const preorderPromise = network.getNamespacePrice(namespaceID).then(namespacePrice => skeletons_1.makeNamespacePreorderSkeleton(namespaceID, dummyConsensusHash, paymentAddress, revealAddress, namespacePrice));\n  return Promise.all([network.getFeeRate(), preorderPromise]).then(([feeRate, preorderTX]) => {\n    const outputsValue = utils_1.sumOutputValues(preorderTX);\n    const txFee = feeRate * utils_1.estimateTXBytes(preorderTX, paymentUtxos, 0);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates cost of a namesapce reveal transaction for a namespace\n * @param {BlockstackNamespace} namespace - the namespace to reveal\n * @param {String} revealAddress - the address to receive the namespace\n *    (this must have been passed as 'revealAddress' to a prior namespace\n *    preorder)\n * @param {String} paymentAddress - the address that pays for this transaction\n * @param {Number} paymentUtxos - the number of UTXOs we expect will be required\n *    from the payment address\n * @returns {Promise} - a promise which resolves to the satoshi cost to\n *    fund the reveal.  This includes a 5500 satoshi dust output for the\n *    preorder.  Even though this is a change output, the payer must have\n *    enough funds to generate this output, so we include it in the cost.\n * @private\n */\n\n\nfunction estimateNamespaceReveal(namespace, revealAddress, paymentAddress, paymentUtxos = 1) {\n  const network = config_1.config.network;\n  const revealTX = skeletons_1.makeNamespaceRevealSkeleton(namespace, revealAddress);\n  return network.getFeeRate().then(feeRate => {\n    const outputsValue = utils_1.sumOutputValues(revealTX); // 1 additional output for payer change\n\n    const txFee = feeRate * utils_1.estimateTXBytes(revealTX, paymentUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates the cost of a namespace-ready transaction for a namespace\n * @param {String} namespaceID - the namespace to ready\n * @param {Number} revealUtxos - the number of UTXOs we expect will\n *  be required from the reveal address\n * @returns {Promise} - a promise which resolves to the satoshi cost to\n *  fund this namespacey-ready transaction.\n * @private\n */\n\n\nfunction estimateNamespaceReady(namespaceID, revealUtxos = 1) {\n  const network = config_1.config.network;\n  const readyTX = skeletons_1.makeNamespaceReadySkeleton(namespaceID);\n  return network.getFeeRate().then(feeRate => {\n    const outputsValue = utils_1.sumOutputValues(readyTX);\n    const txFee = feeRate * utils_1.estimateTXBytes(readyTX, revealUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates the cost of a name-import transaction\n * @param {String} name - the fully-qualified name\n * @param {String} recipientAddr - the recipient\n * @param {String} zonefileHash - the zone file hash\n * @param {Number} importUtxos - the number of UTXOs we expect will\n *  be required from the importer address\n * @returns {Promise} - a promise which resolves to the satoshi cost\n *  to fund this name-import transaction\n * @private\n */\n\n\nfunction estimateNameImport(name, recipientAddr, zonefileHash, importUtxos = 1) {\n  const network = config_1.config.network;\n  const importTX = skeletons_1.makeNameImportSkeleton(name, recipientAddr, zonefileHash);\n  return network.getFeeRate().then(feeRate => {\n    const outputsValue = utils_1.sumOutputValues(importTX);\n    const txFee = feeRate * utils_1.estimateTXBytes(importTX, importUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates the cost of an announce transaction\n * @param {String} messageHash - the hash of the message\n * @param {Number} senderUtxos - the number of utxos we expect will\n *  be required from the importer address\n * @returns {Promise} - a promise which resolves to the satoshi cost\n *  to fund this announce transaction\n * @private\n */\n\n\nfunction estimateAnnounce(messageHash, senderUtxos = 1) {\n  const network = config_1.config.network;\n  const announceTX = skeletons_1.makeAnnounceSkeleton(messageHash);\n  return network.getFeeRate().then(feeRate => {\n    const outputsValue = utils_1.sumOutputValues(announceTX);\n    const txFee = feeRate * utils_1.estimateTXBytes(announceTX, senderUtxos, 1);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Estimates the cost of a token-transfer transaction\n * @param {String} recipientAddress - the recipient of the tokens\n * @param {String} tokenType - the type of token to spend\n * @param {Object} tokenAmount - a 64-bit unsigned BigInteger encoding the number of tokens\n *   to spend\n * @param {String} scratchArea - an arbitrary string to store with the transaction\n * @param {Number} senderUtxos - the number of utxos we expect will\n *  be required from the importer address\n * @param {Number} additionalOutputs - the number of outputs we expect to add beyond\n *  just the recipient output (default = 1, if the token owner is also the bitcoin funder)\n * @returns {Promise} - a promise which resolves to the satoshi cost to\n *  fund this token-transfer transaction\n * @private\n */\n\n\nfunction estimateTokenTransfer(recipientAddress, tokenType, tokenAmount, scratchArea, senderUtxos = 1, additionalOutputs = 1) {\n  const network = config_1.config.network;\n  const tokenTransferTX = skeletons_1.makeTokenTransferSkeleton(recipientAddress, dummyConsensusHash, tokenType, tokenAmount, scratchArea);\n  return network.getFeeRate().then(feeRate => {\n    const outputsValue = utils_1.sumOutputValues(tokenTransferTX);\n    const txFee = feeRate * utils_1.estimateTXBytes(tokenTransferTX, senderUtxos, additionalOutputs);\n    return txFee + outputsValue;\n  });\n}\n/**\n * Generates a preorder transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to pre-order\n * @param {String} destinationAddress - the address to receive the name (this\n *    must be passed as the 'registrationAddress' in the register transaction)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction or a transaction signer object\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makePreorder(fullyQualifiedName, destinationAddress, paymentKeyIn, buildIncomplete = false) {\n  const network = config_1.config.network;\n  const namespace = fullyQualifiedName.split('.').pop();\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(preorderAddress => {\n    const preorderPromise = Promise.all([network.getConsensusHash(), network.getNamePrice(fullyQualifiedName), network.getNamespaceBurnAddress(namespace)]).then(([consensusHash, namePrice, burnAddress]) => skeletons_1.makePreorderSkeleton(fullyQualifiedName, consensusHash, preorderAddress, burnAddress, namePrice, destinationAddress));\n    return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate(), preorderPromise]).then(([utxos, feeRate, preorderSkeleton]) => {\n      const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(preorderSkeleton, network.layer1);\n      txB.setVersion(1);\n      const changeIndex = 1; // preorder skeleton always creates a change output at index = 1\n\n      const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0, changeIndex);\n      return utils_1.signInputs(signingTxB, paymentKey);\n    }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n  });\n}\n/**\n * Generates an update transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to update\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of the\n *    owner key, or a transaction signer object. This will provide one\n *    UTXO input, and also recieve a dust output.\n * @param {String | TransactionSigner} paymentKeyIn - a hex string, or a\n *    transaction signer object, of the private key used to fund the\n *    transaction's txfees\n * @param {String} zonefile - the zonefile data to update (this will be hashed\n *    to include in the transaction), the zonefile itself must be published\n *    after the UPDATE propagates.\n * @param {String} valueHash - if given, this is the hash to store (instead of\n *    zonefile).  zonefile will be ignored if this is given.\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makeUpdate(fullyQualifiedName, ownerKeyIn, paymentKeyIn, zonefile, valueHash = '', buildIncomplete = false) {\n  const network = config_1.config.network;\n\n  if (!valueHash && !zonefile) {\n    return Promise.reject(new Error('Need zonefile or valueHash arguments'));\n  }\n\n  if (valueHash.length === 0) {\n    if (!zonefile) {\n      return Promise.reject(new Error('Need zonefile or valueHash arguments'));\n    }\n\n    valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n  } else if (valueHash.length !== 40) {\n    return Promise.reject(new Error(\"Invalid valueHash \".concat(valueHash)));\n  }\n\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  const ownerKey = getTransactionSigner(ownerKeyIn);\n  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(([ownerAddress, paymentAddress]) => {\n    const txPromise = network.getConsensusHash().then(consensusHash => skeletons_1.makeUpdateSkeleton(fullyQualifiedName, consensusHash, valueHash)).then(updateTX => {\n      const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(updateTX, network.layer1);\n      txB.setVersion(1);\n      return txB;\n    });\n    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(([txB, payerUtxos, ownerUtxos, feeRate]) => {\n      const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n      const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n      return utils_1.signInputs(signingTxB, paymentKey, [{\n        index: ownerInput.index,\n        signer: ownerKey\n      }]);\n    });\n  }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a register transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to register\n * @param {String} registerAddress - the address to receive the name (this\n *    must have been passed as the 'destinationAddress' in the preorder transaction)\n *    this address will receive a dust UTXO\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key (or a TransactionSigner object) used to fund the\n *    transaction (this *must* be the same as the payment address used\n *    to fund the preorder)\n * @param {String} zonefile - the zonefile data to include (this will be hashed\n *    to include in the transaction), the zonefile itself must be published\n *    after the UPDATE propagates.\n * @param {String} valueHash - the hash of the zone file data to include.\n *    It will be used instead of zonefile, if given\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makeRegister(fullyQualifiedName, registerAddress, paymentKeyIn, zonefile = null, valueHash = null, buildIncomplete = false) {\n  const network = config_1.config.network;\n\n  if (!valueHash && !!zonefile) {\n    valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n  } else if (!!valueHash && valueHash.length !== 40) {\n    return Promise.reject(new Error(\"Invalid zonefile hash \".concat(valueHash)));\n  }\n\n  const registerSkeleton = skeletons_1.makeRegisterSkeleton(fullyQualifiedName, registerAddress, valueHash);\n  const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(registerSkeleton, network.layer1);\n  txB.setVersion(1);\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(paymentAddress => Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {\n    const signingTxB = fundTransaction(txB, paymentAddress, utxos, feeRate, 0);\n    return utils_1.signInputs(signingTxB, paymentKey);\n  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a transfer transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to transfer\n * @param {String} destinationAddress - the address to receive the name.\n *    this address will receive a dust UTXO\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\n *    the current owner's private key (or a TransactionSigner object)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction (or a\n *    TransactionSigner object)\n * @param {Boolean} keepZonefile - if true, then preserve the name's zone file\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\n *   transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makeTransfer(fullyQualifiedName, destinationAddress, ownerKeyIn, paymentKeyIn, keepZonefile = false, buildIncomplete = false) {\n  const network = config_1.config.network;\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  const ownerKey = getTransactionSigner(ownerKeyIn);\n  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(([ownerAddress, paymentAddress]) => {\n    const txPromise = network.getConsensusHash().then(consensusHash => skeletons_1.makeTransferSkeleton(fullyQualifiedName, consensusHash, destinationAddress, keepZonefile)).then(transferTX => {\n      const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(transferTX, network.layer1);\n      txB.setVersion(1);\n      return txB;\n    });\n    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(([txB, payerUtxos, ownerUtxos, feeRate]) => {\n      const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n      const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n      return utils_1.signInputs(signingTxB, paymentKey, [{\n        index: ownerInput.index,\n        signer: ownerKey\n      }]);\n    });\n  }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a revoke transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to revoke\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\n *    the current owner's private key (or a TransactionSigner object)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction (or a\n *    TransactionSigner object)\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makeRevoke(fullyQualifiedName, ownerKeyIn, paymentKeyIn, buildIncomplete = false) {\n  const network = config_1.config.network;\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  const ownerKey = getTransactionSigner(ownerKeyIn);\n  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(([ownerAddress, paymentAddress]) => {\n    const revokeTX = skeletons_1.makeRevokeSkeleton(fullyQualifiedName);\n    const txPromise = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(revokeTX, network.layer1);\n    txPromise.setVersion(1);\n    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(([txB, payerUtxos, ownerUtxos, feeRate]) => {\n      const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB);\n      const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n      return utils_1.signInputs(signingTxB, paymentKey, [{\n        index: ownerInput.index,\n        signer: ownerKey\n      }]);\n    });\n  }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a renewal transaction for a domain name.\n * @param {String} fullyQualifiedName - the name to transfer\n * @param {String} destinationAddress - the address to receive the name after renewal\n *    this address will receive a dust UTXO\n * @param {String | TransactionSigner} ownerKeyIn - a hex string of\n *    the current owner's private key (or a TransactionSigner object)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the renewal (or a TransactionSigner\n *    object)\n * @param {String} zonefile - the zonefile data to include, if given (this will be hashed\n *    to include in the transaction), the zonefile itself must be published\n *    after the RENEWAL propagates.\n * @param {String} valueHash - the raw zone file hash to include (this will be used\n *    instead of zonefile, if given).\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n */\n\n\nfunction makeRenewal(fullyQualifiedName, destinationAddress, ownerKeyIn, paymentKeyIn, zonefile = null, valueHash = null, buildIncomplete = false) {\n  const network = config_1.config.network;\n\n  if (!valueHash && !!zonefile) {\n    valueHash = utils_1.hash160(Buffer.from(zonefile)).toString('hex');\n  }\n\n  const namespace = fullyQualifiedName.split('.').pop();\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  const ownerKey = getTransactionSigner(ownerKeyIn);\n  return Promise.all([ownerKey.getAddress(), paymentKey.getAddress()]).then(([ownerAddress, paymentAddress]) => {\n    const txPromise = Promise.all([network.getNamePrice(fullyQualifiedName), network.getNamespaceBurnAddress(namespace)]).then(([namePrice, burnAddress]) => skeletons_1.makeRenewalSkeleton(fullyQualifiedName, destinationAddress, ownerAddress, burnAddress, namePrice, valueHash)).then(tx => {\n      const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(tx, network.layer1);\n      txB.setVersion(1);\n      return txB;\n    });\n    return Promise.all([txPromise, network.getUTXOs(paymentAddress), network.getUTXOs(ownerAddress), network.getFeeRate()]).then(([txB, payerUtxos, ownerUtxos, feeRate]) => {\n      const ownerInput = addOwnerInput(ownerUtxos, ownerAddress, txB, false);\n      const txInner = utils_1.getTransactionInsideBuilder(txB);\n      const ownerOutput = txInner.outs[2];\n      const ownerOutputAddr = bitcoinjs_lib_1.address.fromOutputScript(ownerOutput.script, network.layer1);\n\n      if (ownerOutputAddr !== ownerAddress) {\n        return Promise.reject(new Error(\"Original owner \".concat(ownerAddress, \" should have an output at \") + \"index 2 in transaction was \".concat(ownerOutputAddr)));\n      }\n\n      ownerOutput.value = ownerInput.value;\n      const signingTxB = fundTransaction(txB, paymentAddress, payerUtxos, feeRate, ownerInput.value);\n      return utils_1.signInputs(signingTxB, paymentKey, [{\n        index: ownerInput.index,\n        signer: ownerKey\n      }]);\n    });\n  }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a namespace preorder transaction for a namespace\n * @param {String} namespaceID - the namespace to pre-order\n * @param {String} revealAddress - the address to receive the namespace (this\n *    must be passed as the 'revealAddress' in the namespace-reveal transaction)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string of\n *    the private key used to fund the transaction (or a\n *    TransactionSigner object)\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *    indicating whether the function should attempt to return an unsigned (or not fully signed)\n *    transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *    this function *does not* perform the requisite safety checks -- please see\n *    the safety module for those.\n * @private\n *\n * @ignore\n */\n\n\nfunction makeNamespacePreorder(namespaceID, revealAddress, paymentKeyIn, buildIncomplete = false) {\n  const network = config_1.config.network;\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(preorderAddress => {\n    const preorderPromise = Promise.all([network.getConsensusHash(), network.getNamespacePrice(namespaceID)]).then(([consensusHash, namespacePrice]) => skeletons_1.makeNamespacePreorderSkeleton(namespaceID, consensusHash, preorderAddress, revealAddress, namespacePrice));\n    return Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate(), preorderPromise]).then(([utxos, feeRate, preorderSkeleton]) => {\n      const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(preorderSkeleton, network.layer1);\n      txB.setVersion(1);\n      const changeIndex = 1; // preorder skeleton always creates a change output at index = 1\n\n      const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0, changeIndex);\n      return utils_1.signInputs(signingTxB, paymentKey);\n    }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n  });\n}\n/**\n * Generates a namespace reveal transaction for a namespace\n * @param {BlockstackNamespace} namespace - the namespace to reveal\n * @param {String} revealAddress - the address to receive the namespace (this\n *   must be passed as the 'revealAddress' in the namespace-reveal transaction)\n * @param {String | TransactionSigner} paymentKeyIn - a hex string (or\n *   a TransactionSigner object) of the private key used to fund the\n *   transaction\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\n *   transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *   this function *does not* perform the requisite safety checks -- please see\n *   the safety module for those.\n * @private\n */\n\n\nfunction makeNamespaceReveal(namespace, revealAddress, paymentKeyIn, buildIncomplete = false) {\n  const network = config_1.config.network;\n\n  if (!namespace.check()) {\n    return Promise.reject(new Error('Invalid namespace'));\n  }\n\n  const namespaceRevealTX = skeletons_1.makeNamespaceRevealSkeleton(namespace, revealAddress);\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(preorderAddress => Promise.all([network.getUTXOs(preorderAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {\n    const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(namespaceRevealTX, network.layer1);\n    txB.setVersion(1);\n    const signingTxB = fundTransaction(txB, preorderAddress, utxos, feeRate, 0);\n    return utils_1.signInputs(signingTxB, paymentKey);\n  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a namespace ready transaction for a namespace\n * @param {String} namespaceID - the namespace to launch\n * @param {String | TransactionSigner} revealKeyIn - the private key\n *  of the 'revealAddress' used to reveal the namespace\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *  indicating whether the function should attempt to return an unsigned (or not fully signed)\n *  transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n *  this function *does not* perform the requisite safety checks -- please see\n *  the safety module for those.\n * @private\n */\n\n\nfunction makeNamespaceReady(namespaceID, revealKeyIn, buildIncomplete = false) {\n  const network = config_1.config.network;\n  const namespaceReadyTX = skeletons_1.makeNamespaceReadySkeleton(namespaceID);\n  const revealKey = getTransactionSigner(revealKeyIn);\n  return revealKey.getAddress().then(revealAddress => Promise.all([network.getUTXOs(revealAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {\n    const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(namespaceReadyTX, network.layer1);\n    txB.setVersion(1);\n    const signingTxB = fundTransaction(txB, revealAddress, utxos, feeRate, 0);\n    return utils_1.signInputs(signingTxB, revealKey);\n  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a name import transaction for a namespace\n * @param {String} name - the name to import\n * @param {String} recipientAddr - the address to receive the name\n * @param {String} zonefileHash - the hash of the zonefile to give this name\n * @param {String | TransactionSigner} importerKeyIn - the private key\n * that pays for the import\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * this function does not perform the requisite safety checks -- please see\n * the safety module for those.\n * @private\n */\n\n\nfunction makeNameImport(name, recipientAddr, zonefileHash, importerKeyIn, buildIncomplete = false) {\n  const network = config_1.config.network;\n  const nameImportTX = skeletons_1.makeNameImportSkeleton(name, recipientAddr, zonefileHash);\n  const importerKey = getTransactionSigner(importerKeyIn);\n  return importerKey.getAddress().then(importerAddress => Promise.all([network.getUTXOs(importerAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {\n    const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(nameImportTX, network.layer1);\n    const signingTxB = fundTransaction(txB, importerAddress, utxos, feeRate, 0);\n    return utils_1.signInputs(signingTxB, importerKey);\n  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates an announce transaction\n * @param {String} messageHash - the hash of the message to send.  Should be\n *  an already-announced zone file hash\n * @param {String | TransactionSigner} senderKeyIn - the private key\n *  that pays for the transaction.  Should be the key that owns the\n *  name that the message recipients subscribe to\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * this function does not perform the requisite safety checks -- please see the\n * safety module for those.\n * @private\n */\n\n\nfunction makeAnnounce(messageHash, senderKeyIn, buildIncomplete = false) {\n  const network = config_1.config.network;\n  const announceTX = skeletons_1.makeAnnounceSkeleton(messageHash);\n  const senderKey = getTransactionSigner(senderKeyIn);\n  return senderKey.getAddress().then(senderAddress => Promise.all([network.getUTXOs(senderAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {\n    const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(announceTX, network.layer1);\n    const signingTxB = fundTransaction(txB, senderAddress, utxos, feeRate, 0);\n    return utils_1.signInputs(signingTxB, senderKey);\n  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a token-transfer transaction\n * @param {String} recipientAddress - the address to receive the tokens\n * @param {String} tokenType - the type of tokens to send\n * @param {Object} tokenAmount - the BigInteger encoding of an unsigned 64-bit number of\n *  tokens to send\n * @param {String} scratchArea - an arbitrary string to include with the transaction\n * @param {String | TransactionSigner} senderKeyIn - the hex-encoded private key to send\n *   the tokens\n * @param {String | TransactionSigner} btcFunderKeyIn - the hex-encoded private key to fund\n *   the bitcoin fees for the transaction. Optional -- if not passed, will attempt to\n *   fund with sender key.\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n *   indicating whether the function should attempt to return an unsigned (or not fully signed)\n *   transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * This function does not perform the requisite safety checks -- please see the\n * safety module for those.\n * @private\n */\n\n\nfunction makeTokenTransfer(recipientAddress, tokenType, tokenAmount, scratchArea, senderKeyIn, btcFunderKeyIn, buildIncomplete = false) {\n  const network = config_1.config.network;\n  const separateFunder = !!btcFunderKeyIn;\n  const senderKey = getTransactionSigner(senderKeyIn);\n  const btcKey = btcFunderKeyIn ? getTransactionSigner(btcFunderKeyIn) : senderKey;\n  const txPromise = network.getConsensusHash().then(consensusHash => skeletons_1.makeTokenTransferSkeleton(recipientAddress, consensusHash, tokenType, tokenAmount, scratchArea));\n  return Promise.all([senderKey.getAddress(), btcKey.getAddress()]).then(([senderAddress, btcAddress]) => {\n    const btcUTXOsPromise = separateFunder ? network.getUTXOs(btcAddress) : Promise.resolve([]);\n    return Promise.all([network.getUTXOs(senderAddress), btcUTXOsPromise, network.getFeeRate(), txPromise]).then(([senderUTXOs, btcUTXOs, feeRate, tokenTransferTX]) => {\n      const txB = bitcoinjs_lib_1.TransactionBuilder.fromTransaction(tokenTransferTX, network.layer1);\n\n      if (separateFunder) {\n        const payerInput = addOwnerInput(senderUTXOs, senderAddress, txB);\n        const signingTxB = fundTransaction(txB, btcAddress, btcUTXOs, feeRate, payerInput.value);\n        return utils_1.signInputs(signingTxB, btcKey, [{\n          index: payerInput.index,\n          signer: senderKey\n        }]);\n      } else {\n        const signingTxB = fundTransaction(txB, senderAddress, senderUTXOs, feeRate, 0);\n        return utils_1.signInputs(signingTxB, senderKey);\n      }\n    });\n  }).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n/**\n * Generates a bitcoin spend to a specified address. This will fund up to `amount`\n *   of satoshis from the payer's UTXOs. It will generate a change output if and only\n *   if the amount of leftover change is *greater* than the additional fees associated\n *   with the extra output. If the requested amount is not enough to fund the transaction's\n *   associated fees, then this will reject with a InvalidAmountError\n *\n * UTXOs are selected largest to smallest, and UTXOs which cannot fund the fees associated\n *   with their own input will not be included.\n *\n * If you specify an amount > the total balance of the payer address, then this will\n *   generate a maximum spend transaction\n *\n * @param {String} destinationAddress - the address to receive the bitcoin payment\n * @param {String | TransactionSigner} paymentKeyIn - the private key\n *    used to fund the bitcoin spend\n * @param {number} amount - the amount in satoshis for the payment address to\n *    spend in this transaction\n * @param {boolean} buildIncomplete - optional boolean, defaults to false,\n * indicating whether the function should attempt to return an unsigned (or not fully signed)\n * transaction. Useful for passing around a TX for multi-sig input signing.\n * @returns {Promise} - a promise which resolves to the hex-encoded transaction.\n * @private\n */\n\n\nfunction makeBitcoinSpend(destinationAddress, paymentKeyIn, amount, buildIncomplete = false) {\n  if (amount <= 0) {\n    return Promise.reject(new errors_1.InvalidParameterError('amount', 'amount must be greater than zero'));\n  }\n\n  const network = config_1.config.network;\n  const paymentKey = getTransactionSigner(paymentKeyIn);\n  return paymentKey.getAddress().then(paymentAddress => Promise.all([network.getUTXOs(paymentAddress), network.getFeeRate()]).then(([utxos, feeRate]) => {\n    const txB = new bitcoinjs_lib_1.TransactionBuilder(network.layer1);\n    txB.setVersion(1);\n    const destinationIndex = txB.addOutput(destinationAddress, 0); // will add utxos up to _amount_ and return the amount of leftover _change_\n\n    let change;\n\n    try {\n      change = utils_1.addUTXOsToFund(txB, utxos, amount, feeRate, false);\n    } catch (err) {\n      if (err.name === 'NotEnoughFundsError') {\n        // actual amount funded = amount requested - remainder\n        amount -= err.leftToFund;\n        change = 0;\n      } else {\n        throw err;\n      }\n    }\n\n    let feesToPay = feeRate * utils_1.estimateTXBytes(txB, 0, 0);\n    const feeForChange = feeRate * utils_1.estimateTXBytes(txB, 0, 1) - feesToPay; // it's worthwhile to add a change output\n\n    if (change > feeForChange) {\n      feesToPay += feeForChange;\n      txB.addOutput(paymentAddress, change);\n    } // now let's compute how much output is leftover once we pay the fees.\n\n\n    const outputAmount = amount - feesToPay;\n\n    if (outputAmount < utils_1.DUST_MINIMUM) {\n      throw new errors_1.InvalidAmountError(feesToPay, amount);\n    } // we need to manually set the output values now\n\n\n    const txInner = utils_1.getTransactionInsideBuilder(txB);\n    const txOut = txInner.outs[destinationIndex];\n    txOut.value = outputAmount; // ready to sign.\n\n    return utils_1.signInputs(txB, paymentKey);\n  })).then(signingTxB => returnTransactionHex(signingTxB, buildIncomplete));\n}\n\nexports.transactions = {\n  makeRenewal,\n  makeUpdate,\n  makePreorder,\n  makeRegister,\n  makeTransfer,\n  makeRevoke,\n  makeNamespacePreorder,\n  makeNamespaceReveal,\n  makeNamespaceReady,\n  makeBitcoinSpend,\n  makeNameImport,\n  makeAnnounce,\n  makeTokenTransfer,\n  BlockstackNamespace: skeletons_1.BlockstackNamespace,\n  estimatePreorder,\n  estimateRegister,\n  estimateTransfer,\n  estimateUpdate,\n  estimateRenewal,\n  estimateRevoke,\n  estimateNamespacePreorder,\n  estimateNamespaceReveal,\n  estimateNamespaceReady,\n  estimateNameImport,\n  estimateAnnounce,\n  estimateTokenTransfer\n};","map":null,"metadata":{},"sourceType":"script"}