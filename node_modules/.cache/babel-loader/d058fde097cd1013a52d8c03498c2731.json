{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/ivan/Projects/hacksupply/animal-kingdom-master/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst bip174_1 = require('bip174');\n\nconst varuint = require('bip174/src/lib/converter/varint');\n\nconst utils_1 = require('bip174/src/lib/utils');\n\nconst address_1 = require('./address');\n\nconst bufferutils_1 = require('./bufferutils');\n\nconst crypto_1 = require('./crypto');\n\nconst ecpair_1 = require('./ecpair');\n\nconst networks_1 = require('./networks');\n\nconst payments = require('./payments');\n\nconst bscript = require('./script');\n\nconst transaction_1 = require('./transaction');\n/**\n * These are the default arguments for a Psbt instance.\n */\n\n\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\n\nclass Psbt {\n  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {\n    this.data = data; // set defaults\n\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2); // Make data hidden when enumerating\n\n    const dpew = (obj, attr, enumerable, writable) => Object.defineProperty(obj, attr, {\n      enumerable,\n      writable\n    });\n\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n\n  static fromBase64(data, opts = {}) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, opts);\n  }\n\n  static fromHex(data, opts = {}) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, opts);\n  }\n\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n\n  addInput(inputData) {\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n\n  addOutput(outputData) {\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const _outputData = outputData,\n          address = _outputData.address;\n\n    if (typeof address === 'string') {\n      const network = this.opts.network;\n      const script = address_1.toOutputScript(address, network);\n      outputData = Object.assign(outputData, {\n        script\n      });\n    }\n\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n\n    const tx = c.__TX.clone();\n\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n\n  getFeeRate() {\n    return getTxCacheValue('__FEE_RATE', 'fee rate', this.data.inputs, this.__CACHE);\n  }\n\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n\n  finalizeAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n\n  finalizeInput(inputIndex) {\n    const input = utils_1.checkForInput(this.data.inputs, inputIndex);\n\n    const _getScriptFromInput = getScriptFromInput(inputIndex, input, this.__CACHE),\n          script = _getScriptFromInput.script,\n          isP2SH = _getScriptFromInput.isP2SH,\n          isP2WSH = _getScriptFromInput.isP2WSH,\n          isSegwit = _getScriptFromInput.isSegwit;\n\n    if (!script) throw new Error(\"No script found for input #\".concat(inputIndex));\n    const scriptType = classifyScript(script);\n    if (!canFinalize(input, script, scriptType)) throw new Error(\"Can not finalize input #\".concat(inputIndex));\n    checkPartialSigSighashes(input);\n\n    const _getFinalScripts = getFinalScripts(script, scriptType, input.partialSig, isSegwit, isP2SH, isP2WSH),\n          finalScriptSig = _getFinalScripts.finalScriptSig,\n          finalScriptWitness = _getFinalScripts.finalScriptWitness;\n\n    if (finalScriptSig) this.data.updateInput(inputIndex, {\n      finalScriptSig\n    });\n    if (finalScriptWitness) this.data.updateInput(inputIndex, {\n      finalScriptWitness\n    });\n    if (!finalScriptSig && !finalScriptWitness) throw new Error(\"Unknown error finalizing input #\".concat(inputIndex));\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n\n  validateSignaturesOfAllInputs() {\n    utils_1.checkForInput(this.data.inputs, 0); // making sure we have at least one\n\n    const results = range(this.data.inputs.length).map(idx => this.validateSignaturesOfInput(idx));\n    return results.reduce((final, res) => res === true && final, true);\n  }\n\n  validateSignaturesOfInput(inputIndex, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1) throw new Error('No signatures to validate');\n    const mySigs = pubkey ? partialSig.filter(sig => sig.pubkey.equals(pubkey)) : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n\n      const _ref = sighashCache !== sig.hashType ? getHashForSig(inputIndex, Object.assign({}, input, {\n        sighashType: sig.hashType\n      }), this.__CACHE) : {\n        hash: hashCache,\n        script: scriptCache\n      },\n            hash = _ref.hash,\n            script = _ref.script;\n\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      const keypair = ecpair_1.fromPublicKey(pSig.pubkey);\n      results.push(keypair.verify(hash, sig.signature));\n    }\n\n    return results.every(res => res === true);\n  }\n\n  signAllInputsHD(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n\n    const results = [];\n\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n\n    return this;\n  }\n\n  signAllInputsHDAsync(hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n\n      const results = [];\n      const promises = [];\n\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(() => {\n          results.push(true);\n        }, () => {\n          results.push(false);\n        }));\n      }\n\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n\n        resolve();\n      });\n    });\n  }\n\n  signInputHD(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n\n  signInputHDAsync(inputIndex, hdKeyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer => this.signInputAsync(inputIndex, signer, sighashTypes));\n      return Promise.all(promises).then(() => {\n        resolve();\n      }).catch(reject);\n    });\n  }\n\n  signAllInputs(keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n    if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input'); // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n\n    const results = [];\n\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n\n    return this;\n  }\n\n  signAllInputsAsync(keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey) return reject(new Error('Need Signer to sign input')); // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n\n      const results = [];\n      const promises = [];\n\n      for (const _ref2 of this.data.inputs.entries()) {\n        var _ref3 = _slicedToArray(_ref2, 1);\n\n        const i = _ref3[0];\n        promises.push(this.signInputAsync(i, keyPair, sighashTypes).then(() => {\n          results.push(true);\n        }, () => {\n          results.push(false);\n        }));\n      }\n\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n\n        resolve();\n      });\n    });\n  }\n\n  signInput(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n    if (!keyPair || !keyPair.publicKey) throw new Error('Need Signer to sign input');\n\n    const _getHashAndSighashTyp = getHashAndSighashType(this.data.inputs, inputIndex, keyPair.publicKey, this.__CACHE, sighashTypes),\n          hash = _getHashAndSighashTyp.hash,\n          sighashType = _getHashAndSighashTyp.sighashType;\n\n    const partialSig = [{\n      pubkey: keyPair.publicKey,\n      signature: bscript.signature.encode(keyPair.sign(hash), sighashType)\n    }];\n    this.data.updateInput(inputIndex, {\n      partialSig\n    });\n    return this;\n  }\n\n  signInputAsync(inputIndex, keyPair, sighashTypes = [transaction_1.Transaction.SIGHASH_ALL]) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey) return reject(new Error('Need Signer to sign input'));\n\n      const _getHashAndSighashTyp2 = getHashAndSighashType(this.data.inputs, inputIndex, keyPair.publicKey, this.__CACHE, sighashTypes),\n            hash = _getHashAndSighashTyp2.hash,\n            sighashType = _getHashAndSighashTyp2.sighashType;\n\n      Promise.resolve(keyPair.sign(hash)).then(signature => {\n        const partialSig = [{\n          pubkey: keyPair.publicKey,\n          signature: bscript.signature.encode(signature, sighashType)\n        }];\n        this.data.updateInput(inputIndex, {\n          partialSig\n        });\n        resolve();\n      });\n    });\n  }\n\n  toBuffer() {\n    return this.data.toBuffer();\n  }\n\n  toHex() {\n    return this.data.toHex();\n  }\n\n  toBase64() {\n    return this.data.toBase64();\n  }\n\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n\n  updateInput(inputIndex, updateData) {\n    this.data.updateInput(inputIndex, updateData);\n\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, this.data.inputs[inputIndex], inputIndex);\n    }\n\n    return this;\n  }\n\n  updateOutput(outputIndex, updateData) {\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n\n}\n\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\n\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\n\n\nclass PsbtTransaction {\n  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true\n    });\n  }\n\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length\n    };\n  }\n\n  addInput(input) {\n    if (input.hash === undefined || input.index === undefined || !Buffer.isBuffer(input.hash) && typeof input.hash !== 'string' || typeof input.index !== 'number') {\n      throw new Error('Error adding input.');\n    }\n\n    const hash = typeof input.hash === 'string' ? bufferutils_1.reverseBuffer(Buffer.from(input.hash, 'hex')) : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n\n  addOutput(output) {\n    if (output.script === undefined || output.value === undefined || !Buffer.isBuffer(output.script) || typeof output.value !== 'number') {\n      throw new Error('Error adding output.');\n    }\n\n    this.tx.addOutput(output.script, output.value);\n  }\n\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n\n}\n\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n\n    case 'multisig':\n      const p2ms = payments.p2ms({\n        output: script\n      });\n      return hasSigs(p2ms.m, input.partialSig);\n\n    default:\n      return false;\n  }\n}\n\nfunction hasSigs(neededSigs, partialSig) {\n  if (!partialSig) return false;\n  if (partialSig.length > neededSigs) throw new Error('Too many signatures');\n  return partialSig.length === neededSigs;\n}\n\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\n\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({\n        output: script\n      });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\n\nconst isP2MS = isPaymentFactory(payments.p2ms);\nconst isP2PK = isPaymentFactory(payments.p2pk);\nconst isP2PKH = isPaymentFactory(payments.p2pkh);\nconst isP2WPKH = isPaymentFactory(payments.p2wpkh);\nconst isP2WSHScript = isPaymentFactory(payments.p2wsh);\n\nfunction check32Bit(num) {\n  if (typeof num !== 'number' || num !== Math.floor(num) || num > 0xffffffff || num < 0) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\n\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n\n  const satoshis = feeRate * vsize;\n\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\"Warning: You are paying around \".concat((satoshis / 1e8).toFixed(8), \" in \") + \"fees, which is \".concat(feeRate, \" satoshi per byte for a transaction \") + \"with a VSize of \".concat(vsize, \" bytes (segwit counted as 0.25 byte per \") + \"byte). Use setMaximumFeeRate method to raise your threshold, or \" + \"pass true to the first arg of extractTransaction.\");\n  }\n}\n\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    let throws = false;\n    let pSigs = [];\n\n    if ((input.partialSig || []).length === 0) {\n      if (!input.finalScriptSig && !input.finalScriptWitness) return;\n      pSigs = getPsigsFromInputFinalScripts(input);\n    } else {\n      pSigs = input.partialSig;\n    }\n\n    pSigs.forEach(pSig => {\n      const _bscript$signature$de = bscript.signature.decode(pSig.signature),\n            hashType = _bscript$signature$de.hashType;\n\n      const whitelist = [];\n      const isAnyoneCanPay = hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;\n      if (isAnyoneCanPay) whitelist.push('addInput');\n      const hashMod = hashType & 0x1f;\n\n      switch (hashMod) {\n        case transaction_1.Transaction.SIGHASH_ALL:\n          break;\n\n        case transaction_1.Transaction.SIGHASH_SINGLE:\n        case transaction_1.Transaction.SIGHASH_NONE:\n          whitelist.push('addOutput');\n          whitelist.push('setInputSequence');\n          break;\n      }\n\n      if (whitelist.indexOf(action) === -1) {\n        throws = true;\n      }\n    });\n\n    if (throws) {\n      throw new Error('Can not modify transaction, signatures exist.');\n    }\n  });\n}\n\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const partialSig = input.partialSig,\n        sighashType = input.sighashType;\n  partialSig.forEach(pSig => {\n    const _bscript$signature$de2 = bscript.signature.decode(pSig.signature),\n          hashType = _bscript$signature$de2.hashType;\n\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\n\nfunction checkScriptForPubkey(pubkey, script, action) {\n  const pubkeyHash = crypto_1.hash160(pubkey);\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  const hasKey = decompiled.some(element => {\n    if (typeof element === 'number') return false;\n    return element.equals(pubkey) || element.equals(pubkeyHash);\n  });\n\n  if (!hasKey) {\n    throw new Error(\"Can not \".concat(action, \" for this input with the key \").concat(pubkey.toString('hex')));\n  }\n}\n\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(input => input.script && input.script.length === 0 && input.witness && input.witness.length === 0);\n\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\n\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\n\nfunction checkTxInputCache(cache, input) {\n  const key = bufferutils_1.reverseBuffer(Buffer.from(input.hash)).toString('hex') + ':' + input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\n\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript) => {\n    const redeemScriptOutput = payment({\n      redeem: {\n        output: redeemScript\n      }\n    }).output;\n\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(\"\".concat(paymentScriptName, \" for input #\").concat(inputIndex, \" doesn't match the scriptPubKey in the prevout\"));\n    }\n  };\n}\n\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(payments.p2wsh, 'Witness script');\n\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized)) throw new Error(\"PSBT must be finalized to calculate \".concat(name));\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;else if (key === '__FEE') return c.__FEE;\n}\n\nfunction getFinalScripts(script, scriptType, partialSig, isSegwit, isP2SH, isP2WSH) {\n  let finalScriptSig;\n  let finalScriptWitness; // Wow, the payments API is very handy\n\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({\n    redeem: payment\n  });\n  const p2sh = !isP2SH ? null : payments.p2sh({\n    redeem: p2wsh || payment\n  });\n\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = witnessStackToScriptWitness(p2wsh.witness);\n    } else {\n      finalScriptWitness = witnessStackToScriptWitness(payment.witness);\n    }\n\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n\n  return {\n    finalScriptSig,\n    finalScriptWitness\n  };\n}\n\nfunction getHashAndSighashType(inputs, inputIndex, pubkey, cache, sighashTypes) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n\n  const _getHashForSig = getHashForSig(inputIndex, input, cache, sighashTypes),\n        hash = _getHashForSig.hash,\n        sighashType = _getHashForSig.sighashType,\n        script = _getHashForSig.script;\n\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType\n  };\n}\n\nfunction getHashForSig(inputIndex, input, cache, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType = input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\"Sighash type is not allowed. Retry the sign method passing the \" + \"sighashTypes array of whitelisted types. Sighash type: \".concat(str));\n  }\n\n  let hash;\n  let script;\n\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash(); // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(\"Non-witness UTXO hash for input #\".concat(inputIndex, \" doesn't match the hash specified in the prevout\"));\n    }\n\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    const prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n\n    if (input.redeemScript) {\n      // If a redeemScript is provided, the scriptPubKey must be for that redeemScript\n      checkRedeemScript(inputIndex, prevout.script, input.redeemScript);\n      script = input.redeemScript;\n    } else {\n      script = prevout.script;\n    }\n\n    if (isP2WSHScript(script)) {\n      if (!input.witnessScript) throw new Error('Segwit input needs witnessScript if not P2WPKH');\n      checkWitnessScript(inputIndex, script, input.witnessScript);\n      hash = unsignedTx.hashForWitnessV0(inputIndex, input.witnessScript, prevout.value, sighashType);\n      script = input.witnessScript;\n    } else if (isP2WPKH(script)) {\n      // P2WPKH uses the P2PKH template for prevoutScript when signing\n      const signingScript = payments.p2pkh({\n        hash: script.slice(2)\n      }).output;\n      hash = unsignedTx.hashForWitnessV0(inputIndex, signingScript, prevout.value, sighashType);\n    } else {\n      hash = unsignedTx.hashForSignature(inputIndex, script, sighashType);\n    }\n  } else if (input.witnessUtxo) {\n    let _script; // so we don't shadow the `let script` above\n\n\n    if (input.redeemScript) {\n      // If a redeemScript is provided, the scriptPubKey must be for that redeemScript\n      checkRedeemScript(inputIndex, input.witnessUtxo.script, input.redeemScript);\n      _script = input.redeemScript;\n    } else {\n      _script = input.witnessUtxo.script;\n    }\n\n    if (isP2WPKH(_script)) {\n      // P2WPKH uses the P2PKH template for prevoutScript when signing\n      const signingScript = payments.p2pkh({\n        hash: _script.slice(2)\n      }).output;\n      hash = unsignedTx.hashForWitnessV0(inputIndex, signingScript, input.witnessUtxo.value, sighashType);\n      script = _script;\n    } else if (isP2WSHScript(_script)) {\n      if (!input.witnessScript) throw new Error('Segwit input needs witnessScript if not P2WPKH');\n      checkWitnessScript(inputIndex, _script, input.witnessScript);\n      hash = unsignedTx.hashForWitnessV0(inputIndex, input.witnessScript, input.witnessUtxo.value, sighashType); // want to make sure the script we return is the actual meaningful script\n\n      script = input.witnessScript;\n    } else {\n      throw new Error(\"Input #\".concat(inputIndex, \" has witnessUtxo but non-segwit script: \") + \"\".concat(_script.toString('hex')));\n    }\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n\n  return {\n    script,\n    sighashType,\n    hash\n  };\n}\n\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs\n      });\n      break;\n\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature\n      });\n      break;\n\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature\n      });\n      break;\n\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature\n      });\n      break;\n  }\n\n  return payment;\n}\n\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig ? [] : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness ? [] : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems.concat(witnessItems).filter(item => {\n    return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);\n  }).map(sig => ({\n    signature: sig\n  }));\n}\n\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(cache, input, inputIndex);\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n\n  if (input.witnessScript || isP2WPKH(res.script)) {\n    res.isSegwit = true;\n  }\n\n  return res;\n}\n\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = utils_1.checkForInput(inputs, inputIndex);\n\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n\n  const myDerivations = input.bip32Derivation.map(bipDv => {\n    if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n      return bipDv;\n    } else {\n      return;\n    }\n  }).filter(v => !!v);\n\n  if (myDerivations.length === 0) {\n    throw new Error('Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint');\n  }\n\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n\n    return node;\n  });\n  return signers;\n}\n\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({\n    output: script\n  }); // for each pubkey in order of p2ms script\n\n  return p2ms.pubkeys.map(pk => {\n    // filter partialSig array by pubkey being equal\n    return (partialSig.filter(ps => {\n      return ps.pubkey.equals(pk);\n    })[0] || {}).signature; // Any pubkey without a match will return undefined\n    // this last filter removes all the undefined items in the array.\n  }).filter(v => !!v);\n}\n\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n\n    return vector;\n  }\n\n  return readVector();\n}\n\nfunction sighashTypeToString(sighashType) {\n  let text = sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY ? 'SIGHASH_ANYONECANPAY | ' : '';\n  const sigMod = sighashType & 0x1f;\n\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n\n  return text;\n}\n\nfunction witnessStackToScriptWitness(witness) {\n  let buffer = Buffer.allocUnsafe(0);\n\n  function writeSlice(slice) {\n    buffer = Buffer.concat([buffer, Buffer.from(slice)]);\n  }\n\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n\n  writeVector(witness);\n  return buffer;\n}\n\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    }\n\n  });\n}\n\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig) tx.ins[idx].script = input.finalScriptSig;\n\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(input.finalScriptWitness);\n    }\n\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n  const fee = inputAmount - outputAmount;\n\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\n\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n\n  return c[inputIndex];\n}\n\nfunction classifyScript(script) {\n  if (isP2WPKH(script)) return 'witnesspubkeyhash';\n  if (isP2PKH(script)) return 'pubkeyhash';\n  if (isP2MS(script)) return 'multisig';\n  if (isP2PK(script)) return 'pubkey';\n  return 'nonstandard';\n}\n\nfunction range(n) {\n  return [...Array(n).keys()];\n}","map":null,"metadata":{},"sourceType":"script"}