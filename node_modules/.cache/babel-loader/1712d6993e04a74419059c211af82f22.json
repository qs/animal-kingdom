{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"/home/ivan/Projects/hacksupply/animal-kingdom-master/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst baddress = require('./address');\n\nconst bufferutils_1 = require('./bufferutils');\n\nconst classify = require('./classify');\n\nconst bcrypto = require('./crypto');\n\nconst ECPair = require('./ecpair');\n\nconst networks = require('./networks');\n\nconst payments = require('./payments');\n\nconst bscript = require('./script');\n\nconst script_1 = require('./script');\n\nconst transaction_1 = require('./transaction');\n\nconst types = require('./types');\n\nconst typeforce = require('typeforce');\n\nconst SCRIPT_TYPES = classify.types;\nconst PREVOUT_TYPES = new Set([// Raw\n'p2pkh', 'p2pk', 'p2wpkh', 'p2ms', // P2SH wrapped\n'p2sh-p2pkh', 'p2sh-p2pk', 'p2sh-p2wpkh', 'p2sh-p2ms', // P2WSH wrapped\n'p2wsh-p2pkh', 'p2wsh-p2pk', 'p2wsh-p2ms', // P2SH-P2WSH wrapper\n'p2sh-p2wsh-p2pkh', 'p2sh-p2wsh-p2pk', 'p2sh-p2wsh-p2ms']);\n\nfunction tfMessage(type, value, message) {\n  try {\n    typeforce(type, value);\n  } catch (err) {\n    throw new Error(message);\n  }\n}\n\nfunction txIsString(tx) {\n  return typeof tx === 'string' || tx instanceof String;\n}\n\nfunction txIsTransaction(tx) {\n  return tx instanceof transaction_1.Transaction;\n}\n\nclass TransactionBuilder {\n  // WARNING: maximumFeeRate is __NOT__ to be relied on,\n  //          it's just another potential safety mechanism (safety in-depth)\n  constructor(network = networks.bitcoin, maximumFeeRate = 2500) {\n    this.network = network;\n    this.maximumFeeRate = maximumFeeRate;\n    this.__PREV_TX_SET = {};\n    this.__INPUTS = [];\n    this.__TX = new transaction_1.Transaction();\n    this.__TX.version = 2;\n    this.__USE_LOW_R = false;\n    console.warn('Deprecation Warning: TransactionBuilder will be removed in the future. ' + '(v6.x.x or later) Please use the Psbt class instead. Examples of usage ' + 'are available in the transactions-psbt.js integration test file on our ' + 'Github. A high level explanation is available in the psbt.ts and psbt.js ' + 'files as well.');\n  }\n\n  static fromTransaction(transaction, network) {\n    const txb = new TransactionBuilder(network); // Copy transaction fields\n\n    txb.setVersion(transaction.version);\n    txb.setLockTime(transaction.locktime); // Copy outputs (done first to avoid signature invalidation)\n\n    transaction.outs.forEach(txOut => {\n      txb.addOutput(txOut.script, txOut.value);\n    }); // Copy inputs\n\n    transaction.ins.forEach(txIn => {\n      txb.__addInputUnsafe(txIn.hash, txIn.index, {\n        sequence: txIn.sequence,\n        script: txIn.script,\n        witness: txIn.witness\n      });\n    }); // fix some things not possible through the public API\n\n    txb.__INPUTS.forEach((input, i) => {\n      fixMultisigOrder(input, transaction, i);\n    });\n\n    return txb;\n  }\n\n  setLowR(setting) {\n    typeforce(typeforce.maybe(typeforce.Boolean), setting);\n\n    if (setting === undefined) {\n      setting = true;\n    }\n\n    this.__USE_LOW_R = setting;\n    return setting;\n  }\n\n  setLockTime(locktime) {\n    typeforce(types.UInt32, locktime); // if any signatures exist, throw\n\n    if (this.__INPUTS.some(input => {\n      if (!input.signatures) return false;\n      return input.signatures.some(s => s !== undefined);\n    })) {\n      throw new Error('No, this would invalidate signatures');\n    }\n\n    this.__TX.locktime = locktime;\n  }\n\n  setVersion(version) {\n    typeforce(types.UInt32, version); // XXX: this might eventually become more complex depending on what the versions represent\n\n    this.__TX.version = version;\n  }\n\n  addInput(txHash, vout, sequence, prevOutScript) {\n    if (!this.__canModifyInputs()) {\n      throw new Error('No, this would invalidate signatures');\n    }\n\n    let value; // is it a hex string?\n\n    if (txIsString(txHash)) {\n      // transaction hashs's are displayed in reverse order, un-reverse it\n      txHash = bufferutils_1.reverseBuffer(Buffer.from(txHash, 'hex')); // is it a Transaction object?\n    } else if (txIsTransaction(txHash)) {\n      const txOut = txHash.outs[vout];\n      prevOutScript = txOut.script;\n      value = txOut.value;\n      txHash = txHash.getHash(false);\n    }\n\n    return this.__addInputUnsafe(txHash, vout, {\n      sequence,\n      prevOutScript,\n      value\n    });\n  }\n\n  addOutput(scriptPubKey, value) {\n    if (!this.__canModifyOutputs()) {\n      throw new Error('No, this would invalidate signatures');\n    } // Attempt to get a script if it's a base58 or bech32 address string\n\n\n    if (typeof scriptPubKey === 'string') {\n      scriptPubKey = baddress.toOutputScript(scriptPubKey, this.network);\n    }\n\n    return this.__TX.addOutput(scriptPubKey, value);\n  }\n\n  build() {\n    return this.__build(false);\n  }\n\n  buildIncomplete() {\n    return this.__build(true);\n  }\n\n  sign(signParams, keyPair, redeemScript, hashType, witnessValue, witnessScript) {\n    trySign(getSigningData(this.network, this.__INPUTS, this.__needsOutputs.bind(this), this.__TX, signParams, keyPair, redeemScript, hashType, witnessValue, witnessScript, this.__USE_LOW_R));\n  }\n\n  __addInputUnsafe(txHash, vout, options) {\n    if (transaction_1.Transaction.isCoinbaseHash(txHash)) {\n      throw new Error('coinbase inputs not supported');\n    }\n\n    const prevTxOut = txHash.toString('hex') + ':' + vout;\n    if (this.__PREV_TX_SET[prevTxOut] !== undefined) throw new Error('Duplicate TxOut: ' + prevTxOut);\n    let input = {}; // derive what we can from the scriptSig\n\n    if (options.script !== undefined) {\n      input = expandInput(options.script, options.witness || []);\n    } // if an input value was given, retain it\n\n\n    if (options.value !== undefined) {\n      input.value = options.value;\n    } // derive what we can from the previous transactions output script\n\n\n    if (!input.prevOutScript && options.prevOutScript) {\n      let prevOutType;\n\n      if (!input.pubkeys && !input.signatures) {\n        const expanded = expandOutput(options.prevOutScript);\n\n        if (expanded.pubkeys) {\n          input.pubkeys = expanded.pubkeys;\n          input.signatures = expanded.signatures;\n        }\n\n        prevOutType = expanded.type;\n      }\n\n      input.prevOutScript = options.prevOutScript;\n      input.prevOutType = prevOutType || classify.output(options.prevOutScript);\n    }\n\n    const vin = this.__TX.addInput(txHash, vout, options.sequence, options.scriptSig);\n\n    this.__INPUTS[vin] = input;\n    this.__PREV_TX_SET[prevTxOut] = true;\n    return vin;\n  }\n\n  __build(allowIncomplete) {\n    if (!allowIncomplete) {\n      if (!this.__TX.ins.length) throw new Error('Transaction has no inputs');\n      if (!this.__TX.outs.length) throw new Error('Transaction has no outputs');\n    }\n\n    const tx = this.__TX.clone(); // create script signatures from inputs\n\n\n    this.__INPUTS.forEach((input, i) => {\n      if (!input.prevOutType && !allowIncomplete) throw new Error('Transaction is not complete');\n      const result = build(input.prevOutType, input, allowIncomplete);\n\n      if (!result) {\n        if (!allowIncomplete && input.prevOutType === SCRIPT_TYPES.NONSTANDARD) throw new Error('Unknown input type');\n        if (!allowIncomplete) throw new Error('Not enough information');\n        return;\n      }\n\n      tx.setInputScript(i, result.input);\n      tx.setWitness(i, result.witness);\n    });\n\n    if (!allowIncomplete) {\n      // do not rely on this, its merely a last resort\n      if (this.__overMaximumFees(tx.virtualSize())) {\n        throw new Error('Transaction has absurd fees');\n      }\n    }\n\n    return tx;\n  }\n\n  __canModifyInputs() {\n    return this.__INPUTS.every(input => {\n      if (!input.signatures) return true;\n      return input.signatures.every(signature => {\n        if (!signature) return true;\n        const hashType = signatureHashType(signature); // if SIGHASH_ANYONECANPAY is set, signatures would not\n        // be invalidated by more inputs\n\n        return (hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY) !== 0;\n      });\n    });\n  }\n\n  __needsOutputs(signingHashType) {\n    if (signingHashType === transaction_1.Transaction.SIGHASH_ALL) {\n      return this.__TX.outs.length === 0;\n    } // if inputs are being signed with SIGHASH_NONE, we don't strictly need outputs\n    // .build() will fail, but .buildIncomplete() is OK\n\n\n    return this.__TX.outs.length === 0 && this.__INPUTS.some(input => {\n      if (!input.signatures) return false;\n      return input.signatures.some(signature => {\n        if (!signature) return false; // no signature, no issue\n\n        const hashType = signatureHashType(signature);\n        if (hashType & transaction_1.Transaction.SIGHASH_NONE) return false; // SIGHASH_NONE doesn't care about outputs\n\n        return true; // SIGHASH_* does care\n      });\n    });\n  }\n\n  __canModifyOutputs() {\n    const nInputs = this.__TX.ins.length;\n    const nOutputs = this.__TX.outs.length;\n    return this.__INPUTS.every(input => {\n      if (input.signatures === undefined) return true;\n      return input.signatures.every(signature => {\n        if (!signature) return true;\n        const hashType = signatureHashType(signature);\n        const hashTypeMod = hashType & 0x1f;\n        if (hashTypeMod === transaction_1.Transaction.SIGHASH_NONE) return true;\n\n        if (hashTypeMod === transaction_1.Transaction.SIGHASH_SINGLE) {\n          // if SIGHASH_SINGLE is set, and nInputs > nOutputs\n          // some signatures would be invalidated by the addition\n          // of more outputs\n          return nInputs <= nOutputs;\n        }\n\n        return false;\n      });\n    });\n  }\n\n  __overMaximumFees(bytes) {\n    // not all inputs will have .value defined\n    const incoming = this.__INPUTS.reduce((a, x) => a + (x.value >>> 0), 0); // but all outputs do, and if we have any input value\n    // we can immediately determine if the outputs are too small\n\n\n    const outgoing = this.__TX.outs.reduce((a, x) => a + x.value, 0);\n\n    const fee = incoming - outgoing;\n    const feeRate = fee / bytes;\n    return feeRate > this.maximumFeeRate;\n  }\n\n}\n\nexports.TransactionBuilder = TransactionBuilder;\n\nfunction expandInput(scriptSig, witnessStack, type, scriptPubKey) {\n  if (scriptSig.length === 0 && witnessStack.length === 0) return {};\n\n  if (!type) {\n    let ssType = classify.input(scriptSig, true);\n    let wsType = classify.witness(witnessStack, true);\n    if (ssType === SCRIPT_TYPES.NONSTANDARD) ssType = undefined;\n    if (wsType === SCRIPT_TYPES.NONSTANDARD) wsType = undefined;\n    type = ssType || wsType;\n  }\n\n  switch (type) {\n    case SCRIPT_TYPES.P2WPKH:\n      {\n        const _payments$p2wpkh = payments.p2wpkh({\n          witness: witnessStack\n        }),\n              output = _payments$p2wpkh.output,\n              pubkey = _payments$p2wpkh.pubkey,\n              signature = _payments$p2wpkh.signature;\n\n        return {\n          prevOutScript: output,\n          prevOutType: SCRIPT_TYPES.P2WPKH,\n          pubkeys: [pubkey],\n          signatures: [signature]\n        };\n      }\n\n    case SCRIPT_TYPES.P2PKH:\n      {\n        const _payments$p2pkh = payments.p2pkh({\n          input: scriptSig\n        }),\n              output = _payments$p2pkh.output,\n              pubkey = _payments$p2pkh.pubkey,\n              signature = _payments$p2pkh.signature;\n\n        return {\n          prevOutScript: output,\n          prevOutType: SCRIPT_TYPES.P2PKH,\n          pubkeys: [pubkey],\n          signatures: [signature]\n        };\n      }\n\n    case SCRIPT_TYPES.P2PK:\n      {\n        const _payments$p2pk = payments.p2pk({\n          input: scriptSig\n        }),\n              signature = _payments$p2pk.signature;\n\n        return {\n          prevOutType: SCRIPT_TYPES.P2PK,\n          pubkeys: [undefined],\n          signatures: [signature]\n        };\n      }\n\n    case SCRIPT_TYPES.P2MS:\n      {\n        const _payments$p2ms = payments.p2ms({\n          input: scriptSig,\n          output: scriptPubKey\n        }, {\n          allowIncomplete: true\n        }),\n              m = _payments$p2ms.m,\n              pubkeys = _payments$p2ms.pubkeys,\n              signatures = _payments$p2ms.signatures;\n\n        return {\n          prevOutType: SCRIPT_TYPES.P2MS,\n          pubkeys,\n          signatures,\n          maxSignatures: m\n        };\n      }\n  }\n\n  if (type === SCRIPT_TYPES.P2SH) {\n    const _payments$p2sh = payments.p2sh({\n      input: scriptSig,\n      witness: witnessStack\n    }),\n          output = _payments$p2sh.output,\n          redeem = _payments$p2sh.redeem;\n\n    const outputType = classify.output(redeem.output);\n    const expanded = expandInput(redeem.input, redeem.witness, outputType, redeem.output);\n    if (!expanded.prevOutType) return {};\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      redeemScript: redeem.output,\n      redeemScriptType: expanded.prevOutType,\n      witnessScript: expanded.witnessScript,\n      witnessScriptType: expanded.witnessScriptType,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures\n    };\n  }\n\n  if (type === SCRIPT_TYPES.P2WSH) {\n    const _payments$p2wsh = payments.p2wsh({\n      input: scriptSig,\n      witness: witnessStack\n    }),\n          output = _payments$p2wsh.output,\n          redeem = _payments$p2wsh.redeem;\n\n    const outputType = classify.output(redeem.output);\n    let expanded;\n\n    if (outputType === SCRIPT_TYPES.P2WPKH) {\n      expanded = expandInput(redeem.input, redeem.witness, outputType);\n    } else {\n      expanded = expandInput(bscript.compile(redeem.witness), [], outputType, redeem.output);\n    }\n\n    if (!expanded.prevOutType) return {};\n    return {\n      prevOutScript: output,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      witnessScript: redeem.output,\n      witnessScriptType: expanded.prevOutType,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures\n    };\n  }\n\n  return {\n    prevOutType: SCRIPT_TYPES.NONSTANDARD,\n    prevOutScript: scriptSig\n  };\n} // could be done in expandInput, but requires the original Transaction for hashForSignature\n\n\nfunction fixMultisigOrder(input, transaction, vin) {\n  if (input.redeemScriptType !== SCRIPT_TYPES.P2MS || !input.redeemScript) return;\n  if (input.pubkeys.length === input.signatures.length) return;\n  const unmatched = input.signatures.concat();\n  input.signatures = input.pubkeys.map(pubKey => {\n    const keyPair = ECPair.fromPublicKey(pubKey);\n    let match; // check for a signature\n\n    unmatched.some((signature, i) => {\n      // skip if undefined || OP_0\n      if (!signature) return false; // TODO: avoid O(n) hashForSignature\n\n      const parsed = bscript.signature.decode(signature);\n      const hash = transaction.hashForSignature(vin, input.redeemScript, parsed.hashType); // skip if signature does not match pubKey\n\n      if (!keyPair.verify(hash, parsed.signature)) return false; // remove matched signature from unmatched\n\n      unmatched[i] = undefined;\n      match = signature;\n      return true;\n    });\n    return match;\n  });\n}\n\nfunction expandOutput(script, ourPubKey) {\n  typeforce(types.Buffer, script);\n  const type = classify.output(script);\n\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH:\n      {\n        if (!ourPubKey) return {\n          type\n        }; // does our hash160(pubKey) match the output scripts?\n\n        const pkh1 = payments.p2pkh({\n          output: script\n        }).hash;\n        const pkh2 = bcrypto.hash160(ourPubKey);\n        if (!pkh1.equals(pkh2)) return {\n          type\n        };\n        return {\n          type,\n          pubkeys: [ourPubKey],\n          signatures: [undefined]\n        };\n      }\n\n    case SCRIPT_TYPES.P2WPKH:\n      {\n        if (!ourPubKey) return {\n          type\n        }; // does our hash160(pubKey) match the output scripts?\n\n        const wpkh1 = payments.p2wpkh({\n          output: script\n        }).hash;\n        const wpkh2 = bcrypto.hash160(ourPubKey);\n        if (!wpkh1.equals(wpkh2)) return {\n          type\n        };\n        return {\n          type,\n          pubkeys: [ourPubKey],\n          signatures: [undefined]\n        };\n      }\n\n    case SCRIPT_TYPES.P2PK:\n      {\n        const p2pk = payments.p2pk({\n          output: script\n        });\n        return {\n          type,\n          pubkeys: [p2pk.pubkey],\n          signatures: [undefined]\n        };\n      }\n\n    case SCRIPT_TYPES.P2MS:\n      {\n        const p2ms = payments.p2ms({\n          output: script\n        });\n        return {\n          type,\n          pubkeys: p2ms.pubkeys,\n          signatures: p2ms.pubkeys.map(() => undefined),\n          maxSignatures: p2ms.m\n        };\n      }\n  }\n\n  return {\n    type\n  };\n}\n\nfunction prepareInput(input, ourPubKey, redeemScript, witnessScript) {\n  if (redeemScript && witnessScript) {\n    const p2wsh = payments.p2wsh({\n      redeem: {\n        output: witnessScript\n      }\n    });\n    const p2wshAlt = payments.p2wsh({\n      output: redeemScript\n    });\n    const p2sh = payments.p2sh({\n      redeem: {\n        output: redeemScript\n      }\n    });\n    const p2shAlt = payments.p2sh({\n      redeem: p2wsh\n    }); // enforces P2SH(P2WSH(...))\n\n    if (!p2wsh.hash.equals(p2wshAlt.hash)) throw new Error('Witness script inconsistent with prevOutScript');\n    if (!p2sh.hash.equals(p2shAlt.hash)) throw new Error('Redeem script inconsistent with prevOutScript');\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys) throw new Error(expanded.type + ' not supported as witnessScript (' + bscript.toASM(witnessScript) + ')');\n\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n\n    const signScript = witnessScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) throw new Error('P2SH(P2WSH(P2WPKH)) is a consensus failure');\n    return {\n      redeemScript,\n      redeemScriptType: SCRIPT_TYPES.P2WSH,\n      witnessScript,\n      witnessScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures\n    };\n  }\n\n  if (redeemScript) {\n    const p2sh = payments.p2sh({\n      redeem: {\n        output: redeemScript\n      }\n    });\n\n    if (input.prevOutScript) {\n      let p2shAlt;\n\n      try {\n        p2shAlt = payments.p2sh({\n          output: input.prevOutScript\n        });\n      } catch (e) {\n        throw new Error('PrevOutScript must be P2SH');\n      }\n\n      if (!p2sh.hash.equals(p2shAlt.hash)) throw new Error('Redeem script inconsistent with prevOutScript');\n    }\n\n    const expanded = expandOutput(p2sh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys) throw new Error(expanded.type + ' not supported as redeemScript (' + bscript.toASM(redeemScript) + ')');\n\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n\n    let signScript = redeemScript;\n\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({\n        pubkey: expanded.pubkeys[0]\n      }).output;\n    }\n\n    return {\n      redeemScript,\n      redeemScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2SH,\n      prevOutScript: p2sh.output,\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures\n    };\n  }\n\n  if (witnessScript) {\n    const p2wsh = payments.p2wsh({\n      redeem: {\n        output: witnessScript\n      }\n    });\n\n    if (input.prevOutScript) {\n      const p2wshAlt = payments.p2wsh({\n        output: input.prevOutScript\n      });\n      if (!p2wsh.hash.equals(p2wshAlt.hash)) throw new Error('Witness script inconsistent with prevOutScript');\n    }\n\n    const expanded = expandOutput(p2wsh.redeem.output, ourPubKey);\n    if (!expanded.pubkeys) throw new Error(expanded.type + ' not supported as witnessScript (' + bscript.toASM(witnessScript) + ')');\n\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n\n    const signScript = witnessScript;\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) throw new Error('P2WSH(P2WPKH) is a consensus failure');\n    return {\n      witnessScript,\n      witnessScriptType: expanded.type,\n      prevOutType: SCRIPT_TYPES.P2WSH,\n      prevOutScript: p2wsh.output,\n      hasWitness: true,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures\n    };\n  }\n\n  if (input.prevOutType && input.prevOutScript) {\n    // embedded scripts are not possible without extra information\n    if (input.prevOutType === SCRIPT_TYPES.P2SH) throw new Error('PrevOutScript is ' + input.prevOutType + ', requires redeemScript');\n    if (input.prevOutType === SCRIPT_TYPES.P2WSH) throw new Error('PrevOutScript is ' + input.prevOutType + ', requires witnessScript');\n    if (!input.prevOutScript) throw new Error('PrevOutScript is missing');\n    const expanded = expandOutput(input.prevOutScript, ourPubKey);\n    if (!expanded.pubkeys) throw new Error(expanded.type + ' not supported (' + bscript.toASM(input.prevOutScript) + ')');\n\n    if (input.signatures && input.signatures.some(x => x !== undefined)) {\n      expanded.signatures = input.signatures;\n    }\n\n    let signScript = input.prevOutScript;\n\n    if (expanded.type === SCRIPT_TYPES.P2WPKH) {\n      signScript = payments.p2pkh({\n        pubkey: expanded.pubkeys[0]\n      }).output;\n    }\n\n    return {\n      prevOutType: expanded.type,\n      prevOutScript: input.prevOutScript,\n      hasWitness: expanded.type === SCRIPT_TYPES.P2WPKH,\n      signScript,\n      signType: expanded.type,\n      pubkeys: expanded.pubkeys,\n      signatures: expanded.signatures,\n      maxSignatures: expanded.maxSignatures\n    };\n  }\n\n  const prevOutScript = payments.p2pkh({\n    pubkey: ourPubKey\n  }).output;\n  return {\n    prevOutType: SCRIPT_TYPES.P2PKH,\n    prevOutScript,\n    hasWitness: false,\n    signScript: prevOutScript,\n    signType: SCRIPT_TYPES.P2PKH,\n    pubkeys: [ourPubKey],\n    signatures: [undefined]\n  };\n}\n\nfunction build(type, input, allowIncomplete) {\n  const pubkeys = input.pubkeys || [];\n  let signatures = input.signatures || [];\n\n  switch (type) {\n    case SCRIPT_TYPES.P2PKH:\n      {\n        if (pubkeys.length === 0) break;\n        if (signatures.length === 0) break;\n        return payments.p2pkh({\n          pubkey: pubkeys[0],\n          signature: signatures[0]\n        });\n      }\n\n    case SCRIPT_TYPES.P2WPKH:\n      {\n        if (pubkeys.length === 0) break;\n        if (signatures.length === 0) break;\n        return payments.p2wpkh({\n          pubkey: pubkeys[0],\n          signature: signatures[0]\n        });\n      }\n\n    case SCRIPT_TYPES.P2PK:\n      {\n        if (pubkeys.length === 0) break;\n        if (signatures.length === 0) break;\n        return payments.p2pk({\n          signature: signatures[0]\n        });\n      }\n\n    case SCRIPT_TYPES.P2MS:\n      {\n        const m = input.maxSignatures;\n\n        if (allowIncomplete) {\n          signatures = signatures.map(x => x || script_1.OPS.OP_0);\n        } else {\n          signatures = signatures.filter(x => x);\n        } // if the transaction is not not complete (complete), or if signatures.length === m, validate\n        // otherwise, the number of OP_0's may be >= m, so don't validate (boo)\n\n\n        const validate = !allowIncomplete || m === signatures.length;\n        return payments.p2ms({\n          m,\n          pubkeys,\n          signatures\n        }, {\n          allowIncomplete,\n          validate\n        });\n      }\n\n    case SCRIPT_TYPES.P2SH:\n      {\n        const redeem = build(input.redeemScriptType, input, allowIncomplete);\n        if (!redeem) return;\n        return payments.p2sh({\n          redeem: {\n            output: redeem.output || input.redeemScript,\n            input: redeem.input,\n            witness: redeem.witness\n          }\n        });\n      }\n\n    case SCRIPT_TYPES.P2WSH:\n      {\n        const redeem = build(input.witnessScriptType, input, allowIncomplete);\n        if (!redeem) return;\n        return payments.p2wsh({\n          redeem: {\n            output: input.witnessScript,\n            input: redeem.input,\n            witness: redeem.witness\n          }\n        });\n      }\n  }\n}\n\nfunction canSign(input) {\n  return input.signScript !== undefined && input.signType !== undefined && input.pubkeys !== undefined && input.signatures !== undefined && input.signatures.length === input.pubkeys.length && input.pubkeys.length > 0 && (input.hasWitness === false || input.value !== undefined);\n}\n\nfunction signatureHashType(buffer) {\n  return buffer.readUInt8(buffer.length - 1);\n}\n\nfunction checkSignArgs(inputs, signParams) {\n  if (!PREVOUT_TYPES.has(signParams.prevOutScriptType)) {\n    throw new TypeError(\"Unknown prevOutScriptType \\\"\".concat(signParams.prevOutScriptType, \"\\\"\"));\n  }\n\n  tfMessage(typeforce.Number, signParams.vin, \"sign must include vin parameter as Number (input index)\");\n  tfMessage(types.Signer, signParams.keyPair, \"sign must include keyPair parameter as Signer interface\");\n  tfMessage(typeforce.maybe(typeforce.Number), signParams.hashType, \"sign hashType parameter must be a number\");\n  const prevOutType = (inputs[signParams.vin] || []).prevOutType;\n  const posType = signParams.prevOutScriptType;\n\n  switch (posType) {\n    case 'p2pkh':\n      if (prevOutType && prevOutType !== 'pubkeyhash') {\n        throw new TypeError(\"input #\".concat(signParams.vin, \" is not of type p2pkh: \").concat(prevOutType));\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, \"\".concat(posType, \" requires NO witnessScript\"));\n      tfMessage(typeforce.value(undefined), signParams.redeemScript, \"\".concat(posType, \" requires NO redeemScript\"));\n      tfMessage(typeforce.value(undefined), signParams.witnessValue, \"\".concat(posType, \" requires NO witnessValue\"));\n      break;\n\n    case 'p2pk':\n      if (prevOutType && prevOutType !== 'pubkey') {\n        throw new TypeError(\"input #\".concat(signParams.vin, \" is not of type p2pk: \").concat(prevOutType));\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, \"\".concat(posType, \" requires NO witnessScript\"));\n      tfMessage(typeforce.value(undefined), signParams.redeemScript, \"\".concat(posType, \" requires NO redeemScript\"));\n      tfMessage(typeforce.value(undefined), signParams.witnessValue, \"\".concat(posType, \" requires NO witnessValue\"));\n      break;\n\n    case 'p2wpkh':\n      if (prevOutType && prevOutType !== 'witnesspubkeyhash') {\n        throw new TypeError(\"input #\".concat(signParams.vin, \" is not of type p2wpkh: \").concat(prevOutType));\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, \"\".concat(posType, \" requires NO witnessScript\"));\n      tfMessage(typeforce.value(undefined), signParams.redeemScript, \"\".concat(posType, \" requires NO redeemScript\"));\n      tfMessage(types.Satoshi, signParams.witnessValue, \"\".concat(posType, \" requires witnessValue\"));\n      break;\n\n    case 'p2ms':\n      if (prevOutType && prevOutType !== 'multisig') {\n        throw new TypeError(\"input #\".concat(signParams.vin, \" is not of type p2ms: \").concat(prevOutType));\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, \"\".concat(posType, \" requires NO witnessScript\"));\n      tfMessage(typeforce.value(undefined), signParams.redeemScript, \"\".concat(posType, \" requires NO redeemScript\"));\n      tfMessage(typeforce.value(undefined), signParams.witnessValue, \"\".concat(posType, \" requires NO witnessValue\"));\n      break;\n\n    case 'p2sh-p2wpkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\"input #\".concat(signParams.vin, \" is not of type p2sh-p2wpkh: \").concat(prevOutType));\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, \"\".concat(posType, \" requires NO witnessScript\"));\n      tfMessage(typeforce.Buffer, signParams.redeemScript, \"\".concat(posType, \" requires redeemScript\"));\n      tfMessage(types.Satoshi, signParams.witnessValue, \"\".concat(posType, \" requires witnessValue\"));\n      break;\n\n    case 'p2sh-p2ms':\n    case 'p2sh-p2pk':\n    case 'p2sh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\"input #\".concat(signParams.vin, \" is not of type \").concat(posType, \": \").concat(prevOutType));\n      }\n\n      tfMessage(typeforce.value(undefined), signParams.witnessScript, \"\".concat(posType, \" requires NO witnessScript\"));\n      tfMessage(typeforce.Buffer, signParams.redeemScript, \"\".concat(posType, \" requires redeemScript\"));\n      tfMessage(typeforce.value(undefined), signParams.witnessValue, \"\".concat(posType, \" requires NO witnessValue\"));\n      break;\n\n    case 'p2wsh-p2ms':\n    case 'p2wsh-p2pk':\n    case 'p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'witnessscripthash') {\n        throw new TypeError(\"input #\".concat(signParams.vin, \" is not of type \").concat(posType, \": \").concat(prevOutType));\n      }\n\n      tfMessage(typeforce.Buffer, signParams.witnessScript, \"\".concat(posType, \" requires witnessScript\"));\n      tfMessage(typeforce.value(undefined), signParams.redeemScript, \"\".concat(posType, \" requires NO redeemScript\"));\n      tfMessage(types.Satoshi, signParams.witnessValue, \"\".concat(posType, \" requires witnessValue\"));\n      break;\n\n    case 'p2sh-p2wsh-p2ms':\n    case 'p2sh-p2wsh-p2pk':\n    case 'p2sh-p2wsh-p2pkh':\n      if (prevOutType && prevOutType !== 'scripthash') {\n        throw new TypeError(\"input #\".concat(signParams.vin, \" is not of type \").concat(posType, \": \").concat(prevOutType));\n      }\n\n      tfMessage(typeforce.Buffer, signParams.witnessScript, \"\".concat(posType, \" requires witnessScript\"));\n      tfMessage(typeforce.Buffer, signParams.redeemScript, \"\".concat(posType, \" requires witnessScript\"));\n      tfMessage(types.Satoshi, signParams.witnessValue, \"\".concat(posType, \" requires witnessScript\"));\n      break;\n  }\n}\n\nfunction trySign({\n  input,\n  ourPubKey,\n  keyPair,\n  signatureHash,\n  hashType,\n  useLowR\n}) {\n  // enforce in order signing of public keys\n  let signed = false;\n\n  for (const _ref of input.pubkeys.entries()) {\n    var _ref2 = _slicedToArray(_ref, 2);\n\n    const i = _ref2[0];\n    const pubKey = _ref2[1];\n    if (!ourPubKey.equals(pubKey)) continue;\n    if (input.signatures[i]) throw new Error('Signature already exists'); // TODO: add tests\n\n    if (ourPubKey.length !== 33 && input.hasWitness) {\n      throw new Error('BIP143 rejects uncompressed public keys in P2WPKH or P2WSH');\n    }\n\n    const signature = keyPair.sign(signatureHash, useLowR);\n    input.signatures[i] = bscript.signature.encode(signature, hashType);\n    signed = true;\n  }\n\n  if (!signed) throw new Error('Key pair cannot sign for this input');\n}\n\nfunction getSigningData(network, inputs, needsOutputs, tx, signParams, keyPair, redeemScript, hashType, witnessValue, witnessScript, useLowR) {\n  let vin;\n\n  if (typeof signParams === 'number') {\n    console.warn('DEPRECATED: TransactionBuilder sign method arguments ' + 'will change in v6, please use the TxbSignArg interface');\n    vin = signParams;\n  } else if (typeof signParams === 'object') {\n    checkSignArgs(inputs, signParams);\n    vin = signParams.vin;\n    keyPair = signParams.keyPair;\n    redeemScript = signParams.redeemScript;\n    hashType = signParams.hashType;\n    witnessValue = signParams.witnessValue;\n    witnessScript = signParams.witnessScript;\n  } else {\n    throw new TypeError('TransactionBuilder sign first arg must be TxbSignArg or number');\n  }\n\n  if (keyPair === undefined) {\n    throw new Error('sign requires keypair');\n  } // TODO: remove keyPair.network matching in 4.0.0\n\n\n  if (keyPair.network && keyPair.network !== network) throw new TypeError('Inconsistent network');\n  if (!inputs[vin]) throw new Error('No input at index: ' + vin);\n  hashType = hashType || transaction_1.Transaction.SIGHASH_ALL;\n  if (needsOutputs(hashType)) throw new Error('Transaction needs outputs');\n  const input = inputs[vin]; // if redeemScript was previously provided, enforce consistency\n\n  if (input.redeemScript !== undefined && redeemScript && !input.redeemScript.equals(redeemScript)) {\n    throw new Error('Inconsistent redeemScript');\n  }\n\n  const ourPubKey = keyPair.publicKey || keyPair.getPublicKey && keyPair.getPublicKey();\n\n  if (!canSign(input)) {\n    if (witnessValue !== undefined) {\n      if (input.value !== undefined && input.value !== witnessValue) throw new Error('Input did not match witnessValue');\n      typeforce(types.Satoshi, witnessValue);\n      input.value = witnessValue;\n    }\n\n    if (!canSign(input)) {\n      const prepared = prepareInput(input, ourPubKey, redeemScript, witnessScript); // updates inline\n\n      Object.assign(input, prepared);\n    }\n\n    if (!canSign(input)) throw Error(input.prevOutType + ' not supported');\n  } // ready to sign\n\n\n  let signatureHash;\n\n  if (input.hasWitness) {\n    signatureHash = tx.hashForWitnessV0(vin, input.signScript, input.value, hashType);\n  } else {\n    signatureHash = tx.hashForSignature(vin, input.signScript, hashType);\n  }\n\n  return {\n    input,\n    ourPubKey,\n    keyPair,\n    signatureHash,\n    hashType,\n    useLowR: !!useLowR\n  };\n}","map":null,"metadata":{},"sourceType":"script"}