{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n\nconst crypto = require(\"crypto\"); // @ts-ignore: Could not find a declaration file for module\n\n\nconst jsontokens_1 = require(\"jsontokens\");\n\nconst utils_1 = require(\"../utils\");\n\nconst fetchUtil_1 = require(\"../fetchUtil\");\n\nconst keys_1 = require(\"../keys\");\n\nconst logger_1 = require(\"../logger\");\n\nconst errors_1 = require(\"../errors\");\n/**\n * @ignore\n */\n\n\nexports.BLOCKSTACK_GAIA_HUB_LABEL = 'blockstack-gaia-hub-config';\n/**\n *\n * @param filename\n * @param contents\n * @param hubConfig\n * @param contentType\n *\n * @ignore\n */\n\nfunction uploadToGaiaHub(filename, contents, hubConfig, contentType = 'application/octet-stream') {\n  return __awaiter(this, void 0, void 0, function* () {\n    logger_1.Logger.debug(\"uploadToGaiaHub: uploading \".concat(filename, \" to \").concat(hubConfig.server));\n    const response = yield fetchUtil_1.fetchPrivate(\"\".concat(hubConfig.server, \"/store/\").concat(hubConfig.address, \"/\").concat(filename), {\n      method: 'POST',\n      headers: {\n        'Content-Type': contentType,\n        Authorization: \"bearer \".concat(hubConfig.token)\n      },\n      body: contents\n    });\n\n    if (!response.ok) {\n      throw new Error('Error when uploading to Gaia hub');\n    }\n\n    const responseText = yield response.text();\n    const responseJSON = JSON.parse(responseText);\n    return responseJSON.publicURL;\n  });\n}\n\nexports.uploadToGaiaHub = uploadToGaiaHub;\n\nfunction deleteFromGaiaHub(filename, hubConfig) {\n  return __awaiter(this, void 0, void 0, function* () {\n    logger_1.Logger.debug(\"deleteFromGaiaHub: deleting \".concat(filename, \" from \").concat(hubConfig.server));\n    const response = yield fetch(\"\".concat(hubConfig.server, \"/delete/\").concat(hubConfig.address, \"/\").concat(filename), {\n      method: 'DELETE',\n      headers: {\n        Authorization: \"bearer \".concat(hubConfig.token)\n      }\n    });\n\n    if (!response.ok) {\n      let responseMsg = '';\n\n      try {\n        responseMsg = yield response.text();\n      } catch (error) {\n        logger_1.Logger.debug(\"Error getting bad http response text: \".concat(error));\n      }\n\n      const errorMsg = 'Error deleting file from Gaia hub: ' + \"\".concat(response.status, \" \").concat(response.statusText, \": \").concat(responseMsg);\n      logger_1.Logger.error(errorMsg);\n\n      if (response.status === 404) {\n        throw new errors_1.FileNotFound(errorMsg);\n      } else {\n        throw new Error(errorMsg);\n      }\n    }\n  });\n}\n\nexports.deleteFromGaiaHub = deleteFromGaiaHub;\n/**\n *\n * @param filename\n * @param hubConfig\n *\n * @ignore\n */\n\nfunction getFullReadUrl(filename, hubConfig) {\n  return Promise.resolve(\"\".concat(hubConfig.url_prefix).concat(hubConfig.address, \"/\").concat(filename));\n}\n\nexports.getFullReadUrl = getFullReadUrl;\n/**\n *\n * @param challengeText\n * @param signerKeyHex\n *\n * @ignore\n */\n\nfunction makeLegacyAuthToken(challengeText, signerKeyHex) {\n  // only sign specific legacy auth challenges.\n  let parsedChallenge;\n\n  try {\n    parsedChallenge = JSON.parse(challengeText);\n  } catch (err) {\n    throw new Error('Failed in parsing legacy challenge text from the gaia hub.');\n  }\n\n  if (parsedChallenge[0] === 'gaiahub' && parsedChallenge[3] === 'blockstack_storage_please_sign') {\n    const signer = utils_1.hexStringToECPair(signerKeyHex + (signerKeyHex.length === 64 ? '01' : ''));\n    const digest = bitcoinjs_lib_1.crypto.sha256(Buffer.from(challengeText));\n    const signatureBuffer = signer.sign(digest);\n    const signatureWithHash = bitcoinjs_lib_1.script.signature.encode(signatureBuffer, bitcoinjs_lib_1.Transaction.SIGHASH_NONE); // We only want the DER encoding so remove the sighash version byte at the end.\n    // See: https://github.com/bitcoinjs/bitcoinjs-lib/issues/1241#issuecomment-428062912\n\n    const signature = signatureWithHash.toString('hex').slice(0, -2);\n    const publickey = keys_1.getPublicKeyFromPrivate(signerKeyHex);\n    const token = Buffer.from(JSON.stringify({\n      publickey,\n      signature\n    })).toString('base64');\n    return token;\n  } else {\n    throw new Error('Failed to connect to legacy gaia hub. If you operate this hub, please update.');\n  }\n}\n/**\n *\n * @param hubInfo\n * @param signerKeyHex\n * @param hubUrl\n * @param associationToken\n *\n * @ignore\n */\n\n\nfunction makeV1GaiaAuthToken(hubInfo, signerKeyHex, hubUrl, associationToken) {\n  const challengeText = hubInfo.challenge_text;\n  const handlesV1Auth = hubInfo.latest_auth_version && parseInt(hubInfo.latest_auth_version.slice(1), 10) >= 1;\n  const iss = keys_1.getPublicKeyFromPrivate(signerKeyHex);\n\n  if (!handlesV1Auth) {\n    return makeLegacyAuthToken(challengeText, signerKeyHex);\n  }\n\n  const salt = crypto.randomBytes(16).toString('hex');\n  const payload = {\n    gaiaChallenge: challengeText,\n    hubUrl,\n    iss,\n    salt,\n    associationToken\n  };\n  const token = new jsontokens_1.TokenSigner('ES256K', signerKeyHex).sign(payload);\n  return \"v1:\".concat(token);\n}\n/**\n *\n * @ignore\n */\n\n\nfunction connectToGaiaHub(gaiaHubUrl, challengeSignerHex, associationToken) {\n  return __awaiter(this, void 0, void 0, function* () {\n    logger_1.Logger.debug(\"connectToGaiaHub: \".concat(gaiaHubUrl, \"/hub_info\"));\n    const response = yield fetchUtil_1.fetchPrivate(\"\".concat(gaiaHubUrl, \"/hub_info\"));\n    const hubInfo = yield response.json();\n    const readURL = hubInfo.read_url_prefix;\n    const token = makeV1GaiaAuthToken(hubInfo, challengeSignerHex, gaiaHubUrl, associationToken);\n    const address = utils_1.ecPairToAddress(utils_1.hexStringToECPair(challengeSignerHex + (challengeSignerHex.length === 64 ? '01' : '')));\n    return {\n      url_prefix: readURL,\n      address,\n      token,\n      server: gaiaHubUrl\n    };\n  });\n}\n\nexports.connectToGaiaHub = connectToGaiaHub;\n/**\n *\n * @param gaiaHubUrl\n * @param appPrivateKey\n *\n * @ignore\n */\n\nfunction getBucketUrl(gaiaHubUrl, appPrivateKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const challengeSigner = bitcoinjs_lib_1.ECPair.fromPrivateKey(Buffer.from(appPrivateKey, 'hex'));\n    const response = yield fetchUtil_1.fetchPrivate(\"\".concat(gaiaHubUrl, \"/hub_info\"));\n    const responseText = yield response.text();\n    const responseJSON = JSON.parse(responseText);\n    const readURL = responseJSON.read_url_prefix;\n    const address = utils_1.ecPairToAddress(challengeSigner);\n    const bucketUrl = \"\".concat(readURL).concat(address, \"/\");\n    return bucketUrl;\n  });\n}\n\nexports.getBucketUrl = getBucketUrl;","map":null,"metadata":{},"sourceType":"script"}