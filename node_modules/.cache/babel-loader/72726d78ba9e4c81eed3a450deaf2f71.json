{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst crypto = require(\"crypto\");\n\nconst bitcoinjs_lib_1 = require(\"bitcoinjs-lib\");\n\nconst bip39 = require(\"bip39\");\n\nconst utils_1 = require(\"./utils\");\n\nconst wallet_1 = require(\"./encryption/wallet\");\n\nconst APPS_NODE_INDEX = 0;\nconst IDENTITY_KEYCHAIN = 888;\nconst BLOCKSTACK_ON_BITCOIN = 0;\nconst BITCOIN_BIP_44_PURPOSE = 44;\nconst BITCOIN_COIN_TYPE = 0;\nconst BITCOIN_ACCOUNT_INDEX = 0;\nconst EXTERNAL_ADDRESS = 'EXTERNAL_ADDRESS';\nconst CHANGE_ADDRESS = 'CHANGE_ADDRESS';\n/**\n *\n * @ignore\n */\n\nfunction hashCode(string) {\n  let hash = 0;\n  if (string.length === 0) return hash;\n\n  for (let i = 0; i < string.length; i++) {\n    const character = string.charCodeAt(i);\n    hash = (hash << 5) - hash + character;\n    hash &= hash;\n  }\n\n  return hash & 0x7fffffff;\n}\n/**\n *\n * @ignore\n */\n\n\nfunction getNodePrivateKey(node) {\n  return utils_1.ecPairToHexString(bitcoinjs_lib_1.ECPair.fromPrivateKey(node.privateKey));\n}\n/**\n *\n * @ignore\n */\n\n\nfunction getNodePublicKey(node) {\n  return node.publicKey.toString('hex');\n}\n/**\n * The `BlockstackWallet` class manages the hierarchical derivation\n * paths for a standard Blockstack client wallet. This includes paths\n * for Bitcoin payment address, Blockstack identity addresses, Blockstack\n * application specific addresses.\n *\n * @ignore\n */\n\n\nclass BlockstackWallet {\n  constructor(rootNode) {\n    this.rootNode = rootNode;\n  }\n\n  toBase58() {\n    return this.rootNode.toBase58();\n  }\n  /**\n   * Initialize a Blockstack wallet from a seed buffer\n   * @param {Buffer} seed - the input seed for initializing the root node\n   *  of the hierarchical wallet\n   * @return {BlockstackWallet} the constructed wallet\n   */\n\n\n  static fromSeedBuffer(seed) {\n    return new BlockstackWallet(bitcoinjs_lib_1.bip32.fromSeed(seed));\n  }\n  /**\n   * Initialize a Blockstack wallet from a base58 string\n   * @param {string} keychain - the Base58 string used to initialize\n   *  the root node of the hierarchical wallet\n   * @return {BlockstackWallet} the constructed wallet\n   */\n\n\n  static fromBase58(keychain) {\n    return new BlockstackWallet(bitcoinjs_lib_1.bip32.fromBase58(keychain));\n  }\n  /**\n   * Initialize a blockstack wallet from an encrypted phrase & password. Throws\n   * if the password is incorrect. Supports all formats of Blockstack phrases.\n   * @param {string} data - The encrypted phrase as a hex-encoded string\n   * @param {string} password - The plain password\n   * @return {Promise<BlockstackWallet>} the constructed wallet\n   *\n   * @ignore\n   */\n\n\n  static fromEncryptedMnemonic(data, password) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const mnemonic = yield wallet_1.decryptMnemonic(data, password);\n        const seed = yield bip39.mnemonicToSeed(mnemonic);\n        return new BlockstackWallet(bitcoinjs_lib_1.bip32.fromSeed(seed));\n      } catch (err) {\n        if (err.message && err.message.startsWith('bad header;')) {\n          throw new Error('Incorrect password');\n        } else {\n          throw err;\n        }\n      }\n    });\n  }\n  /**\n   * Generate a BIP-39 12 word mnemonic\n   * @return {Promise<string>} space-separated 12 word phrase\n   */\n\n\n  static generateMnemonic() {\n    return bip39.generateMnemonic(128, crypto.randomBytes);\n  }\n  /**\n   * Encrypt a mnemonic phrase with a password\n   * @param {string} mnemonic - Raw mnemonic phrase\n   * @param {string} password - Password to encrypt mnemonic with\n   * @return {Promise<string>} Hex-encoded encrypted mnemonic\n   *\n   */\n\n\n  static encryptMnemonic(mnemonic, password) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const encryptedBuffer = yield wallet_1.encryptMnemonic(mnemonic, password);\n      return encryptedBuffer.toString('hex');\n    });\n  }\n\n  getIdentityPrivateKeychain() {\n    return this.rootNode.deriveHardened(IDENTITY_KEYCHAIN).deriveHardened(BLOCKSTACK_ON_BITCOIN);\n  }\n\n  getBitcoinPrivateKeychain() {\n    return this.rootNode.deriveHardened(BITCOIN_BIP_44_PURPOSE).deriveHardened(BITCOIN_COIN_TYPE).deriveHardened(BITCOIN_ACCOUNT_INDEX);\n  }\n\n  getBitcoinNode(addressIndex, chainType = EXTERNAL_ADDRESS) {\n    return BlockstackWallet.getNodeFromBitcoinKeychain(this.getBitcoinPrivateKeychain().toBase58(), addressIndex, chainType);\n  }\n\n  getIdentityAddressNode(identityIndex) {\n    const identityPrivateKeychain = this.getIdentityPrivateKeychain();\n    return identityPrivateKeychain.deriveHardened(identityIndex);\n  }\n\n  static getAppsNode(identityNode) {\n    return identityNode.deriveHardened(APPS_NODE_INDEX);\n  }\n  /**\n   * Get a salt for use with creating application specific addresses\n   * @return {String} the salt\n   */\n\n\n  getIdentitySalt() {\n    const identityPrivateKeychain = this.getIdentityPrivateKeychain();\n    const publicKeyHex = getNodePublicKey(identityPrivateKeychain);\n    return crypto.createHash('sha256').update(publicKeyHex).digest('hex');\n  }\n  /**\n   * Get a bitcoin receive address at a given index\n   * @param {number} addressIndex - the index of the address\n   * @return {String} address\n   */\n\n\n  getBitcoinAddress(addressIndex) {\n    return BlockstackWallet.getAddressFromBIP32Node(this.getBitcoinNode(addressIndex));\n  }\n  /**\n   * Get the private key hex-string for a given bitcoin receive address\n   * @param {number} addressIndex - the index of the address\n   * @return {String} the hex-string. this will be either 64\n   * characters long to denote an uncompressed bitcoin address, or 66\n   * characters long for a compressed bitcoin address.\n   */\n\n\n  getBitcoinPrivateKey(addressIndex) {\n    return getNodePrivateKey(this.getBitcoinNode(addressIndex));\n  }\n  /**\n   * Get the root node for the bitcoin public keychain\n   * @return {String} base58-encoding of the public node\n   */\n\n\n  getBitcoinPublicKeychain() {\n    return this.getBitcoinPrivateKeychain().neutered();\n  }\n  /**\n   * Get the root node for the identity public keychain\n   * @return {String} base58-encoding of the public node\n   */\n\n\n  getIdentityPublicKeychain() {\n    return this.getIdentityPrivateKeychain().neutered();\n  }\n\n  static getNodeFromBitcoinKeychain(keychainBase58, addressIndex, chainType = EXTERNAL_ADDRESS) {\n    let chain;\n\n    if (chainType === EXTERNAL_ADDRESS) {\n      chain = 0;\n    } else if (chainType === CHANGE_ADDRESS) {\n      chain = 1;\n    } else {\n      throw new Error('Invalid chain type');\n    }\n\n    const keychain = bitcoinjs_lib_1.bip32.fromBase58(keychainBase58);\n    return keychain.derive(chain).derive(addressIndex);\n  }\n  /**\n   * Get a bitcoin address given a base-58 encoded bitcoin node\n   * (usually called the account node)\n   * @param {String} keychainBase58 - base58-encoding of the node\n   * @param {number} addressIndex - index of the address to get\n   * @param {String} chainType - either 'EXTERNAL_ADDRESS' (for a\n   * \"receive\" address) or 'CHANGE_ADDRESS'\n   * @return {String} the address\n   */\n\n\n  static getAddressFromBitcoinKeychain(keychainBase58, addressIndex, chainType = EXTERNAL_ADDRESS) {\n    return BlockstackWallet.getAddressFromBIP32Node(BlockstackWallet.getNodeFromBitcoinKeychain(keychainBase58, addressIndex, chainType));\n  }\n  /**\n   * Get a ECDSA private key hex-string for an application-specific\n   *  address.\n   * @param {String} appsNodeKey - the base58-encoded private key for\n   * applications node (the `appsNodeKey` return in getIdentityKeyPair())\n   * @param {String} salt - a string, used to salt the\n   * application-specific addresses\n   * @param {String} appDomain - the appDomain to generate a key for\n   * @return {String} the private key hex-string. this will be a 64\n   * character string\n   */\n\n\n  static getLegacyAppPrivateKey(appsNodeKey, salt, appDomain) {\n    const hash = crypto.createHash('sha256').update(\"\".concat(appDomain).concat(salt)).digest('hex');\n    const appIndex = hashCode(hash);\n    const appNode = bitcoinjs_lib_1.bip32.fromBase58(appsNodeKey).deriveHardened(appIndex);\n    return getNodePrivateKey(appNode).slice(0, 64);\n  }\n\n  static getAddressFromBIP32Node(node) {\n    return bitcoinjs_lib_1.payments.p2pkh({\n      pubkey: node.publicKey\n    }).address;\n  }\n  /**\n   * Get a ECDSA private key hex-string for an application-specific\n   *  address.\n   * @param {String} appsNodeKey - the base58-encoded private key for\n   * applications node (the `appsNodeKey` return in getIdentityKeyPair())\n   * @param {String} salt - a string, used to salt the\n   * application-specific addresses\n   * @param {String} appDomain - the appDomain to generate a key for\n   * @return {String} the private key hex-string. this will be a 64\n   * character string\n   */\n\n\n  static getAppPrivateKey(appsNodeKey, salt, appDomain) {\n    const hash = crypto.createHash('sha256').update(\"\".concat(appDomain).concat(salt)).digest('hex');\n    const appIndexHexes = []; // note: there's hardcoded numbers here, precisely because I want this\n    //   code to be very specific to the derivation paths we expect.\n\n    if (hash.length !== 64) {\n      throw new Error(\"Unexpected app-domain hash length of \".concat(hash.length));\n    }\n\n    for (let i = 0; i < 11; i++) {\n      // split the hash into 3-byte chunks\n      // because child nodes can only be up to 2^31,\n      // and we shouldn't deal in partial bytes.\n      appIndexHexes.push(hash.slice(i * 6, i * 6 + 6));\n    }\n\n    let appNode = bitcoinjs_lib_1.bip32.fromBase58(appsNodeKey);\n    appIndexHexes.forEach(hex => {\n      if (hex.length > 6) {\n        throw new Error('Invalid hex string length');\n      }\n\n      appNode = appNode.deriveHardened(parseInt(hex, 16));\n    });\n    return getNodePrivateKey(appNode).slice(0, 64);\n  }\n  /**\n   * Get the keypair information for a given identity index. This\n   * information is used to obtain the private key for an identity address\n   * and derive application specific keys for that address.\n   * @param {number} addressIndex - the identity index\n   * @param {boolean} alwaysUncompressed - if true, always return a\n   *   private-key hex string corresponding to the uncompressed address\n   * @return {Object} an IdentityKeyPair type object with keys:\n   *   .key {String} - the private key hex-string\n   *   .keyID {String} - the public key hex-string\n   *   .address {String} - the identity address\n   *   .appsNodeKey {String} - the base-58 encoding of the applications node\n   *   .salt {String} - the salt used for creating app-specific addresses\n   */\n\n\n  getIdentityKeyPair(addressIndex, alwaysUncompressed = false) {\n    const identityNode = this.getIdentityAddressNode(addressIndex);\n    const address = BlockstackWallet.getAddressFromBIP32Node(identityNode);\n    let identityKey = getNodePrivateKey(identityNode);\n\n    if (alwaysUncompressed && identityKey.length === 66) {\n      identityKey = identityKey.slice(0, 64);\n    }\n\n    const identityKeyID = getNodePublicKey(identityNode);\n    const appsNodeKey = BlockstackWallet.getAppsNode(identityNode).toBase58();\n    const salt = this.getIdentitySalt();\n    const keyPair = {\n      key: identityKey,\n      keyID: identityKeyID,\n      address,\n      appsNodeKey,\n      salt\n    };\n    return keyPair;\n  }\n\n}\n\nexports.BlockstackWallet = BlockstackWallet;","map":null,"metadata":{},"sourceType":"script"}