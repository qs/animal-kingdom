{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst elliptic_1 = require(\"elliptic\");\n\nconst crypto_1 = require(\"crypto\");\n\nconst key_encoder_1 = __importDefault(require(\"key-encoder\"));\n\nconst ecdsa_sig_formatter_1 = require(\"ecdsa-sig-formatter\");\n\nconst errors_1 = require(\"../errors\");\n\nclass SECP256K1Client {\n  constructor() {}\n\n  static createHash(signingInput) {\n    return crypto_1.createHash('sha256').update(signingInput).digest();\n  }\n\n  static loadPrivateKey(rawPrivateKey) {\n    if (rawPrivateKey.length === 66) {\n      rawPrivateKey = rawPrivateKey.slice(0, 64);\n    }\n\n    return SECP256K1Client.ec.keyFromPrivate(rawPrivateKey);\n  }\n\n  static loadPublicKey(rawPublicKey) {\n    return SECP256K1Client.ec.keyFromPublic(rawPublicKey, 'hex');\n  }\n\n  static encodePublicKey(publicKey, originalFormat, destinationFormat) {\n    return SECP256K1Client.keyEncoder.encodePublic(publicKey, originalFormat, destinationFormat);\n  }\n\n  static derivePublicKey(privateKey, compressed = true) {\n    if (typeof privateKey !== 'string') {\n      throw Error('private key must be a string');\n    }\n\n    if (!/^[0-9A-F]+$/i.test(privateKey)) {\n      throw Error('private key must be a hex string');\n    }\n\n    if (privateKey.length == 66) {\n      privateKey = privateKey.slice(0, 64);\n    } else if (privateKey.length <= 64) {// do nothing\n    } else {\n      throw Error('private key must be 66 characters or less');\n    }\n\n    const keypair = SECP256K1Client.ec.keyFromPrivate(privateKey);\n    return keypair.getPublic(compressed, 'hex');\n  }\n\n  static signHash(signingInputHash, rawPrivateKey, format = 'jose') {\n    // make sure the required parameters are provided\n    if (!(signingInputHash && rawPrivateKey)) {\n      throw new errors_1.MissingParametersError('a signing input hash and private key are all required');\n    } // prepare the private key\n\n\n    const privateKeyObject = SECP256K1Client.loadPrivateKey(rawPrivateKey); // calculate the signature\n\n    const signatureObject = privateKeyObject.sign(signingInputHash);\n    const derSignature = Buffer.from(signatureObject.toDER());\n\n    if (format === 'der') {\n      return derSignature.toString('hex');\n    } else if (format === 'jose') {\n      // return the JOSE-formatted signature\n      return ecdsa_sig_formatter_1.derToJose(derSignature, 'ES256');\n    } else {\n      throw Error('Invalid signature format');\n    }\n  }\n\n  static loadSignature(joseSignature) {\n    // create and return the DER-formatted signature buffer\n    return ecdsa_sig_formatter_1.joseToDer(joseSignature, 'ES256');\n  }\n\n  static verifyHash(signingInputHash, derSignatureBuffer, rawPublicKey) {\n    // make sure the required parameters are provided\n    if (!(signingInputHash && derSignatureBuffer && rawPublicKey)) {\n      throw new errors_1.MissingParametersError('a signing input hash, der signature, and public key are all required');\n    } // prepare the public key\n\n\n    const publicKeyObject = SECP256K1Client.loadPublicKey(rawPublicKey); // verify the token\n\n    return publicKeyObject.verify(signingInputHash, derSignatureBuffer);\n  }\n\n}\n\nSECP256K1Client.ec = new elliptic_1.ec('secp256k1');\nSECP256K1Client.algorithmName = 'ES256K';\nSECP256K1Client.keyEncoder = new key_encoder_1.default({\n  curveParameters: [1, 3, 132, 0, 10],\n  privatePEMOptions: {\n    label: 'EC PRIVATE KEY'\n  },\n  publicPEMOptions: {\n    label: 'PUBLIC KEY'\n  },\n  curve: SECP256K1Client.ec\n});\nexports.SECP256K1Client = SECP256K1Client;","map":null,"metadata":{},"sourceType":"script"}