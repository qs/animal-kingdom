{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst bufferutils_1 = require('./bufferutils');\n\nconst bcrypto = require('./crypto');\n\nconst transaction_1 = require('./transaction');\n\nconst types = require('./types');\n\nconst fastMerkleRoot = require('merkle-lib/fastRoot');\n\nconst typeforce = require('typeforce');\n\nconst varuint = require('varuint-bitcoin');\n\nconst errorMerkleNoTxes = new TypeError('Cannot compute merkle root for zero transactions');\nconst errorWitnessNotSegwit = new TypeError('Cannot compute witness commit for non-segwit block');\n\nclass Block {\n  constructor() {\n    this.version = 1;\n    this.prevHash = undefined;\n    this.merkleRoot = undefined;\n    this.timestamp = 0;\n    this.witnessCommit = undefined;\n    this.bits = 0;\n    this.nonce = 0;\n    this.transactions = undefined;\n  }\n\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    let offset = 0;\n\n    const readSlice = n => {\n      offset += n;\n      return buffer.slice(offset - n, offset);\n    };\n\n    const readUInt32 = () => {\n      const i = buffer.readUInt32LE(offset);\n      offset += 4;\n      return i;\n    };\n\n    const readInt32 = () => {\n      const i = buffer.readInt32LE(offset);\n      offset += 4;\n      return i;\n    };\n\n    const block = new Block();\n    block.version = readInt32();\n    block.prevHash = readSlice(32);\n    block.merkleRoot = readSlice(32);\n    block.timestamp = readUInt32();\n    block.bits = readUInt32();\n    block.nonce = readUInt32();\n    if (buffer.length === 80) return block;\n\n    const readVarInt = () => {\n      const vi = varuint.decode(buffer, offset);\n      offset += varuint.decode.bytes;\n      return vi;\n    };\n\n    const readTransaction = () => {\n      const tx = transaction_1.Transaction.fromBuffer(buffer.slice(offset), true);\n      offset += tx.byteLength();\n      return tx;\n    };\n\n    const nTransactions = readVarInt();\n    block.transactions = [];\n\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n\n    const witnessCommit = block.getWitnessCommit(); // This Block contains a witness commit\n\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n\n  static fromHex(hex) {\n    return Block.fromBuffer(Buffer.from(hex, 'hex'));\n  }\n\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = Buffer.alloc(32, 0);\n    target.writeUIntBE(mantissa, 29 - exponent, 3);\n    return target;\n  }\n\n  static calculateMerkleRoot(transactions, forWitness) {\n    typeforce([{\n      getHash: types.Function\n    }], transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions)) throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction => transaction.getHash(forWitness));\n    const rootHash = fastMerkleRoot(hashes, bcrypto.hash256);\n    return forWitness ? bcrypto.hash256(Buffer.concat([rootHash, transactions[0].ins[0].witness[0]])) : rootHash;\n  }\n\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null; // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n\n    const witnessCommits = this.transactions[0].outs.filter(out => out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex'))).map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null; // Use the commit with the highest output (should only be one though)\n\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Buffer && result.length === 32)) return null;\n    return result;\n  }\n\n  hasWitnessCommit() {\n    if (this.witnessCommit instanceof Buffer && this.witnessCommit.length === 32) return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n\n  byteLength(headersOnly) {\n    if (headersOnly || !this.transactions) return 80;\n    return 80 + varuint.encodingLength(this.transactions.length) + this.transactions.reduce((a, x) => a + x.byteLength(), 0);\n  }\n\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n\n  getId() {\n    return bufferutils_1.reverseBuffer(this.getHash()).toString('hex');\n  }\n\n  getUTCDate() {\n    const date = new Date(0); // epoch\n\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  } // TODO: buffer, offset compatibility\n\n\n  toBuffer(headersOnly) {\n    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n    let offset = 0;\n\n    const writeSlice = slice => {\n      slice.copy(buffer, offset);\n      offset += slice.length;\n    };\n\n    const writeInt32 = i => {\n      buffer.writeInt32LE(i, offset);\n      offset += 4;\n    };\n\n    const writeUInt32 = i => {\n      buffer.writeUInt32LE(i, offset);\n      offset += 4;\n    };\n\n    writeInt32(this.version);\n    writeSlice(this.prevHash);\n    writeSlice(this.merkleRoot);\n    writeUInt32(this.timestamp);\n    writeUInt32(this.bits);\n    writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    varuint.encode(this.transactions.length, buffer, offset);\n    offset += varuint.encode.bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n\n      tx.toBuffer(buffer, offset);\n      offset += txSize;\n    });\n    return buffer;\n  }\n\n  toHex(headersOnly) {\n    return this.toBuffer(headersOnly).toString('hex');\n  }\n\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return this.__checkMerkleRoot() && (hasWitnessCommit ? this.__checkWitnessCommit() : true);\n  }\n\n  checkProofOfWork() {\n    const hash = bufferutils_1.reverseBuffer(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return hash.compare(target) <= 0;\n  }\n\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return this.merkleRoot.compare(actualMerkleRoot) === 0;\n  }\n\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(this.transactions, true);\n    return this.witnessCommit.compare(actualWitnessCommit) === 0;\n  }\n\n}\n\nexports.Block = Block;\n\nfunction txesHaveWitnessCommit(transactions) {\n  return transactions instanceof Array && transactions[0] && transactions[0].ins && transactions[0].ins instanceof Array && transactions[0].ins[0] && transactions[0].ins[0].witness && transactions[0].ins[0].witness instanceof Array && transactions[0].ins[0].witness.length > 0;\n}\n\nfunction anyTxHasWitness(transactions) {\n  return transactions instanceof Array && transactions.some(tx => typeof tx === 'object' && tx.ins instanceof Array && tx.ins.some(input => typeof input === 'object' && input.witness instanceof Array && input.witness.length > 0));\n}","map":null,"metadata":{},"sourceType":"script"}