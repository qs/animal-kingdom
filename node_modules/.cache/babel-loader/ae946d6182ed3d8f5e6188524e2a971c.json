{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nrequire(\"cross-fetch/polyfill\");\n\nconst serviceUtils_1 = require(\"./serviceUtils\");\n\nconst fetchUtil_1 = require(\"../../fetchUtil\");\n/**\n * @ignore\n */\n\n\nclass Service {\n  static validateProof(proof, ownerAddress, name = null) {\n    let proofUrl;\n    return Promise.resolve().then(() => {\n      proofUrl = this.getProofUrl(proof);\n      return fetchUtil_1.fetchPrivate(proofUrl);\n    }).then(res => {\n      if (res.status !== 200) {\n        throw new Error(\"Proof url \".concat(proofUrl, \" returned unexpected http status \").concat(res.status, \".\\n              Unable to validate proof.\"));\n      }\n\n      return res.text();\n    }).then(text => {\n      // Validate identity in provided proof body/tags if required\n      if (this.shouldValidateIdentityInBody() && proof.identifier !== this.getProofIdentity(text)) {\n        return proof;\n      }\n\n      const proofText = this.getProofStatement(text);\n      proof.valid = serviceUtils_1.containsValidProofStatement(proofText, name) || serviceUtils_1.containsValidAddressProofStatement(proofText, ownerAddress);\n      return proof;\n    }).catch(error => {\n      console.error(error);\n      proof.valid = false;\n      return proof;\n    });\n  }\n\n  static getBaseUrls() {\n    return [];\n  }\n\n  static getProofIdentity(searchText) {\n    return searchText;\n  }\n\n  static getProofStatement(searchText) {\n    return searchText;\n  }\n\n  static shouldValidateIdentityInBody() {\n    return false;\n  }\n\n  static prefixScheme(proofUrl) {\n    if (!proofUrl.startsWith('https://') && !proofUrl.startsWith('http://')) {\n      return \"https://\".concat(proofUrl);\n    } else if (proofUrl.startsWith('http://')) {\n      return proofUrl.replace('http://', 'https://');\n    } else {\n      return proofUrl;\n    }\n  }\n\n  static getProofUrl(proof) {\n    const baseUrls = this.getBaseUrls();\n    let proofUrl = proof.proof_url.toLowerCase();\n    proofUrl = this.prefixScheme(proofUrl);\n\n    for (let i = 0; i < baseUrls.length; i++) {\n      const requiredPrefix = \"\".concat(baseUrls[i]).concat(proof.identifier).toLowerCase();\n\n      if (proofUrl.startsWith(requiredPrefix)) {\n        return proofUrl;\n      }\n    }\n\n    throw new Error(\"Proof url \".concat(proof.proof_url, \" is not valid for service \").concat(proof.service));\n  }\n\n}\n\nexports.Service = Service;","map":null,"metadata":{},"sourceType":"script"}