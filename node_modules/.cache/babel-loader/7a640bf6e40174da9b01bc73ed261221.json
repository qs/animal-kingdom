{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst crypto = require(\"crypto\");\n\nconst bip39 = require(\"bip39\");\n\nconst triplesec = require(\"triplesec\");\n/**\n * Encrypt a raw mnemonic phrase to be password protected\n * @param {string} phrase - Raw mnemonic phrase\n * @param {string} password - Password to encrypt mnemonic with\n * @return {Promise<Buffer>} The encrypted phrase\n * @private\n * @ignore\n * */\n\n\nfunction encryptMnemonic(phrase, password) {\n  return Promise.resolve().then(() => {\n    // must be bip39 mnemonic\n    if (!bip39.validateMnemonic(phrase)) {\n      throw new Error('Not a valid bip39 nmemonic');\n    } // normalize plaintext to fixed length byte string\n\n\n    const plaintextNormalized = Buffer.from(bip39.mnemonicToEntropy(phrase), 'hex'); // AES-128-CBC with SHA256 HMAC\n\n    const salt = crypto.randomBytes(16);\n    const keysAndIV = crypto.pbkdf2Sync(password, salt, 100000, 48, 'sha512');\n    const encKey = keysAndIV.slice(0, 16);\n    const macKey = keysAndIV.slice(16, 32);\n    const iv = keysAndIV.slice(32, 48);\n    const cipher = crypto.createCipheriv('aes-128-cbc', encKey, iv);\n    let cipherText = cipher.update(plaintextNormalized).toString('hex');\n    cipherText += cipher.final().toString('hex');\n    const hmacPayload = Buffer.concat([salt, Buffer.from(cipherText, 'hex')]);\n    const hmac = crypto.createHmac('sha256', macKey);\n    hmac.write(hmacPayload);\n    const hmacDigest = hmac.digest();\n    const payload = Buffer.concat([salt, hmacDigest, Buffer.from(cipherText, 'hex')]);\n    return payload;\n  });\n}\n\nexports.encryptMnemonic = encryptMnemonic; // Used to distinguish bad password during decrypt vs invalid format\n\nclass PasswordError extends Error {}\n/**\n* @ignore\n*/\n\n\nfunction decryptMnemonicBuffer(dataBuffer, password) {\n  return Promise.resolve().then(() => {\n    const salt = dataBuffer.slice(0, 16);\n    const hmacSig = dataBuffer.slice(16, 48); // 32 bytes\n\n    const cipherText = dataBuffer.slice(48);\n    const hmacPayload = Buffer.concat([salt, cipherText]);\n    const keysAndIV = crypto.pbkdf2Sync(password, salt, 100000, 48, 'sha512');\n    const encKey = keysAndIV.slice(0, 16);\n    const macKey = keysAndIV.slice(16, 32);\n    const iv = keysAndIV.slice(32, 48);\n    const decipher = crypto.createDecipheriv('aes-128-cbc', encKey, iv);\n    let plaintext = decipher.update(cipherText).toString('hex');\n    plaintext += decipher.final().toString('hex');\n    const hmac = crypto.createHmac('sha256', macKey);\n    hmac.write(hmacPayload);\n    const hmacDigest = hmac.digest(); // hash both hmacSig and hmacDigest so string comparison time\n    // is uncorrelated to the ciphertext\n\n    const hmacSigHash = crypto.createHash('sha256').update(hmacSig).digest().toString('hex');\n    const hmacDigestHash = crypto.createHash('sha256').update(hmacDigest).digest().toString('hex');\n\n    if (hmacSigHash !== hmacDigestHash) {\n      // not authentic\n      throw new PasswordError('Wrong password (HMAC mismatch)');\n    }\n\n    const mnemonic = bip39.entropyToMnemonic(plaintext);\n\n    if (!bip39.validateMnemonic(mnemonic)) {\n      throw new PasswordError('Wrong password (invalid plaintext)');\n    }\n\n    return mnemonic;\n  });\n}\n/**\n * Decrypt legacy triplesec keys\n * @param {Buffer} dataBuffer - The encrypted key\n * @param {String} password - Password for data\n * @return {Promise<Buffer>} Decrypted seed\n * @private\n * @ignore\n */\n\n\nfunction decryptLegacy(dataBuffer, password) {\n  return new Promise((resolve, reject) => {\n    triplesec.decrypt({\n      key: Buffer.from(password),\n      data: dataBuffer\n    }, (err, plaintextBuffer) => {\n      if (!err) {\n        resolve(plaintextBuffer);\n      } else {\n        reject(err);\n      }\n    });\n  });\n}\n/**\n * Encrypt a raw mnemonic phrase with a password\n * @param {string | Buffer} data - Buffer or hex-encoded string of the encrypted mnemonic\n * @param {string} password - Password for data\n * @return {Promise<string>} the raw mnemonic phrase\n * @private\n * @ignore\n */\n\n\nfunction decryptMnemonic(data, password) {\n  const dataBuffer = Buffer.isBuffer(data) ? data : Buffer.from(data, 'hex');\n  return decryptMnemonicBuffer(dataBuffer, password).catch(err => {\n    // If it was a password error, don't even bother with legacy\n    if (err instanceof PasswordError) {\n      throw err;\n    }\n\n    return decryptLegacy(dataBuffer, password).then(data => data.toString());\n  });\n}\n\nexports.decryptMnemonic = decryptMnemonic;","map":null,"metadata":{},"sourceType":"script"}