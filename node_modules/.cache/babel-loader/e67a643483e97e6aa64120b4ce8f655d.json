{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst range = n => [...Array(n).keys()];\n\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error('Decode Error: could not decode bip32Derivation with key 0x' + keyVal.key.toString('hex'));\n    }\n\n    if (!(keyVal.key.length === 34 || keyVal.key.length === 66) || ![2, 3, 4].includes(keyVal.key[1])) {\n      throw new Error('Decode Error: bip32Derivation has invalid pubkey in key 0x' + keyVal.key.toString('hex'));\n    }\n\n    if (keyVal.value.length / 4 % 1 !== 0) {\n      throw new Error('Decode Error: Input BIP32_DERIVATION value length should be multiple of 4');\n    }\n\n    const pubkey = keyVal.key.slice(1);\n    const data = {\n      masterFingerprint: keyVal.value.slice(0, 4),\n      pubkey,\n      path: 'm'\n    };\n\n    for (const i of range(keyVal.value.length / 4 - 1)) {\n      const val = keyVal.value.readUInt32LE(i * 4 + 4);\n      const isHard = !!(val & 0x80000000);\n      const idx = val & 0x7fffffff;\n      data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n    }\n\n    return data;\n  }\n\n  function encode(data) {\n    const head = Buffer.from([TYPE_BYTE]);\n    const key = Buffer.concat([head, data.pubkey]);\n    const splitPath = data.path.split('/');\n    const value = Buffer.allocUnsafe(splitPath.length * 4);\n    data.masterFingerprint.copy(value, 0);\n    let offset = 4;\n    splitPath.slice(1).forEach(level => {\n      const isHard = level.slice(-1) === \"'\";\n      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n      if (isHard) num += 0x80000000;\n      value.writeUInt32LE(num, offset);\n      offset += 4;\n    });\n    return {\n      key,\n      value\n    };\n  }\n\n  const expected = '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';\n\n  function check(data) {\n    return Buffer.isBuffer(data.pubkey) && Buffer.isBuffer(data.masterFingerprint) && typeof data.path === 'string' && [33, 65].includes(data.pubkey.length) && [2, 3, 4].includes(data.pubkey[0]) && data.masterFingerprint.length === 4;\n  }\n\n  function canAddToArray(array, item, dupeSet) {\n    const dupeString = item.pubkey.toString('hex');\n    if (dupeSet.has(dupeString)) return false;\n    dupeSet.add(dupeString);\n    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n  }\n\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray\n  };\n}\n\nexports.makeConverter = makeConverter;","map":null,"metadata":{},"sourceType":"script"}