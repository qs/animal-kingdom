{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst hub_1 = require(\"./hub\");\n\nexports.connectToGaiaHub = hub_1.connectToGaiaHub;\nexports.uploadToGaiaHub = hub_1.uploadToGaiaHub;\nexports.BLOCKSTACK_GAIA_HUB_LABEL = hub_1.BLOCKSTACK_GAIA_HUB_LABEL; // export { type GaiaHubConfig } from './hub'\n\nconst ec_1 = require(\"../encryption/ec\");\n\nconst keys_1 = require(\"../keys\");\n\nconst profileLookup_1 = require(\"../profiles/profileLookup\");\n\nconst errors_1 = require(\"../errors\");\n\nconst logger_1 = require(\"../logger\");\n\nconst userSession_1 = require(\"../auth/userSession\");\n\nconst utils_1 = require(\"../utils\");\n\nconst fetchUtil_1 = require(\"../fetchUtil\");\n\nconst SIGNATURE_FILE_SUFFIX = '.sig';\n/**\n * Fetch the public read URL of a user file for the specified app.\n * @param {String} path - the path to the file to read\n * @param {String} username - The Blockstack ID of the user to look up\n * @param {String} appOrigin - The app origin\n * @param {String} [zoneFileLookupURL=null] - The URL\n * to use for zonefile lookup. If falsey, this will use the\n * blockstack.js's [[getNameInfo]] function instead.\n * @return {Promise<string>} that resolves to the public read URL of the file\n * or rejects with an error\n */\n\nfunction getUserAppFileUrl(path, username, appOrigin, zoneFileLookupURL) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const profile = yield profileLookup_1.lookupProfile(username, zoneFileLookupURL);\n    let bucketUrl = null;\n\n    if (profile.hasOwnProperty('apps')) {\n      if (profile.apps.hasOwnProperty(appOrigin)) {\n        const url = profile.apps[appOrigin];\n        const bucket = url.replace(/\\/?(\\?|#|$)/, '/$1');\n        bucketUrl = \"\".concat(bucket).concat(path);\n      }\n    }\n\n    return bucketUrl;\n  });\n}\n\nexports.getUserAppFileUrl = getUserAppFileUrl;\n/**\n *\n *\n * @deprecated\n * #### v19 Use [[UserSession.encryptContent]].\n *\n * Encrypts the data provided with the app public key.\n * @param {String|Buffer} content - data to encrypt\n * @param {Object} [options=null] - options object\n * @param {String} options.publicKey - the hex string of the ECDSA public\n * key to use for encryption. If not provided, will use user's appPublicKey.\n * @return {String} Stringified ciphertext object\n */\n\nfunction encryptContent(content, options, caller) {\n  const opts = Object.assign({}, options);\n\n  if (!opts.publicKey) {\n    const privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n    opts.publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n  }\n\n  const cipherObject = ec_1.encryptECIES(opts.publicKey, content);\n  return JSON.stringify(cipherObject);\n}\n\nexports.encryptContent = encryptContent;\n/**\n *\n * @deprecated\n * #### v19 Use [[UserSession.decryptContent]].\n *\n * Decrypts data encrypted with `encryptContent` with the\n * transit private key.\n * @param {String|Buffer} content - encrypted content.\n * @param {Object} [options=null] - options object\n * @param {String} options.privateKey - the hex string of the ECDSA private\n * key to use for decryption. If not provided, will use user's appPrivateKey.\n * @return {String|Buffer} decrypted content.\n */\n\nfunction decryptContent(content, options, caller) {\n  const opts = Object.assign({}, options);\n\n  if (!opts.privateKey) {\n    opts.privateKey = (caller || new userSession_1.UserSession()).loadUserData().appPrivateKey;\n  }\n\n  try {\n    const cipherObject = JSON.parse(content);\n    return ec_1.decryptECIES(opts.privateKey, cipherObject);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      throw new Error('Failed to parse encrypted content JSON. The content may not ' + 'be encrypted. If using getFile, try passing { decrypt: false }.');\n    } else {\n      throw err;\n    }\n  }\n}\n\nexports.decryptContent = decryptContent;\n/* Get the gaia address used for servicing multiplayer reads for the given\n * (username, app) pair.\n * @private\n * @ignore\n */\n\nfunction getGaiaAddress(app, username, zoneFileLookupURL, caller) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const opts = normalizeOptions({\n      app,\n      username\n    }, caller);\n    let fileUrl;\n\n    if (username) {\n      fileUrl = yield getUserAppFileUrl('/', opts.username, opts.app, zoneFileLookupURL);\n    } else {\n      if (!caller) {\n        caller = new userSession_1.UserSession();\n      }\n\n      const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n      fileUrl = yield hub_1.getFullReadUrl('/', gaiaHubConfig);\n    }\n\n    const matches = fileUrl.match(/([13][a-km-zA-HJ-NP-Z0-9]{26,35})/);\n\n    if (!matches) {\n      throw new Error('Failed to parse gaia address');\n    }\n\n    return matches[matches.length - 1];\n  });\n}\n/**\n * @param {Object} [options=null] - options object\n * @param {String} options.username - the Blockstack ID to lookup for multi-player storage\n * @param {String} options.app - the app to lookup for multi-player storage -\n * defaults to current origin\n *\n * @ignore\n */\n\n\nfunction normalizeOptions(options, caller) {\n  const opts = Object.assign({}, options);\n\n  if (opts.username) {\n    if (!opts.app) {\n      const appConfig = (caller || new userSession_1.UserSession()).appConfig;\n\n      if (!appConfig) {\n        throw new errors_1.InvalidStateError('Missing AppConfig');\n      }\n\n      opts.app = appConfig.appDomain;\n    }\n  }\n\n  return opts;\n}\n/**\n * @deprecated\n * #### v19 Use [[UserSession.getFileUrl]] instead.\n *\n * @param {String} path - the path to the file to read\n * @returns {Promise<string>} that resolves to the URL or rejects with an error\n */\n\n\nfunction getFileUrl(path, options, caller) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const opts = normalizeOptions(options, caller);\n    let readUrl;\n\n    if (opts.username) {\n      readUrl = yield getUserAppFileUrl(path, opts.username, opts.app, opts.zoneFileLookupURL);\n    } else {\n      const gaiaHubConfig = yield (caller || new userSession_1.UserSession()).getOrSetLocalGaiaHubConnection();\n      readUrl = yield hub_1.getFullReadUrl(path, gaiaHubConfig);\n    }\n\n    if (!readUrl) {\n      throw new Error('Missing readURL');\n    } else {\n      return readUrl;\n    }\n  });\n}\n\nexports.getFileUrl = getFileUrl;\n/* Handle fetching the contents from a given path. Handles both\n *  multi-player reads and reads from own storage.\n * @private\n * @ignore\n */\n\nfunction getFileContents(path, app, username, zoneFileLookupURL, forceText, caller) {\n  return Promise.resolve().then(() => {\n    const opts = {\n      app,\n      username,\n      zoneFileLookupURL\n    };\n    return getFileUrl(path, opts, caller);\n  }).then(readUrl => fetchUtil_1.fetchPrivate(readUrl)).then(response => {\n    if (response.status !== 200) {\n      if (response.status === 404) {\n        logger_1.Logger.debug(\"getFile \".concat(path, \" returned 404, returning null\"));\n        return null;\n      } else {\n        throw new Error(\"getFile \".concat(path, \" failed with HTTP status \").concat(response.status));\n      }\n    }\n\n    const contentType = response.headers.get('Content-Type');\n\n    if (forceText || contentType === null || contentType.startsWith('text') || contentType === 'application/json') {\n      return response.text();\n    } else {\n      return response.arrayBuffer();\n    }\n  });\n}\n/* Handle fetching an unencrypted file, its associated signature\n *  and then validate it. Handles both multi-player reads and reads\n *  from own storage.\n * @private\n * @ignore\n */\n\n\nfunction getFileSignedUnencrypted(path, opt, caller) {\n  // future optimization note:\n  //    in the case of _multi-player_ reads, this does a lot of excess\n  //    profile lookups to figure out where to read files\n  //    do browsers cache all these requests if Content-Cache is set?\n  return Promise.all([getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, false, caller), getFileContents(\"\".concat(path).concat(SIGNATURE_FILE_SUFFIX), opt.app, opt.username, opt.zoneFileLookupURL, true, caller), getGaiaAddress(opt.app, opt.username, opt.zoneFileLookupURL, caller)]).then(([fileContents, signatureContents, gaiaAddress]) => {\n    if (!fileContents) {\n      return fileContents;\n    }\n\n    if (!gaiaAddress) {\n      throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: ' + \"\".concat(path));\n    }\n\n    if (!signatureContents || typeof signatureContents !== 'string') {\n      throw new errors_1.SignatureVerificationError('Failed to obtain signature for file: ' + \"\".concat(path, \" -- looked in \").concat(path).concat(SIGNATURE_FILE_SUFFIX));\n    }\n\n    let signature;\n    let publicKey;\n\n    try {\n      const sigObject = JSON.parse(signatureContents);\n      signature = sigObject.signature;\n      publicKey = sigObject.publicKey;\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        throw new Error('Failed to parse signature content JSON ' + \"(path: \".concat(path).concat(SIGNATURE_FILE_SUFFIX, \")\") + ' The content may be corrupted.');\n      } else {\n        throw err;\n      }\n    }\n\n    const signerAddress = keys_1.publicKeyToAddress(publicKey);\n\n    if (gaiaAddress !== signerAddress) {\n      throw new errors_1.SignatureVerificationError(\"Signer pubkey address (\".concat(signerAddress, \") doesn't\") + \" match gaia address (\".concat(gaiaAddress, \")\"));\n    } else if (!ec_1.verifyECDSA(fileContents, publicKey, signature)) {\n      throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature: ' + \"path: \".concat(path, \", signature: \").concat(path).concat(SIGNATURE_FILE_SUFFIX));\n    } else {\n      return fileContents;\n    }\n  });\n}\n/* Handle signature verification and decryption for contents which are\n *  expected to be signed and encrypted. This works for single and\n *  multiplayer reads. In the case of multiplayer reads, it uses the\n *  gaia address for verification of the claimed public key.\n * @private\n * @ignore\n */\n\n\nfunction handleSignedEncryptedContents(caller, path, storedContents, app, username, zoneFileLookupURL) {\n  const appPrivateKey = caller.loadUserData().appPrivateKey;\n  const appPublicKey = keys_1.getPublicKeyFromPrivate(appPrivateKey);\n  let addressPromise;\n\n  if (username) {\n    addressPromise = getGaiaAddress(app, username, zoneFileLookupURL, caller);\n  } else {\n    const address = keys_1.publicKeyToAddress(appPublicKey);\n    addressPromise = Promise.resolve(address);\n  }\n\n  return addressPromise.then(address => {\n    if (!address) {\n      throw new errors_1.SignatureVerificationError('Failed to get gaia address for verification of: ' + \"\".concat(path));\n    }\n\n    let sigObject;\n\n    try {\n      sigObject = JSON.parse(storedContents);\n    } catch (err) {\n      if (err instanceof SyntaxError) {\n        throw new Error('Failed to parse encrypted, signed content JSON. The content may not ' + 'be encrypted. If using getFile, try passing' + ' { verify: false, decrypt: false }.');\n      } else {\n        throw err;\n      }\n    }\n\n    const signature = sigObject.signature;\n    const signerPublicKey = sigObject.publicKey;\n    const cipherText = sigObject.cipherText;\n    const signerAddress = keys_1.publicKeyToAddress(signerPublicKey);\n\n    if (!signerPublicKey || !cipherText || !signature) {\n      throw new errors_1.SignatureVerificationError('Failed to get signature verification data from file:' + \" \".concat(path));\n    } else if (signerAddress !== address) {\n      throw new errors_1.SignatureVerificationError(\"Signer pubkey address (\".concat(signerAddress, \") doesn't\") + \" match gaia address (\".concat(address, \")\"));\n    } else if (!ec_1.verifyECDSA(cipherText, signerPublicKey, signature)) {\n      throw new errors_1.SignatureVerificationError('Contents do not match ECDSA signature in file:' + \" \".concat(path));\n    } else {\n      return caller.decryptContent(cipherText);\n    }\n  });\n}\n/**\n * Retrieves the specified file from the app's data store.\n * @param {String} path - the path to the file to read\n * @returns {Promise} that resolves to the raw data in the file\n * or rejects with an error\n */\n\n\nfunction getFile(path, options, caller) {\n  const defaults = {\n    decrypt: true,\n    verify: false,\n    username: null,\n    app: utils_1.getGlobalObject('location', {\n      returnEmptyObject: true\n    }).origin,\n    zoneFileLookupURL: null\n  };\n  const opt = Object.assign({}, defaults, options);\n\n  if (!caller) {\n    caller = new userSession_1.UserSession();\n  } // in the case of signature verification, but no\n  //  encryption expected, need to fetch _two_ files.\n\n\n  if (opt.verify && !opt.decrypt) {\n    return getFileSignedUnencrypted(path, opt, caller);\n  }\n\n  return getFileContents(path, opt.app, opt.username, opt.zoneFileLookupURL, !!opt.decrypt, caller).then(storedContents => {\n    if (storedContents === null) {\n      return storedContents;\n    } else if (opt.decrypt && !opt.verify) {\n      if (typeof storedContents !== 'string') {\n        throw new Error('Expected to get back a string for the cipherText');\n      }\n\n      return caller.decryptContent(storedContents);\n    } else if (opt.decrypt && opt.verify) {\n      if (typeof storedContents !== 'string') {\n        throw new Error('Expected to get back a string for the cipherText');\n      }\n\n      return handleSignedEncryptedContents(caller, path, storedContents, opt.app, opt.username, opt.zoneFileLookupURL);\n    } else if (!opt.verify && !opt.decrypt) {\n      return storedContents;\n    } else {\n      throw new Error('Should be unreachable.');\n    }\n  });\n}\n\nexports.getFile = getFile;\n/**\n * Stores the data provided in the app's data store to to the file specified.\n * @param {String} path - the path to store the data in\n * @param {String|Buffer} content - the data to store in the file\n * @return {Promise} that resolves if the operation succeed and rejects\n * if it failed\n */\n\nfunction putFile(path, content, options, caller) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const defaults = {\n      encrypt: true,\n      sign: false,\n      contentType: ''\n    };\n    const opt = Object.assign({}, defaults, options);\n    let contentType = opt.contentType;\n\n    if (!contentType) {\n      contentType = typeof content === 'string' ? 'text/plain; charset=utf-8' : 'application/octet-stream';\n    }\n\n    if (!caller) {\n      caller = new userSession_1.UserSession();\n    } // First, let's figure out if we need to get public/private keys,\n    //  or if they were passed in\n\n\n    let privateKey = '';\n    let publicKey = '';\n\n    if (opt.sign) {\n      if (typeof opt.sign === 'string') {\n        privateKey = opt.sign;\n      } else {\n        privateKey = caller.loadUserData().appPrivateKey;\n      }\n    }\n\n    if (opt.encrypt) {\n      if (typeof opt.encrypt === 'string') {\n        publicKey = opt.encrypt;\n      } else {\n        if (!privateKey) {\n          privateKey = caller.loadUserData().appPrivateKey;\n        }\n\n        publicKey = keys_1.getPublicKeyFromPrivate(privateKey);\n      }\n    } // In the case of signing, but *not* encrypting,\n    //   we perform two uploads. So the control-flow\n    //   here will return there.\n\n\n    if (!opt.encrypt && opt.sign) {\n      const signatureObject = ec_1.signECDSA(privateKey, content);\n      const signatureContent = JSON.stringify(signatureObject);\n      const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n\n      try {\n        const fileUrls = yield Promise.all([hub_1.uploadToGaiaHub(path, content, gaiaHubConfig, contentType), hub_1.uploadToGaiaHub(\"\".concat(path).concat(SIGNATURE_FILE_SUFFIX), signatureContent, gaiaHubConfig, 'application/json')]);\n        return fileUrls[0];\n      } catch (error) {\n        const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n        const fileUrls = yield Promise.all([hub_1.uploadToGaiaHub(path, content, freshHubConfig, contentType), hub_1.uploadToGaiaHub(\"\".concat(path).concat(SIGNATURE_FILE_SUFFIX), signatureContent, freshHubConfig, 'application/json')]);\n        return fileUrls[0];\n      }\n    } // In all other cases, we only need one upload.\n\n\n    if (opt.encrypt && !opt.sign) {\n      content = encryptContent(content, {\n        publicKey\n      });\n      contentType = 'application/json';\n    } else if (opt.encrypt && opt.sign) {\n      const cipherText = encryptContent(content, {\n        publicKey\n      });\n      const signatureObject = ec_1.signECDSA(privateKey, cipherText);\n      const signedCipherObject = {\n        signature: signatureObject.signature,\n        publicKey: signatureObject.publicKey,\n        cipherText\n      };\n      content = JSON.stringify(signedCipherObject);\n      contentType = 'application/json';\n    }\n\n    const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n\n    try {\n      return yield hub_1.uploadToGaiaHub(path, content, gaiaHubConfig, contentType);\n    } catch (error) {\n      const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n      const file = yield hub_1.uploadToGaiaHub(path, content, freshHubConfig, contentType);\n      return file;\n    }\n  });\n}\n\nexports.putFile = putFile;\n/**\n * Deletes the specified file from the app's data store.\n * @param path - The path to the file to delete.\n * @param options - Optional options object.\n * @param options.wasSigned - Set to true if the file was originally signed\n * in order for the corresponding signature file to also be deleted.\n * @returns Resolves when the file has been removed or rejects with an error.\n */\n\nfunction deleteFile(path, options, caller) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (!caller) {\n      caller = new userSession_1.UserSession();\n    }\n\n    const gaiaHubConfig = yield caller.getOrSetLocalGaiaHubConnection();\n    const opts = Object.assign({}, options);\n\n    if (opts.wasSigned) {\n      // If signed, delete both the content file and the .sig file\n      try {\n        yield hub_1.deleteFromGaiaHub(path, gaiaHubConfig);\n        yield hub_1.deleteFromGaiaHub(\"\".concat(path).concat(SIGNATURE_FILE_SUFFIX), gaiaHubConfig);\n      } catch (error) {\n        const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n        yield hub_1.deleteFromGaiaHub(path, freshHubConfig);\n        yield hub_1.deleteFromGaiaHub(\"\".concat(path).concat(SIGNATURE_FILE_SUFFIX), gaiaHubConfig);\n      }\n    } else {\n      try {\n        yield hub_1.deleteFromGaiaHub(path, gaiaHubConfig);\n      } catch (error) {\n        const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n        yield hub_1.deleteFromGaiaHub(path, freshHubConfig);\n      }\n    }\n  });\n}\n\nexports.deleteFile = deleteFile;\n/**\n * Get the app storage bucket URL\n * @param {String} gaiaHubUrl - the gaia hub URL\n * @param {String} appPrivateKey - the app private key used to generate the app address\n * @returns {Promise} That resolves to the URL of the app index file\n * or rejects if it fails\n */\n\nfunction getAppBucketUrl(gaiaHubUrl, appPrivateKey) {\n  return hub_1.getBucketUrl(gaiaHubUrl, appPrivateKey);\n}\n\nexports.getAppBucketUrl = getAppBucketUrl;\n/**\n * Loop over the list of files in a Gaia hub, and run a callback on each entry.\n * Not meant to be called by external clients.\n * @param {GaiaHubConfig} hubConfig - the Gaia hub config\n * @param {String | null} page - the page ID\n * @param {number} callCount - the loop count\n * @param {number} fileCount - the number of files listed so far\n * @param {function} callback - the callback to invoke on each file.  If it returns a falsey\n *  value, then the loop stops.  If it returns a truthy value, the loop continues.\n * @returns {Promise} that resolves to the number of files listed.\n * @private\n * @ignore\n */\n\nfunction listFilesLoop(caller, hubConfig, page, callCount, fileCount, callback) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (callCount > 65536) {\n      // this is ridiculously huge, and probably indicates\n      // a faulty Gaia hub anyway (e.g. on that serves endless data)\n      throw new Error('Too many entries to list');\n    }\n\n    hubConfig = hubConfig || (yield caller.getOrSetLocalGaiaHubConnection());\n    let response;\n\n    try {\n      const pageRequest = JSON.stringify({\n        page\n      });\n      const fetchOptions = {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'Content-Length': \"\".concat(pageRequest.length),\n          Authorization: \"bearer \".concat(hubConfig.token)\n        },\n        body: pageRequest\n      };\n      response = yield fetchUtil_1.fetchPrivate(\"\".concat(hubConfig.server, \"/list-files/\").concat(hubConfig.address), fetchOptions);\n\n      if (!response.ok) {\n        throw new Error(\"listFiles failed with HTTP status \".concat(response.status));\n      }\n    } catch (error) {\n      // If error occurs on the first call, perform a gaia re-connection and retry.\n      // Same logic as other gaia requests (putFile, getFile, etc).\n      if (callCount === 0) {\n        const freshHubConfig = yield caller.setLocalGaiaHubConnection();\n        return listFilesLoop(caller, freshHubConfig, page, callCount + 1, 0, callback);\n      }\n\n      throw error;\n    }\n\n    const responseText = yield response.text();\n    const responseJSON = JSON.parse(responseText);\n    const entries = responseJSON.entries;\n    const nextPage = responseJSON.page;\n\n    if (entries === null || entries === undefined) {\n      // indicates a misbehaving Gaia hub or a misbehaving driver\n      // (i.e. the data is malformed)\n      throw new Error('Bad listFiles response: no entries');\n    }\n\n    for (let i = 0; i < entries.length; i++) {\n      const rc = callback(entries[i]);\n\n      if (!rc) {\n        // callback indicates that we're done\n        return fileCount + i;\n      }\n    }\n\n    if (nextPage && entries.length > 0) {\n      // keep going -- have more entries\n      return listFilesLoop(caller, hubConfig, nextPage, callCount + 1, fileCount + entries.length, callback);\n    } else {\n      // no more entries -- end of data\n      return fileCount + entries.length;\n    }\n  });\n}\n/**\n * List the set of files in this application's Gaia storage bucket.\n * @param {function} callback - a callback to invoke on each named file that\n * returns `true` to continue the listing operation or `false` to end it\n * @return {Promise} that resolves to the number of files listed\n */\n\n\nfunction listFiles(callback, caller) {\n  caller = caller || new userSession_1.UserSession();\n  return listFilesLoop(caller, null, null, 0, 0, callback);\n}\n\nexports.listFiles = listFiles;","map":null,"metadata":{},"sourceType":"script"}