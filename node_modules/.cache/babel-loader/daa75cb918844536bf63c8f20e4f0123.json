{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst crypto = require(\"./crypto\");\n\nconst bs58check = require('bs58check');\n\nconst ecc = require('tiny-secp256k1');\n\nconst typeforce = require('typeforce');\n\nconst wif = require('wif');\n\nconst UINT256_TYPE = typeforce.BufferN(32);\nconst NETWORK_TYPE = typeforce.compile({\n  wif: typeforce.UInt8,\n  bip32: {\n    public: typeforce.UInt32,\n    private: typeforce.UInt32\n  }\n});\nconst BITCOIN = {\n  wif: 0x80,\n  bip32: {\n    public: 0x0488b21e,\n    private: 0x0488ade4\n  }\n};\nconst HIGHEST_BIT = 0x80000000;\nconst UINT31_MAX = Math.pow(2, 31) - 1;\n\nfunction BIP32Path(value) {\n  return typeforce.String(value) && value.match(/^(m\\/)?(\\d+'?\\/)*\\d+'?$/) !== null;\n}\n\nfunction UInt31(value) {\n  return typeforce.UInt32(value) && value <= UINT31_MAX;\n}\n\nclass BIP32 {\n  constructor(__D, __Q, chainCode, network, __DEPTH = 0, __INDEX = 0, __PARENT_FINGERPRINT = 0x00000000) {\n    this.__D = __D;\n    this.__Q = __Q;\n    this.chainCode = chainCode;\n    this.network = network;\n    this.__DEPTH = __DEPTH;\n    this.__INDEX = __INDEX;\n    this.__PARENT_FINGERPRINT = __PARENT_FINGERPRINT;\n    typeforce(NETWORK_TYPE, network);\n    this.lowR = false;\n  }\n\n  get depth() {\n    return this.__DEPTH;\n  }\n\n  get index() {\n    return this.__INDEX;\n  }\n\n  get parentFingerprint() {\n    return this.__PARENT_FINGERPRINT;\n  }\n\n  get publicKey() {\n    if (this.__Q === undefined) this.__Q = ecc.pointFromScalar(this.__D, true);\n    return this.__Q;\n  }\n\n  get privateKey() {\n    return this.__D;\n  }\n\n  get identifier() {\n    return crypto.hash160(this.publicKey);\n  }\n\n  get fingerprint() {\n    return this.identifier.slice(0, 4);\n  } // Private === not neutered\n  // Public === neutered\n\n\n  isNeutered() {\n    return this.__D === undefined;\n  }\n\n  neutered() {\n    return fromPublicKeyLocal(this.publicKey, this.chainCode, this.network, this.depth, this.index, this.parentFingerprint);\n  }\n\n  toBase58() {\n    const network = this.network;\n    const version = !this.isNeutered() ? network.bip32.private : network.bip32.public;\n    const buffer = Buffer.allocUnsafe(78); // 4 bytes: version bytes\n\n    buffer.writeUInt32BE(version, 0); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ....\n\n    buffer.writeUInt8(this.depth, 4); // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n\n    buffer.writeUInt32BE(this.parentFingerprint, 5); // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n    // This is encoded in big endian. (0x00000000 if master key)\n\n    buffer.writeUInt32BE(this.index, 9); // 32 bytes: the chain code\n\n    this.chainCode.copy(buffer, 13); // 33 bytes: the public key or private key data\n\n    if (!this.isNeutered()) {\n      // 0x00 + k for private keys\n      buffer.writeUInt8(0, 45);\n      this.privateKey.copy(buffer, 46); // 33 bytes: the public key\n    } else {\n      // X9.62 encoding for public keys\n      this.publicKey.copy(buffer, 45);\n    }\n\n    return bs58check.encode(buffer);\n  }\n\n  toWIF() {\n    if (!this.privateKey) throw new TypeError('Missing private key');\n    return wif.encode(this.network.wif, this.privateKey, true);\n  } // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#child-key-derivation-ckd-functions\n\n\n  derive(index) {\n    typeforce(typeforce.UInt32, index);\n    const isHardened = index >= HIGHEST_BIT;\n    const data = Buffer.allocUnsafe(37); // Hardened child\n\n    if (isHardened) {\n      if (this.isNeutered()) throw new TypeError('Missing private key for hardened child key'); // data = 0x00 || ser256(kpar) || ser32(index)\n\n      data[0] = 0x00;\n      this.privateKey.copy(data, 1);\n      data.writeUInt32BE(index, 33); // Normal child\n    } else {\n      // data = serP(point(kpar)) || ser32(index)\n      //      = serP(Kpar) || ser32(index)\n      this.publicKey.copy(data, 0);\n      data.writeUInt32BE(index, 33);\n    }\n\n    const I = crypto.hmacSHA512(this.chainCode, data);\n    const IL = I.slice(0, 32);\n    const IR = I.slice(32); // if parse256(IL) >= n, proceed with the next value for i\n\n    if (!ecc.isPrivate(IL)) return this.derive(index + 1); // Private parent key -> private child key\n\n    let hd;\n\n    if (!this.isNeutered()) {\n      // ki = parse256(IL) + kpar (mod n)\n      const ki = ecc.privateAdd(this.privateKey, IL); // In case ki == 0, proceed with the next value for i\n\n      if (ki == null) return this.derive(index + 1);\n      hd = fromPrivateKeyLocal(ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0)); // Public parent key -> public child key\n    } else {\n      // Ki = point(parse256(IL)) + Kpar\n      //    = G*IL + Kpar\n      const Ki = ecc.pointAddScalar(this.publicKey, IL, true); // In case Ki is the point at infinity, proceed with the next value for i\n\n      if (Ki === null) return this.derive(index + 1);\n      hd = fromPublicKeyLocal(Ki, IR, this.network, this.depth + 1, index, this.fingerprint.readUInt32BE(0));\n    }\n\n    return hd;\n  }\n\n  deriveHardened(index) {\n    typeforce(UInt31, index); // Only derives hardened private keys by default\n\n    return this.derive(index + HIGHEST_BIT);\n  }\n\n  derivePath(path) {\n    typeforce(BIP32Path, path);\n    let splitPath = path.split('/');\n\n    if (splitPath[0] === 'm') {\n      if (this.parentFingerprint) throw new TypeError('Expected master, got child');\n      splitPath = splitPath.slice(1);\n    }\n\n    return splitPath.reduce((prevHd, indexStr) => {\n      let index;\n\n      if (indexStr.slice(-1) === \"'\") {\n        index = parseInt(indexStr.slice(0, -1), 10);\n        return prevHd.deriveHardened(index);\n      } else {\n        index = parseInt(indexStr, 10);\n        return prevHd.derive(index);\n      }\n    }, this);\n  }\n\n  sign(hash, lowR) {\n    if (!this.privateKey) throw new Error('Missing private key');\n    if (lowR === undefined) lowR = this.lowR;\n\n    if (lowR === false) {\n      return ecc.sign(hash, this.privateKey);\n    } else {\n      let sig = ecc.sign(hash, this.privateKey);\n      const extraData = Buffer.alloc(32, 0);\n      let counter = 0; // if first try is lowR, skip the loop\n      // for second try and on, add extra entropy counting up\n\n      while (sig[0] > 0x7f) {\n        counter++;\n        extraData.writeUIntLE(counter, 0, 6);\n        sig = ecc.signWithEntropy(hash, this.privateKey, extraData);\n      }\n\n      return sig;\n    }\n  }\n\n  verify(hash, signature) {\n    return ecc.verify(hash, this.publicKey, signature);\n  }\n\n}\n\nfunction fromBase58(inString, network) {\n  const buffer = bs58check.decode(inString);\n  if (buffer.length !== 78) throw new TypeError('Invalid buffer length');\n  network = network || BITCOIN; // 4 bytes: version bytes\n\n  const version = buffer.readUInt32BE(0);\n  if (version !== network.bip32.private && version !== network.bip32.public) throw new TypeError('Invalid network version'); // 1 byte: depth: 0x00 for master nodes, 0x01 for level-1 descendants, ...\n\n  const depth = buffer[4]; // 4 bytes: the fingerprint of the parent's key (0x00000000 if master key)\n\n  const parentFingerprint = buffer.readUInt32BE(5);\n\n  if (depth === 0) {\n    if (parentFingerprint !== 0x00000000) throw new TypeError('Invalid parent fingerprint');\n  } // 4 bytes: child number. This is the number i in xi = xpar/i, with xi the key being serialized.\n  // This is encoded in MSB order. (0x00000000 if master key)\n\n\n  const index = buffer.readUInt32BE(9);\n  if (depth === 0 && index !== 0) throw new TypeError('Invalid index'); // 32 bytes: the chain code\n\n  const chainCode = buffer.slice(13, 45);\n  let hd; // 33 bytes: private key data (0x00 + k)\n\n  if (version === network.bip32.private) {\n    if (buffer.readUInt8(45) !== 0x00) throw new TypeError('Invalid private key');\n    const k = buffer.slice(46, 78);\n    hd = fromPrivateKeyLocal(k, chainCode, network, depth, index, parentFingerprint); // 33 bytes: public key data (0x02 + X or 0x03 + X)\n  } else {\n    const X = buffer.slice(45, 78);\n    hd = fromPublicKeyLocal(X, chainCode, network, depth, index, parentFingerprint);\n  }\n\n  return hd;\n}\n\nexports.fromBase58 = fromBase58;\n\nfunction fromPrivateKey(privateKey, chainCode, network) {\n  return fromPrivateKeyLocal(privateKey, chainCode, network);\n}\n\nexports.fromPrivateKey = fromPrivateKey;\n\nfunction fromPrivateKeyLocal(privateKey, chainCode, network, depth, index, parentFingerprint) {\n  typeforce({\n    privateKey: UINT256_TYPE,\n    chainCode: UINT256_TYPE\n  }, {\n    privateKey,\n    chainCode\n  });\n  network = network || BITCOIN;\n  if (!ecc.isPrivate(privateKey)) throw new TypeError('Private key not in range [1, n)');\n  return new BIP32(privateKey, undefined, chainCode, network, depth, index, parentFingerprint);\n}\n\nfunction fromPublicKey(publicKey, chainCode, network) {\n  return fromPublicKeyLocal(publicKey, chainCode, network);\n}\n\nexports.fromPublicKey = fromPublicKey;\n\nfunction fromPublicKeyLocal(publicKey, chainCode, network, depth, index, parentFingerprint) {\n  typeforce({\n    publicKey: typeforce.BufferN(33),\n    chainCode: UINT256_TYPE\n  }, {\n    publicKey,\n    chainCode\n  });\n  network = network || BITCOIN; // verify the X coordinate is a point on the curve\n\n  if (!ecc.isPoint(publicKey)) throw new TypeError('Point is not on the curve');\n  return new BIP32(undefined, publicKey, chainCode, network, depth, index, parentFingerprint);\n}\n\nfunction fromSeed(seed, network) {\n  typeforce(typeforce.Buffer, seed);\n  if (seed.length < 16) throw new TypeError('Seed should be at least 128 bits');\n  if (seed.length > 64) throw new TypeError('Seed should be at most 512 bits');\n  network = network || BITCOIN;\n  const I = crypto.hmacSHA512(Buffer.from('Bitcoin seed', 'utf8'), seed);\n  const IL = I.slice(0, 32);\n  const IR = I.slice(32);\n  return fromPrivateKey(IL, IR, network);\n}\n\nexports.fromSeed = fromSeed;","map":null,"metadata":{},"sourceType":"script"}