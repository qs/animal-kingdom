{"ast":null,"code":"// Generated by IcedCoffeeScript 108.0.8\n(function () {\n  var CombineBase,\n      Concat,\n      HMAC,\n      SHA3,\n      SHA512,\n      WordArray,\n      XOR,\n      bulk_sign,\n      _ref,\n      __hasProp = {}.hasOwnProperty,\n      __extends = function (child, parent) {\n    for (var key in parent) {\n      if (__hasProp.call(parent, key)) child[key] = parent[key];\n    }\n\n    function ctor() {\n      this.constructor = child;\n    }\n\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n    child.__super__ = parent.prototype;\n    return child;\n  };\n\n  _ref = require('./hmac'), HMAC = _ref.HMAC, bulk_sign = _ref.bulk_sign;\n  SHA512 = require('./sha512').SHA512;\n  SHA3 = require('./sha3').SHA3;\n  WordArray = require('./wordarray').WordArray;\n\n  CombineBase = function () {\n    function CombineBase() {\n      this.hasherBlockSize = this.hashers[0].hasherBlockSize;\n      this.hasherBlockSizeBytes = this.hasherBlockSize * 4;\n      this.reset();\n    }\n\n    CombineBase.prototype.reset = function () {\n      var h, _i, _len, _ref1;\n\n      _ref1 = this.hashers;\n\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        h = _ref1[_i];\n        h.reset();\n      }\n\n      return this;\n    };\n\n    CombineBase.prototype.update = function (w) {\n      var h, _i, _len, _ref1;\n\n      _ref1 = this.hashers;\n\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        h = _ref1[_i];\n        h.update(w);\n      }\n\n      return this;\n    };\n\n    CombineBase.prototype.scrub = function () {\n      var h, _i, _len, _ref1;\n\n      _ref1 = this.hashers;\n\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        h = _ref1[_i];\n        h.scrub();\n      }\n\n      return this;\n    };\n\n    CombineBase.prototype.finalize = function (w) {\n      var h, hashes, out, _i, _len, _ref1;\n\n      hashes = function () {\n        var _i, _len, _ref1, _results;\n\n        _ref1 = this.hashers;\n        _results = [];\n\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          h = _ref1[_i];\n\n          _results.push(h.finalize(w));\n        }\n\n        return _results;\n      }.call(this);\n\n      out = hashes[0];\n      _ref1 = hashes.slice(1);\n\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        h = _ref1[_i];\n\n        this._coalesce(out, h);\n\n        h.scrub();\n      }\n\n      return out;\n    };\n\n    return CombineBase;\n  }();\n\n  Concat = function (_super) {\n    __extends(Concat, _super);\n\n    function Concat(key, klasses) {\n      var hm, i, klass, subkey, subkeys;\n\n      if (klasses == null) {\n        klasses = [SHA512, SHA3];\n      }\n\n      subkeys = key.split(klasses.length);\n\n      this.hashers = function () {\n        var _i, _len, _results;\n\n        _results = [];\n\n        for (i = _i = 0, _len = klasses.length; _i < _len; i = ++_i) {\n          klass = klasses[i];\n          subkey = subkeys[i];\n          hm = new HMAC(subkey, klass);\n          subkey.scrub();\n\n          _results.push(hm);\n        }\n\n        return _results;\n      }();\n\n      Concat.__super__.constructor.call(this);\n    }\n\n    Concat.get_output_size = function () {\n      return SHA512.output_size + SHA3.output_size;\n    };\n\n    Concat.prototype._coalesce = function (out, h) {\n      return out.concat(h);\n    };\n\n    Concat.prototype.get_output_size = function () {\n      var h, tot, _i, _len, _ref1;\n\n      tot = 0;\n      _ref1 = this.hashers;\n\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        h = _ref1[_i];\n        tot += h.get_output_size();\n      }\n\n      return tot;\n    };\n\n    Concat.sign = function (_arg) {\n      var input, key;\n      key = _arg.key, input = _arg.input;\n      return new Concat(key).finalize(input);\n    };\n\n    Concat.bulk_sign = function (args, cb) {\n      args.klass = Concat;\n      args.what = \"HMAC-SHA512-SHA3\";\n      return bulk_sign(args, cb);\n    };\n\n    return Concat;\n  }(CombineBase);\n\n  XOR = function (_super) {\n    __extends(XOR, _super);\n\n    function XOR(key, klasses) {\n      var klass;\n\n      if (klasses == null) {\n        klasses = [SHA512, SHA3];\n      }\n\n      this.hashers = function () {\n        var _i, _len, _results;\n\n        _results = [];\n\n        for (_i = 0, _len = klasses.length; _i < _len; _i++) {\n          klass = klasses[_i];\n\n          _results.push(new HMAC(key, klass));\n        }\n\n        return _results;\n      }();\n\n      XOR.__super__.constructor.call(this);\n    }\n\n    XOR.prototype.reset = function () {\n      var h, i, _i, _len, _ref1;\n\n      XOR.__super__.reset.call(this);\n\n      _ref1 = this.hashers;\n\n      for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {\n        h = _ref1[i];\n        h.update(new WordArray([i]));\n      }\n\n      return this;\n    };\n\n    XOR.get_output_size = function () {\n      return Math.max(SHA512.output_size, SHA3.output_size);\n    };\n\n    XOR.prototype._coalesce = function (out, h) {\n      return out.xor(h, {});\n    };\n\n    XOR.prototype.get_output_size = function () {\n      var h;\n      return Math.max.apply(Math, function () {\n        var _i, _len, _ref1, _results;\n\n        _ref1 = this.hashers;\n        _results = [];\n\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n          h = _ref1[_i];\n\n          _results.push(h.get_output_size());\n        }\n\n        return _results;\n      }.call(this));\n    };\n\n    XOR.sign = function (_arg) {\n      var input, key;\n      key = _arg.key, input = _arg.input;\n      return new XOR(key).finalize(input);\n    };\n\n    XOR.bulk_sign = function (arg, cb) {\n      arg.klass = XOR;\n      arg.what = \"HMAC-SHA512-XOR-SHA3\";\n      return bulk_sign(arg, cb);\n    };\n\n    return XOR;\n  }(CombineBase);\n\n  exports.Concat = Concat;\n  exports.XOR = XOR;\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}