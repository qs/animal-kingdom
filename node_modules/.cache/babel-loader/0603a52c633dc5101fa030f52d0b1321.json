{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst NETWORKS = require('./networks');\n\nconst types = require('./types');\n\nconst ecc = require('tiny-secp256k1');\n\nconst randomBytes = require('randombytes');\n\nconst typeforce = require('typeforce');\n\nconst wif = require('wif');\n\nconst isOptions = typeforce.maybe(typeforce.compile({\n  compressed: types.maybe(types.Boolean),\n  network: types.maybe(types.Network)\n}));\n\nclass ECPair {\n  constructor(__D, __Q, options) {\n    this.__D = __D;\n    this.__Q = __Q;\n    this.lowR = false;\n    if (options === undefined) options = {};\n    this.compressed = options.compressed === undefined ? true : options.compressed;\n    this.network = options.network || NETWORKS.bitcoin;\n    if (__Q !== undefined) this.__Q = ecc.pointCompress(__Q, this.compressed);\n  }\n\n  get privateKey() {\n    return this.__D;\n  }\n\n  get publicKey() {\n    if (!this.__Q) this.__Q = ecc.pointFromScalar(this.__D, this.compressed);\n    return this.__Q;\n  }\n\n  toWIF() {\n    if (!this.__D) throw new Error('Missing private key');\n    return wif.encode(this.network.wif, this.__D, this.compressed);\n  }\n\n  sign(hash, lowR) {\n    if (!this.__D) throw new Error('Missing private key');\n    if (lowR === undefined) lowR = this.lowR;\n\n    if (lowR === false) {\n      return ecc.sign(hash, this.__D);\n    } else {\n      let sig = ecc.sign(hash, this.__D);\n      const extraData = Buffer.alloc(32, 0);\n      let counter = 0; // if first try is lowR, skip the loop\n      // for second try and on, add extra entropy counting up\n\n      while (sig[0] > 0x7f) {\n        counter++;\n        extraData.writeUIntLE(counter, 0, 6);\n        sig = ecc.signWithEntropy(hash, this.__D, extraData);\n      }\n\n      return sig;\n    }\n  }\n\n  verify(hash, signature) {\n    return ecc.verify(hash, this.publicKey, signature);\n  }\n\n}\n\nfunction fromPrivateKey(buffer, options) {\n  typeforce(types.Buffer256bit, buffer);\n  if (!ecc.isPrivate(buffer)) throw new TypeError('Private key not in range [1, n)');\n  typeforce(isOptions, options);\n  return new ECPair(buffer, undefined, options);\n}\n\nexports.fromPrivateKey = fromPrivateKey;\n\nfunction fromPublicKey(buffer, options) {\n  typeforce(ecc.isPoint, buffer);\n  typeforce(isOptions, options);\n  return new ECPair(undefined, buffer, options);\n}\n\nexports.fromPublicKey = fromPublicKey;\n\nfunction fromWIF(wifString, network) {\n  const decoded = wif.decode(wifString);\n  const version = decoded.version; // list of networks?\n\n  if (types.Array(network)) {\n    network = network.filter(x => {\n      return version === x.wif;\n    }).pop();\n    if (!network) throw new Error('Unknown network version'); // otherwise, assume a network object (or default to bitcoin)\n  } else {\n    network = network || NETWORKS.bitcoin;\n    if (version !== network.wif) throw new Error('Invalid network version');\n  }\n\n  return fromPrivateKey(decoded.privateKey, {\n    compressed: decoded.compressed,\n    network: network\n  });\n}\n\nexports.fromWIF = fromWIF;\n\nfunction makeRandom(options) {\n  typeforce(isOptions, options);\n  if (options === undefined) options = {};\n  const rng = options.rng || randomBytes;\n  let d;\n\n  do {\n    d = rng(32);\n    typeforce(types.Buffer256bit, d);\n  } while (!ecc.isPrivate(d));\n\n  return fromPrivateKey(d, options);\n}\n\nexports.makeRandom = makeRandom;","map":null,"metadata":{},"sourceType":"script"}