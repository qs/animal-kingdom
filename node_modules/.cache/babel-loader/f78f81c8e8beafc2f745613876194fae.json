{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"../utils\");\n\nconst logger_1 = require(\"../logger\");\n/**\n * Detects if the native auth-browser is installed and is successfully\n * launched via a custom protocol URI.\n * @param {String} authRequest\n * The encoded authRequest to be used as a query param in the custom URI.\n * @param {String} successCallback\n * The callback that is invoked when the protocol handler was detected.\n * @param {String} failCallback\n * The callback that is invoked when the protocol handler was not detected.\n * @return {void}\n */\n\n\nfunction launchCustomProtocol(authRequest, successCallback, failCallback) {\n  // Create a unique ID used for this protocol detection attempt.\n  const echoReplyID = Math.random().toString(36).substr(2, 9);\n  const echoReplyKeyPrefix = 'echo-reply-';\n  const echoReplyKey = \"\".concat(echoReplyKeyPrefix).concat(echoReplyID);\n\n  const _utils_1$getGlobalObj = utils_1.getGlobalObjects(['localStorage', 'document', 'setTimeout', 'clearTimeout', 'addEventListener', 'removeEventListener'], {\n    throwIfUnavailable: true,\n    usageDesc: 'detectProtocolLaunch'\n  }),\n        localStorage = _utils_1$getGlobalObj.localStorage,\n        document = _utils_1$getGlobalObj.document,\n        setTimeout = _utils_1$getGlobalObj.setTimeout,\n        clearTimeout = _utils_1$getGlobalObj.clearTimeout,\n        addEventListener = _utils_1$getGlobalObj.addEventListener,\n        removeEventListener = _utils_1$getGlobalObj.removeEventListener; // Use localStorage as a reliable cross-window communication method.\n  // Create the storage entry to signal a protocol detection attempt for the\n  // next browser window to check.\n\n\n  localStorage.setItem(echoReplyKey, Date.now().toString());\n\n  const cleanUpLocalStorage = () => {\n    try {\n      localStorage.removeItem(echoReplyKey); // Also clear out any stale echo-reply keys older than 1 hour.\n\n      for (let i = 0; i < localStorage.length; i++) {\n        const storageKey = localStorage.key(i);\n\n        if (storageKey && storageKey.startsWith(echoReplyKeyPrefix)) {\n          const storageValue = localStorage.getItem(storageKey);\n\n          if (storageValue === 'success' || Date.now() - parseInt(storageValue, 10) > 3600000) {\n            localStorage.removeItem(storageKey);\n          }\n        }\n      }\n    } catch (err) {\n      logger_1.Logger.error('Exception cleaning up echo-reply entries in localStorage');\n      logger_1.Logger.error(err);\n    }\n  };\n\n  const detectionTimeout = 1000;\n  let redirectToWebAuthTimer = 0;\n\n  const cancelWebAuthRedirectTimer = () => {\n    if (redirectToWebAuthTimer) {\n      clearTimeout(redirectToWebAuthTimer);\n      redirectToWebAuthTimer = 0;\n    }\n  };\n\n  const startWebAuthRedirectTimer = (timeout = detectionTimeout) => {\n    cancelWebAuthRedirectTimer();\n    redirectToWebAuthTimer = setTimeout(() => {\n      if (redirectToWebAuthTimer) {\n        cancelWebAuthRedirectTimer();\n        let nextFunc;\n\n        if (localStorage.getItem(echoReplyKey) === 'success') {\n          logger_1.Logger.info('Protocol echo reply detected.');\n          nextFunc = successCallback;\n        } else {\n          logger_1.Logger.info('Protocol handler not detected.');\n          nextFunc = failCallback;\n        }\n\n        failCallback = () => {};\n\n        successCallback = () => {};\n\n        cleanUpLocalStorage(); // Briefly wait since localStorage changes can \n        // sometimes be ignored when immediately redirected.\n\n        setTimeout(() => nextFunc(), 100);\n      }\n    }, timeout);\n  };\n\n  startWebAuthRedirectTimer();\n  const inputPromptTracker = document.createElement('input');\n  inputPromptTracker.type = 'text'; // Setting display:none on an element prevents them from being focused/blurred.\n  // So we hide using 0 width/height/opacity, and set position:fixed so that the\n  // page does not scroll when the element is focused. \n\n  const hiddenCssStyle = 'all: initial; position: fixed; top: 0; height: 0; width: 0; opacity: 0;';\n  inputPromptTracker.style.cssText = hiddenCssStyle; // If the the focus of a page element is immediately changed then this likely indicates \n  // the protocol handler is installed, and the browser is prompting the user if they want \n  // to open the application. \n\n  const inputBlurredFunc = () => {\n    // Use a timeout of 100ms to ignore instant toggles between blur and focus.\n    // Browsers often perform an instant blur & focus when the protocol handler is working\n    // but not showing any browser prompts, so we want to ignore those instances.\n    let isRefocused = false;\n    inputPromptTracker.addEventListener('focus', () => {\n      isRefocused = true;\n    }, {\n      once: true,\n      capture: true\n    });\n    setTimeout(() => {\n      if (redirectToWebAuthTimer && !isRefocused) {\n        logger_1.Logger.info('Detected possible browser prompt for opening the protocol handler app.');\n        clearTimeout(redirectToWebAuthTimer);\n        inputPromptTracker.addEventListener('focus', () => {\n          if (redirectToWebAuthTimer) {\n            logger_1.Logger.info('Possible browser prompt closed, restarting auth redirect timeout.');\n            startWebAuthRedirectTimer();\n          }\n        }, {\n          once: true,\n          capture: true\n        });\n      }\n    }, 100);\n  };\n\n  inputPromptTracker.addEventListener('blur', inputBlurredFunc, {\n    once: true,\n    capture: true\n  });\n  setTimeout(() => inputPromptTracker.removeEventListener('blur', inputBlurredFunc), 200);\n  document.body.appendChild(inputPromptTracker);\n  inputPromptTracker.focus(); // Detect if document.visibility is immediately changed which is a strong \n  // indication that the protocol handler is working. We don't know for sure and \n  // can't predict future browser changes, so only increase the redirect timeout.\n  // This reduces the probability of a false-negative (where local auth works, but \n  // the original page was redirect to web auth because something took too long),\n\n  const pageVisibilityChanged = () => {\n    if (document.hidden && redirectToWebAuthTimer) {\n      logger_1.Logger.info('Detected immediate page visibility change (protocol handler probably working).');\n      startWebAuthRedirectTimer(3000);\n    }\n  };\n\n  document.addEventListener('visibilitychange', pageVisibilityChanged, {\n    once: true,\n    capture: true\n  });\n  setTimeout(() => document.removeEventListener('visibilitychange', pageVisibilityChanged), 500); // Listen for the custom protocol echo reply via localStorage update event.\n\n  addEventListener('storage', function replyEventListener(event) {\n    if (event.key === echoReplyKey && localStorage.getItem(echoReplyKey) === 'success') {\n      // Custom protocol worked, cancel the web auth redirect timer.\n      cancelWebAuthRedirectTimer();\n      inputPromptTracker.removeEventListener('blur', inputBlurredFunc);\n      logger_1.Logger.info('Protocol echo reply detected from localStorage event.'); // Clean up event listener and localStorage.\n\n      removeEventListener('storage', replyEventListener);\n      const nextFunc = successCallback;\n\n      successCallback = () => {};\n\n      failCallback = () => {};\n\n      cleanUpLocalStorage(); // Briefly wait since localStorage changes can sometimes \n      // be ignored when immediately redirected.\n\n      setTimeout(() => nextFunc(), 100);\n    }\n  }, false); // Use iframe technique for launching the protocol URI rather than setting `window.location`.\n  // This method prevents browsers like Safari, Opera, Firefox from showing error prompts\n  // about unknown protocol handler when app is not installed, and avoids an empty\n  // browser tab when the app is installed. \n\n  logger_1.Logger.info('Attempting protocol launch via iframe injection.');\n  const locationSrc = \"\".concat(utils_1.BLOCKSTACK_HANDLER, \":\").concat(authRequest, \"&echo=\").concat(echoReplyID);\n  const iframe = document.createElement('iframe');\n  const iframeStyle = 'all: initial; display: none; position: fixed; top: 0; height: 0; width: 0; opacity: 0;';\n  iframe.style.cssText = iframeStyle;\n  iframe.src = locationSrc;\n  document.body.appendChild(iframe);\n}\n\nexports.launchCustomProtocol = launchCustomProtocol;","map":null,"metadata":{},"sourceType":"script"}