{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nconst typeFields_1 = require('../../typeFields');\n\nconst range = n => [...Array(n).keys()];\n\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {\n    throw new Error('Decode Error: could not decode globalXpub with key 0x' + keyVal.key.toString('hex'));\n  }\n\n  if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {\n    throw new Error('Decode Error: globalXpub has invalid extended pubkey in key 0x' + keyVal.key.toString('hex'));\n  }\n\n  if (keyVal.value.length / 4 % 1 !== 0) {\n    throw new Error('Decode Error: Global GLOBAL_XPUB value length should be multiple of 4');\n  }\n\n  const extendedPubkey = keyVal.key.slice(1);\n  const data = {\n    masterFingerprint: keyVal.value.slice(0, 4),\n    extendedPubkey,\n    path: 'm'\n  };\n\n  for (const i of range(keyVal.value.length / 4 - 1)) {\n    const val = keyVal.value.readUInt32LE(i * 4 + 4);\n    const isHard = !!(val & 0x80000000);\n    const idx = val & 0x7fffffff;\n    data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n  }\n\n  return data;\n}\n\nexports.decode = decode;\n\nfunction encode(data) {\n  const head = Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);\n  const key = Buffer.concat([head, data.extendedPubkey]);\n  const splitPath = data.path.split('/');\n  const value = Buffer.allocUnsafe(splitPath.length * 4);\n  data.masterFingerprint.copy(value, 0);\n  let offset = 4;\n  splitPath.slice(1).forEach(level => {\n    const isHard = level.slice(-1) === \"'\";\n    let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n    if (isHard) num += 0x80000000;\n    value.writeUInt32LE(num, offset);\n    offset += 4;\n  });\n  return {\n    key,\n    value\n  };\n}\n\nexports.encode = encode;\nexports.expected = '{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }';\n\nfunction check(data) {\n  const epk = data.extendedPubkey;\n  const mfp = data.masterFingerprint;\n  const p = data.path;\n  return Buffer.isBuffer(epk) && epk.length === 78 && [2, 3].indexOf(epk[45]) > -1 && Buffer.isBuffer(mfp) && mfp.length === 4 && typeof p === 'string' && !!p.match(/^m(\\/\\d+'?)+$/);\n}\n\nexports.check = check;\n\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.extendedPubkey.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return array.filter(v => v.extendedPubkey.equals(item.extendedPubkey)).length === 0;\n}\n\nexports.canAddToArray = canAddToArray;","map":null,"metadata":{},"sourceType":"script"}