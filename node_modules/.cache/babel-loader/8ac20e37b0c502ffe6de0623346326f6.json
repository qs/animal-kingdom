{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst base64url_1 = __importDefault(require(\"base64url\"));\n\nconst cryptoClients_1 = require(\"./cryptoClients\");\n\nconst errors_1 = require(\"./errors\");\n\nfunction createSigningInput(payload, header) {\n  const tokenParts = []; // add in the header\n\n  const encodedHeader = base64url_1.default.encode(JSON.stringify(header));\n  tokenParts.push(encodedHeader); // add in the payload\n\n  const encodedPayload = base64url_1.default.encode(JSON.stringify(payload));\n  tokenParts.push(encodedPayload); // prepare the message\n\n  const signingInput = tokenParts.join('.'); // return the signing input\n\n  return signingInput;\n}\n\nfunction createUnsecuredToken(payload) {\n  const header = {\n    typ: 'JWT',\n    alg: 'none'\n  };\n  return createSigningInput(payload, header) + '.';\n}\n\nexports.createUnsecuredToken = createUnsecuredToken;\n\nclass TokenSigner {\n  constructor(signingAlgorithm, rawPrivateKey) {\n    if (!(signingAlgorithm && rawPrivateKey)) {\n      throw new errors_1.MissingParametersError('a signing algorithm and private key are required');\n    }\n\n    if (typeof signingAlgorithm !== 'string') {\n      throw new Error('signing algorithm parameter must be a string');\n    }\n\n    signingAlgorithm = signingAlgorithm.toUpperCase();\n\n    if (!cryptoClients_1.cryptoClients.hasOwnProperty(signingAlgorithm)) {\n      throw new Error('invalid signing algorithm');\n    }\n\n    this.tokenType = 'JWT';\n    this.cryptoClient = cryptoClients_1.cryptoClients[signingAlgorithm];\n    this.rawPrivateKey = rawPrivateKey;\n  }\n\n  header(header = {}) {\n    const defaultHeader = {\n      typ: this.tokenType,\n      alg: this.cryptoClient.algorithmName\n    };\n    return Object.assign({}, defaultHeader, header);\n  }\n\n  sign(payload, expanded = false, customHeader = {}) {\n    // generate the token header\n    const header = this.header(customHeader); // prepare the message to be signed\n\n    const signingInput = createSigningInput(payload, header);\n    const signingInputHash = this.cryptoClient.createHash(signingInput); // sign the message and add in the signature\n\n    const signature = this.cryptoClient.signHash(signingInputHash, this.rawPrivateKey);\n\n    if (expanded) {\n      return {\n        'header': [base64url_1.default.encode(JSON.stringify(header))],\n        'payload': JSON.stringify(payload),\n        'signature': [signature]\n      };\n    } else {\n      return [signingInput, signature].join('.');\n    }\n  }\n\n}\n\nexports.TokenSigner = TokenSigner;","map":null,"metadata":{},"sourceType":"script"}