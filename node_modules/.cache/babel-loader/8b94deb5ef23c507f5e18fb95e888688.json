{"ast":null,"code":"// Generated by IcedCoffeeScript 108.0.8\n(function () {\n  var C,\n      Deferrals,\n      Rendezvous,\n      exceptionHandler,\n      findDeferral,\n      make_defer_return,\n      stackWalk,\n      tick_counter,\n      trampoline,\n      warn,\n      __active_trace,\n      __c,\n      _trace_to_string,\n      __slice = [].slice;\n\n  C = require('./const');\n\n  make_defer_return = function (obj, defer_args, id, trace_template, multi) {\n    var k, ret, trace, v;\n    trace = {};\n\n    for (k in trace_template) {\n      v = trace_template[k];\n      trace[k] = v;\n    }\n\n    trace[C.lineno] = defer_args != null ? defer_args[C.lineno] : void 0;\n\n    ret = function () {\n      var inner_args, o, _ref;\n\n      inner_args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n\n      if (defer_args != null) {\n        if ((_ref = defer_args.assign_fn) != null) {\n          _ref.apply(null, inner_args);\n        }\n      }\n\n      if (obj) {\n        o = obj;\n\n        if (!multi) {\n          obj = null;\n        }\n\n        return o._fulfill(id, trace);\n      } else {\n        return warn(\"overused deferral at \" + _trace_to_string(trace));\n      }\n    };\n\n    ret[C.trace] = trace;\n    return ret;\n  };\n\n  __c = 0;\n\n  tick_counter = function (mod) {\n    __c++;\n\n    if (__c % mod === 0) {\n      __c = 0;\n      return true;\n    } else {\n      return false;\n    }\n  };\n\n  __active_trace = null;\n\n  _trace_to_string = function (tr) {\n    var fn;\n    fn = tr[C.funcname] || \"<anonymous>\";\n    return \"\" + fn + \" (\" + tr[C.filename] + \":\" + (tr[C.lineno] + 1) + \")\";\n  };\n\n  warn = function (m) {\n    return typeof console !== \"undefined\" && console !== null ? console.error(\"ICED warning: \" + m) : void 0;\n  };\n\n  exports.trampoline = trampoline = function (fn) {\n    if (!tick_counter(500)) {\n      return fn();\n    } else if ((typeof process !== \"undefined\" && process !== null ? process.nextTick : void 0) != null) {\n      return process.nextTick(fn);\n    } else {\n      return setTimeout(fn);\n    }\n  };\n\n  exports.Deferrals = Deferrals = function () {\n    function Deferrals(k, trace) {\n      this.trace = trace;\n      this.continuation = k;\n      this.count = 1;\n      this.ret = null;\n    }\n\n    Deferrals.prototype._call = function (trace) {\n      var c;\n\n      if (this.continuation) {\n        __active_trace = trace;\n        c = this.continuation;\n        this.continuation = null;\n        return c(this.ret);\n      } else {\n        return warn(\"Entered dead await at \" + _trace_to_string(trace));\n      }\n    };\n\n    Deferrals.prototype._fulfill = function (id, trace) {\n      if (--this.count > 0) {} else {\n        return trampoline(function (_this) {\n          return function () {\n            return _this._call(trace);\n          };\n        }(this));\n      }\n    };\n\n    Deferrals.prototype.defer = function (args) {\n      var self;\n      this.count++;\n      self = this;\n      return make_defer_return(self, args, null, this.trace);\n    };\n\n    return Deferrals;\n  }();\n\n  exports.findDeferral = findDeferral = function (args) {\n    var a, _i, _len;\n\n    for (_i = 0, _len = args.length; _i < _len; _i++) {\n      a = args[_i];\n\n      if (a != null ? a[C.trace] : void 0) {\n        return a;\n      }\n    }\n\n    return null;\n  };\n\n  exports.Rendezvous = Rendezvous = function () {\n    var RvId;\n\n    function Rendezvous() {\n      this.completed = [];\n      this.waiters = [];\n      this.defer_id = 0;\n    }\n\n    RvId = function () {\n      function RvId(rv, id, multi) {\n        this.rv = rv;\n        this.id = id;\n        this.multi = multi;\n      }\n\n      RvId.prototype.defer = function (defer_args) {\n        return this.rv._defer_with_id(this.id, defer_args, this.multi);\n      };\n\n      return RvId;\n    }();\n\n    Rendezvous.prototype.wait = function (cb) {\n      var x;\n\n      if (this.completed.length) {\n        x = this.completed.shift();\n        return cb(x);\n      } else {\n        return this.waiters.push(cb);\n      }\n    };\n\n    Rendezvous.prototype.defer = function (defer_args) {\n      var id;\n      id = this.defer_id++;\n      return this._defer_with_id(id, defer_args);\n    };\n\n    Rendezvous.prototype.id = function (i, multi) {\n      multi = !!multi;\n      return new RvId(this, i, multi);\n    };\n\n    Rendezvous.prototype._fulfill = function (id, trace) {\n      var cb;\n\n      if (this.waiters.length) {\n        cb = this.waiters.shift();\n        return cb(id);\n      } else {\n        return this.completed.push(id);\n      }\n    };\n\n    Rendezvous.prototype._defer_with_id = function (id, defer_args, multi) {\n      this.count++;\n      return make_defer_return(this, defer_args, id, {}, multi);\n    };\n\n    return Rendezvous;\n  }();\n\n  exports.stackWalk = stackWalk = function (cb) {\n    var line, ret, tr, _ref;\n\n    ret = [];\n    tr = cb ? cb[C.trace] : __active_trace;\n\n    while (tr) {\n      line = \"   at \" + _trace_to_string(tr);\n      ret.push(line);\n      tr = tr != null ? (_ref = tr[C.parent]) != null ? _ref[C.trace] : void 0 : void 0;\n    }\n\n    return ret;\n  };\n\n  exports.exceptionHandler = exceptionHandler = function (err, logger) {\n    var stack;\n\n    if (!logger) {\n      logger = console.error;\n    }\n\n    logger(err.stack);\n    stack = stackWalk();\n\n    if (stack.length) {\n      logger(\"Iced 'stack' trace (w/ real line numbers):\");\n      return logger(stack.join(\"\\n\"));\n    }\n  };\n\n  exports.catchExceptions = function (logger) {\n    return typeof process !== \"undefined\" && process !== null ? process.on('uncaughtException', function (err) {\n      exceptionHandler(err, logger);\n      return process.exit(1);\n    }) : void 0;\n  };\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}