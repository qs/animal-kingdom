{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst elliptic_1 = require(\"elliptic\"); // @ts-ignore\n\n\nconst asn1_js_1 = __importDefault(require(\"asn1.js\"));\n\nconst ECPrivateKeyASN = asn1_js_1.default.define('ECPrivateKey', function () {\n  // @ts-ignore\n  const self = this;\n  self.seq().obj(self.key('version').int(), self.key('privateKey').octstr(), self.key('parameters').explicit(0).objid().optional(), self.key('publicKey').explicit(1).bitstr().optional());\n});\nconst SubjectPublicKeyInfoASN = asn1_js_1.default.define('SubjectPublicKeyInfo', function () {\n  // @ts-ignore\n  const self = this;\n  self.seq().obj(self.key('algorithm').seq().obj(self.key(\"id\").objid(), self.key(\"curve\").objid()), self.key('pub').bitstr());\n});\nconst curves = {\n  secp256k1: {\n    curveParameters: [1, 3, 132, 0, 10],\n    privatePEMOptions: {\n      label: 'EC PRIVATE KEY'\n    },\n    publicPEMOptions: {\n      label: 'PUBLIC KEY'\n    },\n    curve: new elliptic_1.ec('secp256k1')\n  }\n};\n\nclass KeyEncoder {\n  constructor(options) {\n    if (typeof options === 'string') {\n      if (options !== 'secp256k1') {\n        throw new Error('Unknown curve ' + options);\n      }\n\n      options = curves[options];\n    }\n\n    this.options = options;\n    this.algorithmID = [1, 2, 840, 10045, 2, 1];\n  }\n\n  privateKeyObject(rawPrivateKey, rawPublicKey) {\n    const privateKeyObject = {\n      version: new bn_js_1.default(1),\n      privateKey: Buffer.from(rawPrivateKey, 'hex'),\n      parameters: this.options.curveParameters\n    };\n\n    if (rawPublicKey) {\n      privateKeyObject.publicKey = {\n        unused: 0,\n        data: Buffer.from(rawPublicKey, 'hex')\n      };\n    }\n\n    return privateKeyObject;\n  }\n\n  publicKeyObject(rawPublicKey) {\n    return {\n      algorithm: {\n        id: this.algorithmID,\n        curve: this.options.curveParameters\n      },\n      pub: {\n        unused: 0,\n        data: Buffer.from(rawPublicKey, 'hex')\n      }\n    };\n  }\n\n  encodePrivate(privateKey, originalFormat, destinationFormat) {\n    let privateKeyObject;\n    /* Parse the incoming private key and convert it to a private key object */\n\n    if (originalFormat === 'raw') {\n      if (typeof privateKey !== 'string') {\n        throw 'private key must be a string';\n      }\n\n      let keyPair = this.options.curve.keyFromPrivate(privateKey, 'hex');\n      let rawPublicKey = keyPair.getPublic('hex');\n      privateKeyObject = this.privateKeyObject(privateKey, rawPublicKey);\n    } else if (originalFormat === 'der') {\n      if (typeof privateKey !== 'string') {// do nothing\n      } else if (typeof privateKey === 'string') {\n        privateKey = Buffer.from(privateKey, 'hex');\n      } else {\n        throw 'private key must be a buffer or a string';\n      }\n\n      privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'der');\n    } else if (originalFormat === 'pem') {\n      if (typeof privateKey !== 'string') {\n        throw 'private key must be a string';\n      }\n\n      privateKeyObject = ECPrivateKeyASN.decode(privateKey, 'pem', this.options.privatePEMOptions);\n    } else {\n      throw 'invalid private key format';\n    }\n    /* Export the private key object to the desired format */\n\n\n    if (destinationFormat === 'raw') {\n      return privateKeyObject.privateKey.toString('hex');\n    } else if (destinationFormat === 'der') {\n      return ECPrivateKeyASN.encode(privateKeyObject, 'der').toString('hex');\n    } else if (destinationFormat === 'pem') {\n      return ECPrivateKeyASN.encode(privateKeyObject, 'pem', this.options.privatePEMOptions);\n    } else {\n      throw 'invalid destination format for private key';\n    }\n  }\n\n  encodePublic(publicKey, originalFormat, destinationFormat) {\n    let publicKeyObject;\n    /* Parse the incoming public key and convert it to a public key object */\n\n    if (originalFormat === 'raw') {\n      if (typeof publicKey !== 'string') {\n        throw 'public key must be a string';\n      }\n\n      publicKeyObject = this.publicKeyObject(publicKey);\n    } else if (originalFormat === 'der') {\n      if (typeof publicKey !== 'string') {// do nothing\n      } else if (typeof publicKey === 'string') {\n        publicKey = Buffer.from(publicKey, 'hex');\n      } else {\n        throw 'public key must be a buffer or a string';\n      }\n\n      publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'der');\n    } else if (originalFormat === 'pem') {\n      if (typeof publicKey !== 'string') {\n        throw 'public key must be a string';\n      }\n\n      publicKeyObject = SubjectPublicKeyInfoASN.decode(publicKey, 'pem', this.options.publicPEMOptions);\n    } else {\n      throw 'invalid public key format';\n    }\n    /* Export the private key object to the desired format */\n\n\n    if (destinationFormat === 'raw') {\n      return publicKeyObject.pub.data.toString('hex');\n    } else if (destinationFormat === 'der') {\n      return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'der').toString('hex');\n    } else if (destinationFormat === 'pem') {\n      return SubjectPublicKeyInfoASN.encode(publicKeyObject, 'pem', this.options.publicPEMOptions);\n    } else {\n      throw 'invalid destination format for public key';\n    }\n  }\n\n}\n\nKeyEncoder.ECPrivateKeyASN = ECPrivateKeyASN;\nKeyEncoder.SubjectPublicKeyInfoASN = SubjectPublicKeyInfoASN;\nexports.default = KeyEncoder;","map":null,"metadata":{},"sourceType":"script"}